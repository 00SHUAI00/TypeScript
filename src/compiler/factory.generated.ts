
// <auto-generated />
/// <reference path="factory.ts" />
namespace ts {
    export function createNumericLiteral(text?: string, location?: TextRange, flags?: NodeFlags): LiteralExpression {
        let node = createNode<LiteralExpression>(SyntaxKind.NumericLiteral, location, flags); 
        if (text) node.text = text;
        return node;
    }
    export function createStringLiteral(text?: string, location?: TextRange, flags?: NodeFlags): StringLiteral {
        let node = createNode<StringLiteral>(SyntaxKind.StringLiteral, location, flags); 
        if (text) node.text = text;
        return node;
    }
    export function createRegularExpressionLiteral(text?: string, location?: TextRange, flags?: NodeFlags): LiteralExpression {
        let node = createNode<LiteralExpression>(SyntaxKind.RegularExpressionLiteral, location, flags); 
        if (text) node.text = text;
        return node;
    }
    export function createNoSubstitutionTemplateLiteral(text?: string, location?: TextRange, flags?: NodeFlags): LiteralExpression {
        let node = createNode<LiteralExpression>(SyntaxKind.NoSubstitutionTemplateLiteral, location, flags); 
        if (text) node.text = text;
        return node;
    }
    export function createTemplateHead(text?: string, location?: TextRange, flags?: NodeFlags): LiteralExpression {
        let node = createNode<LiteralExpression>(SyntaxKind.TemplateHead, location, flags); 
        if (text) node.text = text;
        return node;
    }
    export function createTemplateMiddle(text?: string, location?: TextRange, flags?: NodeFlags): LiteralExpression {
        let node = createNode<LiteralExpression>(SyntaxKind.TemplateMiddle, location, flags); 
        if (text) node.text = text;
        return node;
    }
    export function createTemplateTail(text?: string, location?: TextRange, flags?: NodeFlags): LiteralExpression {
        let node = createNode<LiteralExpression>(SyntaxKind.TemplateTail, location, flags); 
        if (text) node.text = text;
        return node;
    }
    export function createIdentifier(text?: string, originalKeywordKind?: SyntaxKind, location?: TextRange, flags?: NodeFlags): Identifier {
        let node = createNode<Identifier>(SyntaxKind.Identifier, location, flags); 
        if (text) node.text = text;
        if (originalKeywordKind) node.originalKeywordKind = originalKeywordKind;
        return node;
    }
    export function createFalseKeyword(location?: TextRange, flags?: NodeFlags): PrimaryExpression {
        let node = createNode<PrimaryExpression>(SyntaxKind.FalseKeyword, location, flags); 
        return node;
    }
    export function createNullKeyword(location?: TextRange, flags?: NodeFlags): PrimaryExpression {
        let node = createNode<PrimaryExpression>(SyntaxKind.NullKeyword, location, flags); 
        return node;
    }
    export function createSuperKeyword(location?: TextRange, flags?: NodeFlags): PrimaryExpression {
        let node = createNode<PrimaryExpression>(SyntaxKind.SuperKeyword, location, flags); 
        return node;
    }
    export function createThisKeyword(location?: TextRange, flags?: NodeFlags): PrimaryExpression {
        let node = createNode<PrimaryExpression>(SyntaxKind.ThisKeyword, location, flags); 
        return node;
    }
    export function createTrueKeyword(location?: TextRange, flags?: NodeFlags): PrimaryExpression {
        let node = createNode<PrimaryExpression>(SyntaxKind.TrueKeyword, location, flags); 
        return node;
    }
    export function createQualifiedName(left?: EntityName, right?: Identifier, location?: TextRange, flags?: NodeFlags): QualifiedName {
        let node = createNode<QualifiedName>(SyntaxKind.QualifiedName, location, flags); 
        if (left) node.left = left;
        if (right) node.right = right;
        return node;
    }
    export function createComputedPropertyName(expression?: Expression, location?: TextRange, flags?: NodeFlags): ComputedPropertyName {
        let node = createNode<ComputedPropertyName>(SyntaxKind.ComputedPropertyName, location, flags); 
        if (expression) node.expression = expression;
        return node;
    }
    export function createTypeParameter(name?: Identifier, constraint?: TypeNode, expression?: Expression, location?: TextRange, flags?: NodeFlags): TypeParameterDeclaration {
        let node = createNode<TypeParameterDeclaration>(SyntaxKind.TypeParameter, location, flags); 
        if (name) node.name = name;
        if (constraint) node.constraint = constraint;
        if (expression) node.expression = expression;
        return node;
    }
    export function createParameter(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, dotDotDotToken?: Node, name?: BindingPattern | Identifier, questionToken?: Node, type?: TypeNode, initializer?: Expression, location?: TextRange, flags?: NodeFlags): ParameterDeclaration {
        let node = createNode<ParameterDeclaration>(SyntaxKind.Parameter, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (dotDotDotToken) node.dotDotDotToken = dotDotDotToken;
        if (name) node.name = name;
        if (questionToken) node.questionToken = questionToken;
        if (type) node.type = type;
        if (initializer) node.initializer = initializer;
        return node;
    }
    export function createDecorator(expression?: LeftHandSideExpression, location?: TextRange, flags?: NodeFlags): Decorator {
        let node = createNode<Decorator>(SyntaxKind.Decorator, location, flags); 
        if (expression) node.expression = expression;
        return node;
    }
    export function createPropertySignature(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, name?: PropertyName, questionToken?: Node, type?: TypeNode, location?: TextRange, flags?: NodeFlags): PropertySignature {
        let node = createNode<PropertySignature>(SyntaxKind.PropertySignature, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (name) node.name = name;
        if (questionToken) node.questionToken = questionToken;
        if (type) node.type = type;
        return node;
    }
    export function createPropertyDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, name?: PropertyName, type?: TypeNode, initializer?: Expression, location?: TextRange, flags?: NodeFlags): PropertyDeclaration {
        let node = createNode<PropertyDeclaration>(SyntaxKind.PropertyDeclaration, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (name) node.name = name;
        if (type) node.type = type;
        if (initializer) node.initializer = initializer;
        return node;
    }
    export function createMethodSignature(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, name?: PropertyName, questionToken?: Node, typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, type?: TypeNode, location?: TextRange, flags?: NodeFlags): MethodSignature {
        let node = createNode<MethodSignature>(SyntaxKind.MethodSignature, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (name) node.name = name;
        if (questionToken) node.questionToken = questionToken;
        if (typeParameters) node.typeParameters = createNodeArray(typeParameters);
        if (parameters) node.parameters = createNodeArray(parameters);
        if (type) node.type = type;
        return node;
    }
    export function createMethodDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, asteriskToken?: Node, name?: PropertyName, typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, type?: TypeNode, body?: FunctionBody, location?: TextRange, flags?: NodeFlags): MethodDeclaration {
        let node = createNode<MethodDeclaration>(SyntaxKind.MethodDeclaration, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (asteriskToken) node.asteriskToken = asteriskToken;
        if (name) node.name = name;
        if (typeParameters) node.typeParameters = createNodeArray(typeParameters);
        if (parameters) node.parameters = createNodeArray(parameters);
        if (type) node.type = type;
        if (body) node.body = body;
        return node;
    }
    export function createConstructor(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, parameters?: Array<ParameterDeclaration>, type?: TypeNode, body?: FunctionBody, location?: TextRange, flags?: NodeFlags): ConstructorDeclaration {
        let node = createNode<ConstructorDeclaration>(SyntaxKind.Constructor, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (parameters) node.parameters = createNodeArray(parameters);
        if (type) node.type = type;
        if (body) node.body = body;
        return node;
    }
    export function createGetAccessor(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, name?: PropertyName, parameters?: Array<ParameterDeclaration>, type?: TypeNode, body?: FunctionBody, location?: TextRange, flags?: NodeFlags): GetAccessorDeclaration {
        let node = createNode<GetAccessorDeclaration>(SyntaxKind.GetAccessor, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (name) node.name = name;
        if (parameters) node.parameters = createNodeArray(parameters);
        if (type) node.type = type;
        if (body) node.body = body;
        return node;
    }
    export function createSetAccessor(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, name?: PropertyName, parameters?: Array<ParameterDeclaration>, type?: TypeNode, body?: FunctionBody, location?: TextRange, flags?: NodeFlags): SetAccessorDeclaration {
        let node = createNode<SetAccessorDeclaration>(SyntaxKind.SetAccessor, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (name) node.name = name;
        if (parameters) node.parameters = createNodeArray(parameters);
        if (type) node.type = type;
        if (body) node.body = body;
        return node;
    }
    export function createCallSignature(typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, type?: TypeNode, questionToken?: Node, location?: TextRange, flags?: NodeFlags): CallSignatureDeclaration {
        let node = createNode<CallSignatureDeclaration>(SyntaxKind.CallSignature, location, flags); 
        if (typeParameters) node.typeParameters = createNodeArray(typeParameters);
        if (parameters) node.parameters = createNodeArray(parameters);
        if (type) node.type = type;
        if (questionToken) node.questionToken = questionToken;
        return node;
    }
    export function createConstructSignature(typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, type?: TypeNode, questionToken?: Node, location?: TextRange, flags?: NodeFlags): ConstructSignatureDeclaration {
        let node = createNode<ConstructSignatureDeclaration>(SyntaxKind.ConstructSignature, location, flags); 
        if (typeParameters) node.typeParameters = createNodeArray(typeParameters);
        if (parameters) node.parameters = createNodeArray(parameters);
        if (type) node.type = type;
        if (questionToken) node.questionToken = questionToken;
        return node;
    }
    export function createIndexSignature(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, parameters?: Array<ParameterDeclaration>, type?: TypeNode, questionToken?: Node, location?: TextRange, flags?: NodeFlags): IndexSignatureDeclaration {
        let node = createNode<IndexSignatureDeclaration>(SyntaxKind.IndexSignature, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (parameters) node.parameters = createNodeArray(parameters);
        if (type) node.type = type;
        if (questionToken) node.questionToken = questionToken;
        return node;
    }
    export function createTypePredicate(parameterName?: Identifier, type?: TypeNode, location?: TextRange, flags?: NodeFlags): TypePredicateNode {
        let node = createNode<TypePredicateNode>(SyntaxKind.TypePredicate, location, flags); 
        if (parameterName) node.parameterName = parameterName;
        if (type) node.type = type;
        return node;
    }
    export function createTypeReference(typeName?: EntityName, typeArguments?: Array<TypeNode>, location?: TextRange, flags?: NodeFlags): TypeReferenceNode {
        let node = createNode<TypeReferenceNode>(SyntaxKind.TypeReference, location, flags); 
        if (typeName) node.typeName = typeName;
        if (typeArguments) node.typeArguments = createNodeArray(typeArguments);
        return node;
    }
    export function createFunctionType(typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, type?: TypeNode, location?: TextRange, flags?: NodeFlags): FunctionTypeNode {
        let node = createNode<FunctionTypeNode>(SyntaxKind.FunctionType, location, flags); 
        if (typeParameters) node.typeParameters = createNodeArray(typeParameters);
        if (parameters) node.parameters = createNodeArray(parameters);
        if (type) node.type = type;
        return node;
    }
    export function createConstructorType(typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, type?: TypeNode, location?: TextRange, flags?: NodeFlags): ConstructorTypeNode {
        let node = createNode<ConstructorTypeNode>(SyntaxKind.ConstructorType, location, flags); 
        if (typeParameters) node.typeParameters = createNodeArray(typeParameters);
        if (parameters) node.parameters = createNodeArray(parameters);
        if (type) node.type = type;
        return node;
    }
    export function createTypeQuery(exprName?: EntityName, location?: TextRange, flags?: NodeFlags): TypeQueryNode {
        let node = createNode<TypeQueryNode>(SyntaxKind.TypeQuery, location, flags); 
        if (exprName) node.exprName = exprName;
        return node;
    }
    export function createTypeLiteral(members?: Array<TypeElement>, location?: TextRange, flags?: NodeFlags): TypeLiteralNode {
        let node = createNode<TypeLiteralNode>(SyntaxKind.TypeLiteral, location, flags); 
        if (members) node.members = createNodeArray(members);
        return node;
    }
    export function createArrayType(elementType?: TypeNode, location?: TextRange, flags?: NodeFlags): ArrayTypeNode {
        let node = createNode<ArrayTypeNode>(SyntaxKind.ArrayType, location, flags); 
        if (elementType) node.elementType = elementType;
        return node;
    }
    export function createTupleType(elementTypes?: Array<TypeNode>, location?: TextRange, flags?: NodeFlags): TupleTypeNode {
        let node = createNode<TupleTypeNode>(SyntaxKind.TupleType, location, flags); 
        if (elementTypes) node.elementTypes = createNodeArray(elementTypes);
        return node;
    }
    export function createUnionType(types?: Array<TypeNode>, location?: TextRange, flags?: NodeFlags): UnionTypeNode {
        let node = createNode<UnionTypeNode>(SyntaxKind.UnionType, location, flags); 
        if (types) node.types = createNodeArray(types);
        return node;
    }
    export function createIntersectionType(types?: Array<TypeNode>, location?: TextRange, flags?: NodeFlags): IntersectionTypeNode {
        let node = createNode<IntersectionTypeNode>(SyntaxKind.IntersectionType, location, flags); 
        if (types) node.types = createNodeArray(types);
        return node;
    }
    export function createParenthesizedType(type?: TypeNode, location?: TextRange, flags?: NodeFlags): ParenthesizedTypeNode {
        let node = createNode<ParenthesizedTypeNode>(SyntaxKind.ParenthesizedType, location, flags); 
        if (type) node.type = type;
        return node;
    }
    export function createObjectBindingPattern(elements?: Array<BindingElement>, location?: TextRange, flags?: NodeFlags): ObjectBindingPattern {
        let node = createNode<ObjectBindingPattern>(SyntaxKind.ObjectBindingPattern, location, flags); 
        if (elements) node.elements = createNodeArray(elements);
        return node;
    }
    export function createArrayBindingPattern(elements?: Array<BindingElement>, location?: TextRange, flags?: NodeFlags): ArrayBindingPattern {
        let node = createNode<ArrayBindingPattern>(SyntaxKind.ArrayBindingPattern, location, flags); 
        if (elements) node.elements = createNodeArray(elements);
        return node;
    }
    export function createBindingElement(propertyName?: Identifier, dotDotDotToken?: Node, name?: BindingPattern | Identifier, initializer?: Expression, location?: TextRange, flags?: NodeFlags): BindingElement {
        let node = createNode<BindingElement>(SyntaxKind.BindingElement, location, flags); 
        if (propertyName) node.propertyName = propertyName;
        if (dotDotDotToken) node.dotDotDotToken = dotDotDotToken;
        if (name) node.name = name;
        if (initializer) node.initializer = initializer;
        return node;
    }
    export function createArrayLiteralExpression(elements?: Array<Expression>, location?: TextRange, flags?: NodeFlags): ArrayLiteralExpression {
        let node = createNode<ArrayLiteralExpression>(SyntaxKind.ArrayLiteralExpression, location, flags); 
        if (elements) node.elements = createNodeArray(elements);
        return node;
    }
    export function createObjectLiteralExpression(properties?: Array<ObjectLiteralElement>, location?: TextRange, flags?: NodeFlags): ObjectLiteralExpression {
        let node = createNode<ObjectLiteralExpression>(SyntaxKind.ObjectLiteralExpression, location, flags); 
        if (properties) node.properties = createNodeArray(properties);
        return node;
    }
    export function createPropertyAccessExpression(expression?: LeftHandSideExpression, dotToken?: Node, name?: Identifier, location?: TextRange, flags?: NodeFlags): PropertyAccessExpression {
        let node = createNode<PropertyAccessExpression>(SyntaxKind.PropertyAccessExpression, location, flags); 
        if (expression) node.expression = expression;
        if (dotToken) node.dotToken = dotToken;
        if (name) node.name = name;
        return node;
    }
    export function createElementAccessExpression(expression?: LeftHandSideExpression, argumentExpression?: Expression, location?: TextRange, flags?: NodeFlags): ElementAccessExpression {
        let node = createNode<ElementAccessExpression>(SyntaxKind.ElementAccessExpression, location, flags); 
        if (expression) node.expression = expression;
        if (argumentExpression) node.argumentExpression = argumentExpression;
        return node;
    }
    export function createCallExpression(expression?: LeftHandSideExpression, typeArguments?: Array<TypeNode>, _arguments?: Array<Expression>, location?: TextRange, flags?: NodeFlags): CallExpression {
        let node = createNode<CallExpression>(SyntaxKind.CallExpression, location, flags); 
        if (expression) node.expression = expression;
        if (typeArguments) node.typeArguments = createNodeArray(typeArguments);
        if (_arguments) node.arguments = createNodeArray(_arguments);
        return node;
    }
    export function createNewExpression(expression?: LeftHandSideExpression, typeArguments?: Array<TypeNode>, _arguments?: Array<Expression>, location?: TextRange, flags?: NodeFlags): NewExpression {
        let node = createNode<NewExpression>(SyntaxKind.NewExpression, location, flags); 
        if (expression) node.expression = expression;
        if (typeArguments) node.typeArguments = createNodeArray(typeArguments);
        if (_arguments) node.arguments = createNodeArray(_arguments);
        return node;
    }
    export function createTaggedTemplateExpression(tag?: LeftHandSideExpression, template?: LiteralExpression | TemplateExpression, location?: TextRange, flags?: NodeFlags): TaggedTemplateExpression {
        let node = createNode<TaggedTemplateExpression>(SyntaxKind.TaggedTemplateExpression, location, flags); 
        if (tag) node.tag = tag;
        if (template) node.template = template;
        return node;
    }
    export function createTypeAssertionExpression(type?: TypeNode, expression?: UnaryExpression, location?: TextRange, flags?: NodeFlags): TypeAssertion {
        let node = createNode<TypeAssertion>(SyntaxKind.TypeAssertionExpression, location, flags); 
        if (type) node.type = type;
        if (expression) node.expression = expression;
        return node;
    }
    export function createParenthesizedExpression(expression?: Expression, location?: TextRange, flags?: NodeFlags): ParenthesizedExpression {
        let node = createNode<ParenthesizedExpression>(SyntaxKind.ParenthesizedExpression, location, flags); 
        if (expression) node.expression = expression;
        return node;
    }
    export function createFunctionExpression(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, asteriskToken?: Node, name?: Identifier, typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, type?: TypeNode, body?: FunctionBody, location?: TextRange, flags?: NodeFlags): FunctionExpression {
        let node = createNode<FunctionExpression>(SyntaxKind.FunctionExpression, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (asteriskToken) node.asteriskToken = asteriskToken;
        if (name) node.name = name;
        if (typeParameters) node.typeParameters = createNodeArray(typeParameters);
        if (parameters) node.parameters = createNodeArray(parameters);
        if (type) node.type = type;
        if (body) node.body = body;
        return node;
    }
    export function createArrowFunction(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, type?: TypeNode, equalsGreaterThanToken?: Node, body?: ConciseBody, location?: TextRange, flags?: NodeFlags): ArrowFunction {
        let node = createNode<ArrowFunction>(SyntaxKind.ArrowFunction, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (typeParameters) node.typeParameters = createNodeArray(typeParameters);
        if (parameters) node.parameters = createNodeArray(parameters);
        if (type) node.type = type;
        if (equalsGreaterThanToken) node.equalsGreaterThanToken = equalsGreaterThanToken;
        if (body) node.body = body;
        return node;
    }
    export function createDeleteExpression(expression?: UnaryExpression, location?: TextRange, flags?: NodeFlags): DeleteExpression {
        let node = createNode<DeleteExpression>(SyntaxKind.DeleteExpression, location, flags); 
        if (expression) node.expression = expression;
        return node;
    }
    export function createTypeOfExpression(expression?: UnaryExpression, location?: TextRange, flags?: NodeFlags): TypeOfExpression {
        let node = createNode<TypeOfExpression>(SyntaxKind.TypeOfExpression, location, flags); 
        if (expression) node.expression = expression;
        return node;
    }
    export function createVoidExpression(expression?: UnaryExpression, location?: TextRange, flags?: NodeFlags): VoidExpression {
        let node = createNode<VoidExpression>(SyntaxKind.VoidExpression, location, flags); 
        if (expression) node.expression = expression;
        return node;
    }
    export function createAwaitExpression(expression?: UnaryExpression, location?: TextRange, flags?: NodeFlags): AwaitExpression {
        let node = createNode<AwaitExpression>(SyntaxKind.AwaitExpression, location, flags); 
        if (expression) node.expression = expression;
        return node;
    }
    export function createPrefixUnaryExpression(operator?: SyntaxKind, operand?: UnaryExpression, location?: TextRange, flags?: NodeFlags): PrefixUnaryExpression {
        let node = createNode<PrefixUnaryExpression>(SyntaxKind.PrefixUnaryExpression, location, flags); 
        if (operator) node.operator = operator;
        if (operand) node.operand = operand;
        return node;
    }
    export function createPostfixUnaryExpression(operand?: LeftHandSideExpression, operator?: SyntaxKind, location?: TextRange, flags?: NodeFlags): PostfixUnaryExpression {
        let node = createNode<PostfixUnaryExpression>(SyntaxKind.PostfixUnaryExpression, location, flags); 
        if (operand) node.operand = operand;
        if (operator) node.operator = operator;
        return node;
    }
    export function createBinaryExpression(left?: Expression, operatorToken?: Node, right?: Expression, location?: TextRange, flags?: NodeFlags): BinaryExpression {
        let node = createNode<BinaryExpression>(SyntaxKind.BinaryExpression, location, flags); 
        if (left) node.left = left;
        if (operatorToken) node.operatorToken = operatorToken;
        if (right) node.right = right;
        return node;
    }
    export function createConditionalExpression(condition?: Expression, questionToken?: Node, whenTrue?: Expression, colonToken?: Node, whenFalse?: Expression, location?: TextRange, flags?: NodeFlags): ConditionalExpression {
        let node = createNode<ConditionalExpression>(SyntaxKind.ConditionalExpression, location, flags); 
        if (condition) node.condition = condition;
        if (questionToken) node.questionToken = questionToken;
        if (whenTrue) node.whenTrue = whenTrue;
        if (colonToken) node.colonToken = colonToken;
        if (whenFalse) node.whenFalse = whenFalse;
        return node;
    }
    export function createTemplateExpression(head?: LiteralExpression, templateSpans?: Array<TemplateSpan>, location?: TextRange, flags?: NodeFlags): TemplateExpression {
        let node = createNode<TemplateExpression>(SyntaxKind.TemplateExpression, location, flags); 
        if (head) node.head = head;
        if (templateSpans) node.templateSpans = createNodeArray(templateSpans);
        return node;
    }
    export function createYieldExpression(asteriskToken?: Node, expression?: Expression, location?: TextRange, flags?: NodeFlags): YieldExpression {
        let node = createNode<YieldExpression>(SyntaxKind.YieldExpression, location, flags); 
        if (asteriskToken) node.asteriskToken = asteriskToken;
        if (expression) node.expression = expression;
        return node;
    }
    export function createSpreadElementExpression(expression?: Expression, location?: TextRange, flags?: NodeFlags): SpreadElementExpression {
        let node = createNode<SpreadElementExpression>(SyntaxKind.SpreadElementExpression, location, flags); 
        if (expression) node.expression = expression;
        return node;
    }
    export function createClassExpression(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, name?: Identifier, typeParameters?: Array<TypeParameterDeclaration>, heritageClauses?: Array<HeritageClause>, members?: Array<ClassElement>, location?: TextRange, flags?: NodeFlags): ClassExpression {
        let node = createNode<ClassExpression>(SyntaxKind.ClassExpression, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (name) node.name = name;
        if (typeParameters) node.typeParameters = createNodeArray(typeParameters);
        if (heritageClauses) node.heritageClauses = createNodeArray(heritageClauses);
        if (members) node.members = createNodeArray(members);
        return node;
    }
    export function createOmittedExpression(location?: TextRange, flags?: NodeFlags): OmittedExpression {
        let node = createNode<OmittedExpression>(SyntaxKind.OmittedExpression, location, flags); 
        return node;
    }
    export function createExpressionWithTypeArguments(expression?: LeftHandSideExpression, typeArguments?: Array<TypeNode>, location?: TextRange, flags?: NodeFlags): ExpressionWithTypeArguments {
        let node = createNode<ExpressionWithTypeArguments>(SyntaxKind.ExpressionWithTypeArguments, location, flags); 
        if (expression) node.expression = expression;
        if (typeArguments) node.typeArguments = createNodeArray(typeArguments);
        return node;
    }
    export function createAsExpression(expression?: Expression, type?: TypeNode, location?: TextRange, flags?: NodeFlags): AsExpression {
        let node = createNode<AsExpression>(SyntaxKind.AsExpression, location, flags); 
        if (expression) node.expression = expression;
        if (type) node.type = type;
        return node;
    }
    export function createTemplateSpan(expression?: Expression, literal?: LiteralExpression, location?: TextRange, flags?: NodeFlags): TemplateSpan {
        let node = createNode<TemplateSpan>(SyntaxKind.TemplateSpan, location, flags); 
        if (expression) node.expression = expression;
        if (literal) node.literal = literal;
        return node;
    }
    export function createSemicolonClassElement(location?: TextRange, flags?: NodeFlags): SemicolonClassElement {
        let node = createNode<SemicolonClassElement>(SyntaxKind.SemicolonClassElement, location, flags); 
        return node;
    }
    export function createBlock(statements?: Array<Statement>, location?: TextRange, flags?: NodeFlags): Block {
        let node = createNode<Block>(SyntaxKind.Block, location, flags); 
        if (statements) node.statements = createNodeArray(statements);
        return node;
    }
    export function createVariableStatement(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, declarationList?: VariableDeclarationList, location?: TextRange, flags?: NodeFlags): VariableStatement {
        let node = createNode<VariableStatement>(SyntaxKind.VariableStatement, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (declarationList) node.declarationList = declarationList;
        return node;
    }
    export function createEmptyStatement(location?: TextRange, flags?: NodeFlags): EmptyStatement {
        let node = createNode<EmptyStatement>(SyntaxKind.EmptyStatement, location, flags); 
        return node;
    }
    export function createExpressionStatement(expression?: Expression, location?: TextRange, flags?: NodeFlags): ExpressionStatement {
        let node = createNode<ExpressionStatement>(SyntaxKind.ExpressionStatement, location, flags); 
        if (expression) node.expression = expression;
        return node;
    }
    export function createIfStatement(expression?: Expression, thenStatement?: Statement, elseStatement?: Statement, location?: TextRange, flags?: NodeFlags): IfStatement {
        let node = createNode<IfStatement>(SyntaxKind.IfStatement, location, flags); 
        if (expression) node.expression = expression;
        if (thenStatement) node.thenStatement = thenStatement;
        if (elseStatement) node.elseStatement = elseStatement;
        return node;
    }
    export function createDoStatement(statement?: Statement, expression?: Expression, location?: TextRange, flags?: NodeFlags): DoStatement {
        let node = createNode<DoStatement>(SyntaxKind.DoStatement, location, flags); 
        if (statement) node.statement = statement;
        if (expression) node.expression = expression;
        return node;
    }
    export function createWhileStatement(expression?: Expression, statement?: Statement, location?: TextRange, flags?: NodeFlags): WhileStatement {
        let node = createNode<WhileStatement>(SyntaxKind.WhileStatement, location, flags); 
        if (expression) node.expression = expression;
        if (statement) node.statement = statement;
        return node;
    }
    export function createForStatement(initializer?: Expression | VariableDeclarationList, condition?: Expression, incrementor?: Expression, statement?: Statement, location?: TextRange, flags?: NodeFlags): ForStatement {
        let node = createNode<ForStatement>(SyntaxKind.ForStatement, location, flags); 
        if (initializer) node.initializer = initializer;
        if (condition) node.condition = condition;
        if (incrementor) node.incrementor = incrementor;
        if (statement) node.statement = statement;
        return node;
    }
    export function createForInStatement(initializer?: Expression | VariableDeclarationList, expression?: Expression, statement?: Statement, location?: TextRange, flags?: NodeFlags): ForInStatement {
        let node = createNode<ForInStatement>(SyntaxKind.ForInStatement, location, flags); 
        if (initializer) node.initializer = initializer;
        if (expression) node.expression = expression;
        if (statement) node.statement = statement;
        return node;
    }
    export function createForOfStatement(initializer?: Expression | VariableDeclarationList, expression?: Expression, statement?: Statement, location?: TextRange, flags?: NodeFlags): ForOfStatement {
        let node = createNode<ForOfStatement>(SyntaxKind.ForOfStatement, location, flags); 
        if (initializer) node.initializer = initializer;
        if (expression) node.expression = expression;
        if (statement) node.statement = statement;
        return node;
    }
    export function createContinueStatement(label?: Identifier, location?: TextRange, flags?: NodeFlags): ContinueStatement {
        let node = createNode<ContinueStatement>(SyntaxKind.ContinueStatement, location, flags); 
        if (label) node.label = label;
        return node;
    }
    export function createBreakStatement(label?: Identifier, location?: TextRange, flags?: NodeFlags): BreakStatement {
        let node = createNode<BreakStatement>(SyntaxKind.BreakStatement, location, flags); 
        if (label) node.label = label;
        return node;
    }
    export function createReturnStatement(expression?: Expression, location?: TextRange, flags?: NodeFlags): ReturnStatement {
        let node = createNode<ReturnStatement>(SyntaxKind.ReturnStatement, location, flags); 
        if (expression) node.expression = expression;
        return node;
    }
    export function createWithStatement(expression?: Expression, statement?: Statement, location?: TextRange, flags?: NodeFlags): WithStatement {
        let node = createNode<WithStatement>(SyntaxKind.WithStatement, location, flags); 
        if (expression) node.expression = expression;
        if (statement) node.statement = statement;
        return node;
    }
    export function createSwitchStatement(expression?: Expression, caseBlock?: CaseBlock, location?: TextRange, flags?: NodeFlags): SwitchStatement {
        let node = createNode<SwitchStatement>(SyntaxKind.SwitchStatement, location, flags); 
        if (expression) node.expression = expression;
        if (caseBlock) node.caseBlock = caseBlock;
        return node;
    }
    export function createLabeledStatement(label?: Identifier, statement?: Statement, location?: TextRange, flags?: NodeFlags): LabeledStatement {
        let node = createNode<LabeledStatement>(SyntaxKind.LabeledStatement, location, flags); 
        if (label) node.label = label;
        if (statement) node.statement = statement;
        return node;
    }
    export function createThrowStatement(expression?: Expression, location?: TextRange, flags?: NodeFlags): ThrowStatement {
        let node = createNode<ThrowStatement>(SyntaxKind.ThrowStatement, location, flags); 
        if (expression) node.expression = expression;
        return node;
    }
    export function createTryStatement(tryBlock?: Block, catchClause?: CatchClause, finallyBlock?: Block, location?: TextRange, flags?: NodeFlags): TryStatement {
        let node = createNode<TryStatement>(SyntaxKind.TryStatement, location, flags); 
        if (tryBlock) node.tryBlock = tryBlock;
        if (catchClause) node.catchClause = catchClause;
        if (finallyBlock) node.finallyBlock = finallyBlock;
        return node;
    }
    export function createDebuggerStatement(location?: TextRange, flags?: NodeFlags): DebuggerStatement {
        let node = createNode<DebuggerStatement>(SyntaxKind.DebuggerStatement, location, flags); 
        return node;
    }
    export function createVariableDeclaration(name?: BindingPattern | Identifier, type?: TypeNode, initializer?: Expression, location?: TextRange, flags?: NodeFlags): VariableDeclaration {
        let node = createNode<VariableDeclaration>(SyntaxKind.VariableDeclaration, location, flags); 
        if (name) node.name = name;
        if (type) node.type = type;
        if (initializer) node.initializer = initializer;
        return node;
    }
    export function createVariableDeclarationList(declarations?: Array<VariableDeclaration>, location?: TextRange, flags?: NodeFlags): VariableDeclarationList {
        let node = createNode<VariableDeclarationList>(SyntaxKind.VariableDeclarationList, location, flags); 
        if (declarations) node.declarations = createNodeArray(declarations);
        return node;
    }
    export function createFunctionDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, asteriskToken?: Node, name?: Identifier, typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, type?: TypeNode, body?: FunctionBody, location?: TextRange, flags?: NodeFlags): FunctionDeclaration {
        let node = createNode<FunctionDeclaration>(SyntaxKind.FunctionDeclaration, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (asteriskToken) node.asteriskToken = asteriskToken;
        if (name) node.name = name;
        if (typeParameters) node.typeParameters = createNodeArray(typeParameters);
        if (parameters) node.parameters = createNodeArray(parameters);
        if (type) node.type = type;
        if (body) node.body = body;
        return node;
    }
    export function createClassDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, name?: Identifier, typeParameters?: Array<TypeParameterDeclaration>, heritageClauses?: Array<HeritageClause>, members?: Array<ClassElement>, location?: TextRange, flags?: NodeFlags): ClassDeclaration {
        let node = createNode<ClassDeclaration>(SyntaxKind.ClassDeclaration, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (name) node.name = name;
        if (typeParameters) node.typeParameters = createNodeArray(typeParameters);
        if (heritageClauses) node.heritageClauses = createNodeArray(heritageClauses);
        if (members) node.members = createNodeArray(members);
        return node;
    }
    export function createInterfaceDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, name?: Identifier, typeParameters?: Array<TypeParameterDeclaration>, heritageClauses?: Array<HeritageClause>, members?: Array<TypeElement>, location?: TextRange, flags?: NodeFlags): InterfaceDeclaration {
        let node = createNode<InterfaceDeclaration>(SyntaxKind.InterfaceDeclaration, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (name) node.name = name;
        if (typeParameters) node.typeParameters = createNodeArray(typeParameters);
        if (heritageClauses) node.heritageClauses = createNodeArray(heritageClauses);
        if (members) node.members = createNodeArray(members);
        return node;
    }
    export function createTypeAliasDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, name?: Identifier, typeParameters?: Array<TypeParameterDeclaration>, type?: TypeNode, location?: TextRange, flags?: NodeFlags): TypeAliasDeclaration {
        let node = createNode<TypeAliasDeclaration>(SyntaxKind.TypeAliasDeclaration, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (name) node.name = name;
        if (typeParameters) node.typeParameters = createNodeArray(typeParameters);
        if (type) node.type = type;
        return node;
    }
    export function createEnumDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, name?: Identifier, members?: Array<EnumMember>, location?: TextRange, flags?: NodeFlags): EnumDeclaration {
        let node = createNode<EnumDeclaration>(SyntaxKind.EnumDeclaration, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (name) node.name = name;
        if (members) node.members = createNodeArray(members);
        return node;
    }
    export function createModuleDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, name?: Identifier | LiteralExpression, body?: ModuleBody, location?: TextRange, flags?: NodeFlags): ModuleDeclaration {
        let node = createNode<ModuleDeclaration>(SyntaxKind.ModuleDeclaration, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (name) node.name = name;
        if (body) node.body = body;
        return node;
    }
    export function createModuleBlock(statements?: Array<Statement>, location?: TextRange, flags?: NodeFlags): ModuleBlock {
        let node = createNode<ModuleBlock>(SyntaxKind.ModuleBlock, location, flags); 
        if (statements) node.statements = createNodeArray(statements);
        return node;
    }
    export function createCaseBlock(clauses?: Array<CaseOrDefaultClause>, location?: TextRange, flags?: NodeFlags): CaseBlock {
        let node = createNode<CaseBlock>(SyntaxKind.CaseBlock, location, flags); 
        if (clauses) node.clauses = createNodeArray(clauses);
        return node;
    }
    export function createImportEqualsDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, name?: Identifier, moduleReference?: EntityName | ExternalModuleReference, location?: TextRange, flags?: NodeFlags): ImportEqualsDeclaration {
        let node = createNode<ImportEqualsDeclaration>(SyntaxKind.ImportEqualsDeclaration, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (name) node.name = name;
        if (moduleReference) node.moduleReference = moduleReference;
        return node;
    }
    export function createImportDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, importClause?: ImportClause, moduleSpecifier?: Expression, location?: TextRange, flags?: NodeFlags): ImportDeclaration {
        let node = createNode<ImportDeclaration>(SyntaxKind.ImportDeclaration, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (importClause) node.importClause = importClause;
        if (moduleSpecifier) node.moduleSpecifier = moduleSpecifier;
        return node;
    }
    export function createImportClause(name?: Identifier, namedBindings?: NamedImports | NamespaceImport, location?: TextRange, flags?: NodeFlags): ImportClause {
        let node = createNode<ImportClause>(SyntaxKind.ImportClause, location, flags); 
        if (name) node.name = name;
        if (namedBindings) node.namedBindings = namedBindings;
        return node;
    }
    export function createNamespaceImport(name?: Identifier, location?: TextRange, flags?: NodeFlags): NamespaceImport {
        let node = createNode<NamespaceImport>(SyntaxKind.NamespaceImport, location, flags); 
        if (name) node.name = name;
        return node;
    }
    export function createNamedImports(elements?: Array<ImportSpecifier>, location?: TextRange, flags?: NodeFlags): NamedImports {
        let node = createNode<NamedImports>(SyntaxKind.NamedImports, location, flags); 
        if (elements) node.elements = createNodeArray(elements);
        return node;
    }
    export function createImportSpecifier(propertyName?: Identifier, name?: Identifier, location?: TextRange, flags?: NodeFlags): ImportSpecifier {
        let node = createNode<ImportSpecifier>(SyntaxKind.ImportSpecifier, location, flags); 
        if (propertyName) node.propertyName = propertyName;
        if (name) node.name = name;
        return node;
    }
    export function createExportAssignment(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, expression?: Expression, location?: TextRange, flags?: NodeFlags): ExportAssignment {
        let node = createNode<ExportAssignment>(SyntaxKind.ExportAssignment, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (expression) node.expression = expression;
        return node;
    }
    export function createExportDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, exportClause?: NamedExports, moduleSpecifier?: Expression, location?: TextRange, flags?: NodeFlags): ExportDeclaration {
        let node = createNode<ExportDeclaration>(SyntaxKind.ExportDeclaration, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (exportClause) node.exportClause = exportClause;
        if (moduleSpecifier) node.moduleSpecifier = moduleSpecifier;
        return node;
    }
    export function createNamedExports(elements?: Array<ExportSpecifier>, location?: TextRange, flags?: NodeFlags): NamedExports {
        let node = createNode<NamedExports>(SyntaxKind.NamedExports, location, flags); 
        if (elements) node.elements = createNodeArray(elements);
        return node;
    }
    export function createExportSpecifier(propertyName?: Identifier, name?: Identifier, location?: TextRange, flags?: NodeFlags): ExportSpecifier {
        let node = createNode<ExportSpecifier>(SyntaxKind.ExportSpecifier, location, flags); 
        if (propertyName) node.propertyName = propertyName;
        if (name) node.name = name;
        return node;
    }
    export function createMissingDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Modifier>, questionToken?: Node, location?: TextRange, flags?: NodeFlags): MissingDeclaration {
        let node = createNode<MissingDeclaration>(SyntaxKind.MissingDeclaration, location, flags); 
        if (decorators) node.decorators = createNodeArray(decorators);
        if (modifiers) setModifiers(node, modifiers);
        if (questionToken) node.questionToken = questionToken;
        return node;
    }
    export function createExternalModuleReference(expression?: Expression, location?: TextRange, flags?: NodeFlags): ExternalModuleReference {
        let node = createNode<ExternalModuleReference>(SyntaxKind.ExternalModuleReference, location, flags); 
        if (expression) node.expression = expression;
        return node;
    }
    export function createJsxElement(openingElement?: JsxOpeningElement, children?: Array<JsxChild>, closingElement?: JsxClosingElement, location?: TextRange, flags?: NodeFlags): JsxElement {
        let node = createNode<JsxElement>(SyntaxKind.JsxElement, location, flags); 
        if (openingElement) node.openingElement = openingElement;
        if (children) node.children = createNodeArray(children);
        if (closingElement) node.closingElement = closingElement;
        return node;
    }
    export function createJsxSelfClosingElement(tagName?: EntityName, attributes?: Array<JsxAttribute | JsxSpreadAttribute>, location?: TextRange, flags?: NodeFlags): JsxSelfClosingElement {
        let node = createNode<JsxSelfClosingElement>(SyntaxKind.JsxSelfClosingElement, location, flags); 
        if (tagName) node.tagName = tagName;
        if (attributes) node.attributes = createNodeArray(attributes);
        return node;
    }
    export function createJsxOpeningElement(tagName?: EntityName, attributes?: Array<JsxAttribute | JsxSpreadAttribute>, location?: TextRange, flags?: NodeFlags): JsxOpeningElement {
        let node = createNode<JsxOpeningElement>(SyntaxKind.JsxOpeningElement, location, flags); 
        if (tagName) node.tagName = tagName;
        if (attributes) node.attributes = createNodeArray(attributes);
        return node;
    }
    export function createJsxText(location?: TextRange, flags?: NodeFlags): JsxText {
        let node = createNode<JsxText>(SyntaxKind.JsxText, location, flags); 
        return node;
    }
    export function createJsxClosingElement(tagName?: EntityName, location?: TextRange, flags?: NodeFlags): JsxClosingElement {
        let node = createNode<JsxClosingElement>(SyntaxKind.JsxClosingElement, location, flags); 
        if (tagName) node.tagName = tagName;
        return node;
    }
    export function createJsxAttribute(name?: Identifier, initializer?: Expression, location?: TextRange, flags?: NodeFlags): JsxAttribute {
        let node = createNode<JsxAttribute>(SyntaxKind.JsxAttribute, location, flags); 
        if (name) node.name = name;
        if (initializer) node.initializer = initializer;
        return node;
    }
    export function createJsxSpreadAttribute(expression?: Expression, location?: TextRange, flags?: NodeFlags): JsxSpreadAttribute {
        let node = createNode<JsxSpreadAttribute>(SyntaxKind.JsxSpreadAttribute, location, flags); 
        if (expression) node.expression = expression;
        return node;
    }
    export function createJsxExpression(expression?: Expression, location?: TextRange, flags?: NodeFlags): JsxExpression {
        let node = createNode<JsxExpression>(SyntaxKind.JsxExpression, location, flags); 
        if (expression) node.expression = expression;
        return node;
    }
    export function createCaseClause(expression?: Expression, statements?: Array<Statement>, location?: TextRange, flags?: NodeFlags): CaseClause {
        let node = createNode<CaseClause>(SyntaxKind.CaseClause, location, flags); 
        if (expression) node.expression = expression;
        if (statements) node.statements = createNodeArray(statements);
        return node;
    }
    export function createDefaultClause(statements?: Array<Statement>, location?: TextRange, flags?: NodeFlags): DefaultClause {
        let node = createNode<DefaultClause>(SyntaxKind.DefaultClause, location, flags); 
        if (statements) node.statements = createNodeArray(statements);
        return node;
    }
    export function createHeritageClause(token?: SyntaxKind, types?: Array<ExpressionWithTypeArguments>, location?: TextRange, flags?: NodeFlags): HeritageClause {
        let node = createNode<HeritageClause>(SyntaxKind.HeritageClause, location, flags); 
        if (token) node.token = token;
        if (types) node.types = createNodeArray(types);
        return node;
    }
    export function createCatchClause(variableDeclaration?: VariableDeclaration, block?: Block, location?: TextRange, flags?: NodeFlags): CatchClause {
        let node = createNode<CatchClause>(SyntaxKind.CatchClause, location, flags); 
        if (variableDeclaration) node.variableDeclaration = variableDeclaration;
        if (block) node.block = block;
        return node;
    }
    export function createPropertyAssignment(name?: PropertyName, initializer?: Expression, location?: TextRange, flags?: NodeFlags): PropertyAssignment {
        let node = createNode<PropertyAssignment>(SyntaxKind.PropertyAssignment, location, flags); 
        if (name) node.name = name;
        if (initializer) node.initializer = initializer;
        return node;
    }
    export function createShorthandPropertyAssignment(name?: Identifier, equalsToken?: Node, objectAssignmentInitializer?: Expression, location?: TextRange, flags?: NodeFlags): ShorthandPropertyAssignment {
        let node = createNode<ShorthandPropertyAssignment>(SyntaxKind.ShorthandPropertyAssignment, location, flags); 
        if (name) node.name = name;
        if (equalsToken) node.equalsToken = equalsToken;
        if (objectAssignmentInitializer) node.objectAssignmentInitializer = objectAssignmentInitializer;
        return node;
    }
    export function createEnumMember(name?: DeclarationName, initializer?: Expression, location?: TextRange, flags?: NodeFlags): EnumMember {
        let node = createNode<EnumMember>(SyntaxKind.EnumMember, location, flags); 
        if (name) node.name = name;
        if (initializer) node.initializer = initializer;
        return node;
    }
    export function createSourceFileNode(statements?: Array<Statement>, endOfFileToken?: Node, fileName?: string, text?: string, amdDependencies?: Array<AmdDependency>, moduleName?: string, referencedFiles?: Array<FileReference>, languageVariant?: LanguageVariant, renamedDependencies?: Map<string>, hasNoDefaultLib?: boolean, languageVersion?: ScriptTarget, externalModuleIndicator?: Node, isDefaultLib?: boolean, identifiers?: Map<string>, parseDiagnostics?: Array<Diagnostic>, bindDiagnostics?: Array<Diagnostic>, lineMap?: Array<number>, classifiableNames?: Map<string>, resolvedModules?: Map<ResolvedModule>, imports?: Array<LiteralExpression>, location?: TextRange, flags?: NodeFlags): SourceFile {
        let node = createNode<SourceFile>(SyntaxKind.SourceFile, location, flags); 
        if (statements) node.statements = createNodeArray(statements);
        if (endOfFileToken) node.endOfFileToken = endOfFileToken;
        if (fileName) node.fileName = fileName;
        if (text) node.text = text;
        if (amdDependencies) node.amdDependencies = amdDependencies;
        if (moduleName) node.moduleName = moduleName;
        if (referencedFiles) node.referencedFiles = referencedFiles;
        if (languageVariant) node.languageVariant = languageVariant;
        if (renamedDependencies) node.renamedDependencies = renamedDependencies;
        if (hasNoDefaultLib) node.hasNoDefaultLib = hasNoDefaultLib;
        if (languageVersion) node.languageVersion = languageVersion;
        if (externalModuleIndicator) node.externalModuleIndicator = externalModuleIndicator;
        if (isDefaultLib) node.isDefaultLib = isDefaultLib;
        if (identifiers) node.identifiers = identifiers;
        if (parseDiagnostics) node.parseDiagnostics = parseDiagnostics;
        if (bindDiagnostics) node.bindDiagnostics = bindDiagnostics;
        if (lineMap) node.lineMap = lineMap;
        if (classifiableNames) node.classifiableNames = classifiableNames;
        if (resolvedModules) node.resolvedModules = resolvedModules;
        if (imports) node.imports = imports;
        return node;
    }
    export function createJSDocTypeExpression(type?: JSDocType, location?: TextRange, flags?: NodeFlags): JSDocTypeExpression {
        let node = createNode<JSDocTypeExpression>(SyntaxKind.JSDocTypeExpression, location, flags); 
        if (type) node.type = type;
        return node;
    }
    export function createJSDocAllType(location?: TextRange, flags?: NodeFlags): JSDocAllType {
        let node = createNode<JSDocAllType>(SyntaxKind.JSDocAllType, location, flags); 
        return node;
    }
    export function createJSDocUnknownType(location?: TextRange, flags?: NodeFlags): JSDocUnknownType {
        let node = createNode<JSDocUnknownType>(SyntaxKind.JSDocUnknownType, location, flags); 
        return node;
    }
    export function createJSDocArrayType(elementType?: JSDocType, location?: TextRange, flags?: NodeFlags): JSDocArrayType {
        let node = createNode<JSDocArrayType>(SyntaxKind.JSDocArrayType, location, flags); 
        if (elementType) node.elementType = elementType;
        return node;
    }
    export function createJSDocUnionType(types?: Array<JSDocType>, location?: TextRange, flags?: NodeFlags): JSDocUnionType {
        let node = createNode<JSDocUnionType>(SyntaxKind.JSDocUnionType, location, flags); 
        if (types) node.types = createNodeArray(types);
        return node;
    }
    export function createJSDocTupleType(types?: Array<JSDocType>, location?: TextRange, flags?: NodeFlags): JSDocTupleType {
        let node = createNode<JSDocTupleType>(SyntaxKind.JSDocTupleType, location, flags); 
        if (types) node.types = createNodeArray(types);
        return node;
    }
    export function createJSDocNullableType(type?: JSDocType, location?: TextRange, flags?: NodeFlags): JSDocNullableType {
        let node = createNode<JSDocNullableType>(SyntaxKind.JSDocNullableType, location, flags); 
        if (type) node.type = type;
        return node;
    }
    export function createJSDocNonNullableType(type?: JSDocType, location?: TextRange, flags?: NodeFlags): JSDocNonNullableType {
        let node = createNode<JSDocNonNullableType>(SyntaxKind.JSDocNonNullableType, location, flags); 
        if (type) node.type = type;
        return node;
    }
    export function createJSDocRecordType(members?: Array<JSDocRecordMember>, location?: TextRange, flags?: NodeFlags): JSDocRecordType {
        let node = createNode<JSDocRecordType>(SyntaxKind.JSDocRecordType, location, flags); 
        if (members) node.members = createNodeArray(members);
        return node;
    }
    export function createJSDocRecordMember(name?: Identifier | LiteralExpression, type?: JSDocType, location?: TextRange, flags?: NodeFlags): JSDocRecordMember {
        let node = createNode<JSDocRecordMember>(SyntaxKind.JSDocRecordMember, location, flags); 
        if (name) node.name = name;
        if (type) node.type = type;
        return node;
    }
    export function createJSDocTypeReference(name?: EntityName, typeArguments?: Array<JSDocType>, location?: TextRange, flags?: NodeFlags): JSDocTypeReference {
        let node = createNode<JSDocTypeReference>(SyntaxKind.JSDocTypeReference, location, flags); 
        if (name) node.name = name;
        if (typeArguments) node.typeArguments = createNodeArray(typeArguments);
        return node;
    }
    export function createJSDocOptionalType(type?: JSDocType, location?: TextRange, flags?: NodeFlags): JSDocOptionalType {
        let node = createNode<JSDocOptionalType>(SyntaxKind.JSDocOptionalType, location, flags); 
        if (type) node.type = type;
        return node;
    }
    export function createJSDocFunctionType(parameters?: Array<ParameterDeclaration>, type?: JSDocType, location?: TextRange, flags?: NodeFlags): JSDocFunctionType {
        let node = createNode<JSDocFunctionType>(SyntaxKind.JSDocFunctionType, location, flags); 
        if (parameters) node.parameters = createNodeArray(parameters);
        if (type) node.type = type;
        return node;
    }
    export function createJSDocVariadicType(type?: JSDocType, location?: TextRange, flags?: NodeFlags): JSDocVariadicType {
        let node = createNode<JSDocVariadicType>(SyntaxKind.JSDocVariadicType, location, flags); 
        if (type) node.type = type;
        return node;
    }
    export function createJSDocConstructorType(type?: JSDocType, location?: TextRange, flags?: NodeFlags): JSDocConstructorType {
        let node = createNode<JSDocConstructorType>(SyntaxKind.JSDocConstructorType, location, flags); 
        if (type) node.type = type;
        return node;
    }
    export function createJSDocThisType(type?: JSDocType, location?: TextRange, flags?: NodeFlags): JSDocThisType {
        let node = createNode<JSDocThisType>(SyntaxKind.JSDocThisType, location, flags); 
        if (type) node.type = type;
        return node;
    }
    export function createJSDocComment(tags?: Array<JSDocTag>, location?: TextRange, flags?: NodeFlags): JSDocComment {
        let node = createNode<JSDocComment>(SyntaxKind.JSDocComment, location, flags); 
        if (tags) node.tags = createNodeArray(tags);
        return node;
    }
    export function createJSDocTag(atToken?: Node, tagName?: Identifier, location?: TextRange, flags?: NodeFlags): JSDocTag {
        let node = createNode<JSDocTag>(SyntaxKind.JSDocTag, location, flags); 
        if (atToken) node.atToken = atToken;
        if (tagName) node.tagName = tagName;
        return node;
    }
    export function createJSDocParameterTag(preParameterName?: Identifier, typeExpression?: JSDocTypeExpression, postParameterName?: Identifier, atToken?: Node, tagName?: Identifier, location?: TextRange, flags?: NodeFlags): JSDocParameterTag {
        let node = createNode<JSDocParameterTag>(SyntaxKind.JSDocParameterTag, location, flags); 
        if (preParameterName) node.preParameterName = preParameterName;
        if (typeExpression) node.typeExpression = typeExpression;
        if (postParameterName) node.postParameterName = postParameterName;
        if (atToken) node.atToken = atToken;
        if (tagName) node.tagName = tagName;
        return node;
    }
    export function createJSDocReturnTag(typeExpression?: JSDocTypeExpression, atToken?: Node, tagName?: Identifier, location?: TextRange, flags?: NodeFlags): JSDocReturnTag {
        let node = createNode<JSDocReturnTag>(SyntaxKind.JSDocReturnTag, location, flags); 
        if (typeExpression) node.typeExpression = typeExpression;
        if (atToken) node.atToken = atToken;
        if (tagName) node.tagName = tagName;
        return node;
    }
    export function createJSDocTypeTag(typeExpression?: JSDocTypeExpression, atToken?: Node, tagName?: Identifier, location?: TextRange, flags?: NodeFlags): JSDocTypeTag {
        let node = createNode<JSDocTypeTag>(SyntaxKind.JSDocTypeTag, location, flags); 
        if (typeExpression) node.typeExpression = typeExpression;
        if (atToken) node.atToken = atToken;
        if (tagName) node.tagName = tagName;
        return node;
    }
    export function createJSDocTemplateTag(typeParameters?: Array<TypeParameterDeclaration>, atToken?: Node, tagName?: Identifier, location?: TextRange, flags?: NodeFlags): JSDocTemplateTag {
        let node = createNode<JSDocTemplateTag>(SyntaxKind.JSDocTemplateTag, location, flags); 
        if (typeParameters) node.typeParameters = createNodeArray(typeParameters);
        if (atToken) node.atToken = atToken;
        if (tagName) node.tagName = tagName;
        return node;
    }
    export function createRawExpression(text?: string, location?: TextRange, flags?: NodeFlags): RawExpression {
        let node = createNode<RawExpression>(SyntaxKind.RawExpression, location, flags); 
        if (text) node.text = text;
        return node;
    }
    export function createRawStatement(text?: string, location?: TextRange, flags?: NodeFlags): RawStatement {
        let node = createNode<RawStatement>(SyntaxKind.RawStatement, location, flags); 
        if (text) node.text = text;
        return node;
    }
    export function updateQualifiedName(node: QualifiedName, left: EntityName, right: Identifier): QualifiedName {
        if (left !== node.left || right !== node.right) {
            let newNode = createQualifiedName(left, right);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateComputedPropertyName(node: ComputedPropertyName, expression: Expression): ComputedPropertyName {
        if (expression !== node.expression) {
            let newNode = createComputedPropertyName(expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateTypeParameter(node: TypeParameterDeclaration, name: Identifier, constraint: TypeNode, expression: Expression): TypeParameterDeclaration {
        if (name !== node.name || constraint !== node.constraint || expression !== node.expression) {
            let newNode = createTypeParameter(name, constraint, expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateParameter(node: ParameterDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: BindingPattern | Identifier, questionToken: Node, type: TypeNode, initializer: Expression): ParameterDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || questionToken !== node.questionToken || type !== node.type || initializer !== node.initializer) {
            let newNode = createParameter(decorators, modifiers, node.dotDotDotToken, name, questionToken, type, initializer);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateDecorator(node: Decorator, expression: LeftHandSideExpression): Decorator {
        if (expression !== node.expression) {
            let newNode = createDecorator(expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updatePropertySignature(node: PropertySignature, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: PropertyName, type: TypeNode): PropertySignature {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || type !== node.type) {
            let newNode = createPropertySignature(decorators, modifiers, name, node.questionToken, type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updatePropertyDeclaration(node: PropertyDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: PropertyName, type: TypeNode, initializer: Expression): PropertyDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || type !== node.type || initializer !== node.initializer) {
            let newNode = createPropertyDeclaration(decorators, modifiers, name, type, initializer);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateMethodSignature(node: MethodSignature, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: PropertyName, typeParameters: Array<TypeParameterDeclaration>, parameters: Array<ParameterDeclaration>, type: TypeNode): MethodSignature {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || parameters !== node.parameters || type !== node.type) {
            let newNode = createMethodSignature(decorators, modifiers, name, node.questionToken, typeParameters, parameters, type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateMethodDeclaration(node: MethodDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: PropertyName, typeParameters: Array<TypeParameterDeclaration>, parameters: Array<ParameterDeclaration>, type: TypeNode, body: FunctionBody): MethodDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || parameters !== node.parameters || type !== node.type || body !== node.body) {
            let newNode = createMethodDeclaration(decorators, modifiers, node.asteriskToken, name, typeParameters, parameters, type, body);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateConstructor(node: ConstructorDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, parameters: Array<ParameterDeclaration>, type: TypeNode, body: FunctionBody): ConstructorDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || parameters !== node.parameters || type !== node.type || body !== node.body) {
            let newNode = createConstructor(decorators, modifiers, parameters, type, body);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateGetAccessor(node: GetAccessorDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: PropertyName, parameters: Array<ParameterDeclaration>, type: TypeNode, body: FunctionBody): GetAccessorDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || parameters !== node.parameters || type !== node.type || body !== node.body) {
            let newNode = createGetAccessor(decorators, modifiers, name, parameters, type, body);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateSetAccessor(node: SetAccessorDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: PropertyName, parameters: Array<ParameterDeclaration>, type: TypeNode, body: FunctionBody): SetAccessorDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || parameters !== node.parameters || type !== node.type || body !== node.body) {
            let newNode = createSetAccessor(decorators, modifiers, name, parameters, type, body);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateCallSignature(node: CallSignatureDeclaration, typeParameters: Array<TypeParameterDeclaration>, parameters: Array<ParameterDeclaration>, type: TypeNode): CallSignatureDeclaration {
        if (typeParameters !== node.typeParameters || parameters !== node.parameters || type !== node.type) {
            let newNode = createCallSignature(typeParameters, parameters, type, node.questionToken);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateConstructSignature(node: ConstructSignatureDeclaration, typeParameters: Array<TypeParameterDeclaration>, parameters: Array<ParameterDeclaration>, type: TypeNode): ConstructSignatureDeclaration {
        if (typeParameters !== node.typeParameters || parameters !== node.parameters || type !== node.type) {
            let newNode = createConstructSignature(typeParameters, parameters, type, node.questionToken);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateIndexSignature(node: IndexSignatureDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, parameters: Array<ParameterDeclaration>, type: TypeNode): IndexSignatureDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || parameters !== node.parameters || type !== node.type) {
            let newNode = createIndexSignature(decorators, modifiers, parameters, type, node.questionToken);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateTypePredicate(node: TypePredicateNode, parameterName: Identifier, type: TypeNode): TypePredicateNode {
        if (parameterName !== node.parameterName || type !== node.type) {
            let newNode = createTypePredicate(parameterName, type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateTypeReference(node: TypeReferenceNode, typeName: EntityName, typeArguments: Array<TypeNode>): TypeReferenceNode {
        if (typeName !== node.typeName || typeArguments !== node.typeArguments) {
            let newNode = createTypeReference(typeName, typeArguments);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateFunctionType(node: FunctionTypeNode, typeParameters: Array<TypeParameterDeclaration>, parameters: Array<ParameterDeclaration>, type: TypeNode): FunctionTypeNode {
        if (typeParameters !== node.typeParameters || parameters !== node.parameters || type !== node.type) {
            let newNode = createFunctionType(typeParameters, parameters, type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateConstructorType(node: ConstructorTypeNode, typeParameters: Array<TypeParameterDeclaration>, parameters: Array<ParameterDeclaration>, type: TypeNode): ConstructorTypeNode {
        if (typeParameters !== node.typeParameters || parameters !== node.parameters || type !== node.type) {
            let newNode = createConstructorType(typeParameters, parameters, type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateTypeQuery(node: TypeQueryNode, exprName: EntityName): TypeQueryNode {
        if (exprName !== node.exprName) {
            let newNode = createTypeQuery(exprName);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateTypeLiteral(node: TypeLiteralNode, members: Array<TypeElement>): TypeLiteralNode {
        if (members !== node.members) {
            let newNode = createTypeLiteral(members);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateArrayType(node: ArrayTypeNode, elementType: TypeNode): ArrayTypeNode {
        if (elementType !== node.elementType) {
            let newNode = createArrayType(elementType);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateTupleType(node: TupleTypeNode, elementTypes: Array<TypeNode>): TupleTypeNode {
        if (elementTypes !== node.elementTypes) {
            let newNode = createTupleType(elementTypes);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateUnionType(node: UnionTypeNode, types: Array<TypeNode>): UnionTypeNode {
        if (types !== node.types) {
            let newNode = createUnionType(types);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateIntersectionType(node: IntersectionTypeNode, types: Array<TypeNode>): IntersectionTypeNode {
        if (types !== node.types) {
            let newNode = createIntersectionType(types);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateParenthesizedType(node: ParenthesizedTypeNode, type: TypeNode): ParenthesizedTypeNode {
        if (type !== node.type) {
            let newNode = createParenthesizedType(type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateObjectBindingPattern(node: ObjectBindingPattern, elements: Array<BindingElement>): ObjectBindingPattern {
        if (elements !== node.elements) {
            let newNode = createObjectBindingPattern(elements);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateArrayBindingPattern(node: ArrayBindingPattern, elements: Array<BindingElement>): ArrayBindingPattern {
        if (elements !== node.elements) {
            let newNode = createArrayBindingPattern(elements);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateBindingElement(node: BindingElement, propertyName: Identifier, name: BindingPattern | Identifier, initializer: Expression): BindingElement {
        if (propertyName !== node.propertyName || name !== node.name || initializer !== node.initializer) {
            let newNode = createBindingElement(propertyName, node.dotDotDotToken, name, initializer);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateArrayLiteralExpression(node: ArrayLiteralExpression, elements: Array<Expression>): ArrayLiteralExpression {
        if (elements !== node.elements) {
            let newNode = createArrayLiteralExpression(elements);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateObjectLiteralExpression(node: ObjectLiteralExpression, properties: Array<ObjectLiteralElement>): ObjectLiteralExpression {
        if (properties !== node.properties) {
            let newNode = createObjectLiteralExpression(properties);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updatePropertyAccessExpression(node: PropertyAccessExpression, expression: LeftHandSideExpression, name: Identifier): PropertyAccessExpression {
        if (expression !== node.expression || name !== node.name) {
            let newNode = createPropertyAccessExpression(expression, node.dotToken, name);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateElementAccessExpression(node: ElementAccessExpression, expression: LeftHandSideExpression, argumentExpression: Expression): ElementAccessExpression {
        if (expression !== node.expression || argumentExpression !== node.argumentExpression) {
            let newNode = createElementAccessExpression(expression, argumentExpression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateCallExpression(node: CallExpression, expression: LeftHandSideExpression, typeArguments: Array<TypeNode>, _arguments: Array<Expression>): CallExpression {
        if (expression !== node.expression || typeArguments !== node.typeArguments || _arguments !== node.arguments) {
            let newNode = createCallExpression(expression, typeArguments, _arguments);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateNewExpression(node: NewExpression, expression: LeftHandSideExpression, typeArguments: Array<TypeNode>, _arguments: Array<Expression>): NewExpression {
        if (expression !== node.expression || typeArguments !== node.typeArguments || _arguments !== node.arguments) {
            let newNode = createNewExpression(expression, typeArguments, _arguments);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateTaggedTemplateExpression(node: TaggedTemplateExpression, tag: LeftHandSideExpression, template: LiteralExpression | TemplateExpression): TaggedTemplateExpression {
        if (tag !== node.tag || template !== node.template) {
            let newNode = createTaggedTemplateExpression(tag, template);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateTypeAssertionExpression(node: TypeAssertion, type: TypeNode, expression: UnaryExpression): TypeAssertion {
        if (type !== node.type || expression !== node.expression) {
            let newNode = createTypeAssertionExpression(type, expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateParenthesizedExpression(node: ParenthesizedExpression, expression: Expression): ParenthesizedExpression {
        if (expression !== node.expression) {
            let newNode = createParenthesizedExpression(expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateFunctionExpression(node: FunctionExpression, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: Identifier, typeParameters: Array<TypeParameterDeclaration>, parameters: Array<ParameterDeclaration>, type: TypeNode, body: FunctionBody): FunctionExpression {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || parameters !== node.parameters || type !== node.type || body !== node.body) {
            let newNode = createFunctionExpression(decorators, modifiers, node.asteriskToken, name, typeParameters, parameters, type, body);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateArrowFunction(node: ArrowFunction, decorators: Array<Decorator>, modifiers: Array<Modifier>, typeParameters: Array<TypeParameterDeclaration>, parameters: Array<ParameterDeclaration>, type: TypeNode, body: ConciseBody): ArrowFunction {
        if (decorators !== node.decorators || modifiers !== node.modifiers || typeParameters !== node.typeParameters || parameters !== node.parameters || type !== node.type || body !== node.body) {
            let newNode = createArrowFunction(decorators, modifiers, typeParameters, parameters, type, node.equalsGreaterThanToken, body);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateDeleteExpression(node: DeleteExpression, expression: UnaryExpression): DeleteExpression {
        if (expression !== node.expression) {
            let newNode = createDeleteExpression(expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateTypeOfExpression(node: TypeOfExpression, expression: UnaryExpression): TypeOfExpression {
        if (expression !== node.expression) {
            let newNode = createTypeOfExpression(expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateVoidExpression(node: VoidExpression, expression: UnaryExpression): VoidExpression {
        if (expression !== node.expression) {
            let newNode = createVoidExpression(expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateAwaitExpression(node: AwaitExpression, expression: UnaryExpression): AwaitExpression {
        if (expression !== node.expression) {
            let newNode = createAwaitExpression(expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updatePrefixUnaryExpression(node: PrefixUnaryExpression, operand: UnaryExpression): PrefixUnaryExpression {
        if (operand !== node.operand) {
            let newNode = createPrefixUnaryExpression(node.operator, operand);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updatePostfixUnaryExpression(node: PostfixUnaryExpression, operand: LeftHandSideExpression): PostfixUnaryExpression {
        if (operand !== node.operand) {
            let newNode = createPostfixUnaryExpression(operand, node.operator);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateBinaryExpression(node: BinaryExpression, left: Expression, right: Expression): BinaryExpression {
        if (left !== node.left || right !== node.right) {
            let newNode = createBinaryExpression(left, node.operatorToken, right);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateConditionalExpression(node: ConditionalExpression, condition: Expression, whenTrue: Expression, whenFalse: Expression): ConditionalExpression {
        if (condition !== node.condition || whenTrue !== node.whenTrue || whenFalse !== node.whenFalse) {
            let newNode = createConditionalExpression(condition, node.questionToken, whenTrue, node.colonToken, whenFalse);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateTemplateExpression(node: TemplateExpression, head: LiteralExpression, templateSpans: Array<TemplateSpan>): TemplateExpression {
        if (head !== node.head || templateSpans !== node.templateSpans) {
            let newNode = createTemplateExpression(head, templateSpans);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateYieldExpression(node: YieldExpression, expression: Expression): YieldExpression {
        if (expression !== node.expression) {
            let newNode = createYieldExpression(node.asteriskToken, expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateSpreadElementExpression(node: SpreadElementExpression, expression: Expression): SpreadElementExpression {
        if (expression !== node.expression) {
            let newNode = createSpreadElementExpression(expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateClassExpression(node: ClassExpression, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: Identifier, typeParameters: Array<TypeParameterDeclaration>, heritageClauses: Array<HeritageClause>, members: Array<ClassElement>): ClassExpression {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || heritageClauses !== node.heritageClauses || members !== node.members) {
            let newNode = createClassExpression(decorators, modifiers, name, typeParameters, heritageClauses, members);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateExpressionWithTypeArguments(node: ExpressionWithTypeArguments, expression: LeftHandSideExpression, typeArguments: Array<TypeNode>): ExpressionWithTypeArguments {
        if (expression !== node.expression || typeArguments !== node.typeArguments) {
            let newNode = createExpressionWithTypeArguments(expression, typeArguments);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateAsExpression(node: AsExpression, expression: Expression, type: TypeNode): AsExpression {
        if (expression !== node.expression || type !== node.type) {
            let newNode = createAsExpression(expression, type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateTemplateSpan(node: TemplateSpan, expression: Expression, literal: LiteralExpression): TemplateSpan {
        if (expression !== node.expression || literal !== node.literal) {
            let newNode = createTemplateSpan(expression, literal);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateBlock(node: Block, statements: Array<Statement>): Block {
        if (statements !== node.statements) {
            let newNode = createBlock(statements);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateVariableStatement(node: VariableStatement, decorators: Array<Decorator>, modifiers: Array<Modifier>, declarationList: VariableDeclarationList): VariableStatement {
        if (decorators !== node.decorators || modifiers !== node.modifiers || declarationList !== node.declarationList) {
            let newNode = createVariableStatement(decorators, modifiers, declarationList);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateExpressionStatement(node: ExpressionStatement, expression: Expression): ExpressionStatement {
        if (expression !== node.expression) {
            let newNode = createExpressionStatement(expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateIfStatement(node: IfStatement, expression: Expression, thenStatement: Statement, elseStatement: Statement): IfStatement {
        if (expression !== node.expression || thenStatement !== node.thenStatement || elseStatement !== node.elseStatement) {
            let newNode = createIfStatement(expression, thenStatement, elseStatement);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateDoStatement(node: DoStatement, statement: Statement, expression: Expression): DoStatement {
        if (statement !== node.statement || expression !== node.expression) {
            let newNode = createDoStatement(statement, expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateWhileStatement(node: WhileStatement, expression: Expression, statement: Statement): WhileStatement {
        if (expression !== node.expression || statement !== node.statement) {
            let newNode = createWhileStatement(expression, statement);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateForStatement(node: ForStatement, initializer: Expression | VariableDeclarationList, condition: Expression, incrementor: Expression, statement: Statement): ForStatement {
        if (initializer !== node.initializer || condition !== node.condition || incrementor !== node.incrementor || statement !== node.statement) {
            let newNode = createForStatement(initializer, condition, incrementor, statement);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateForInStatement(node: ForInStatement, initializer: Expression | VariableDeclarationList, expression: Expression, statement: Statement): ForInStatement {
        if (initializer !== node.initializer || expression !== node.expression || statement !== node.statement) {
            let newNode = createForInStatement(initializer, expression, statement);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateForOfStatement(node: ForOfStatement, initializer: Expression | VariableDeclarationList, expression: Expression, statement: Statement): ForOfStatement {
        if (initializer !== node.initializer || expression !== node.expression || statement !== node.statement) {
            let newNode = createForOfStatement(initializer, expression, statement);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateContinueStatement(node: ContinueStatement, label: Identifier): ContinueStatement {
        if (label !== node.label) {
            let newNode = createContinueStatement(label);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateBreakStatement(node: BreakStatement, label: Identifier): BreakStatement {
        if (label !== node.label) {
            let newNode = createBreakStatement(label);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateReturnStatement(node: ReturnStatement, expression: Expression): ReturnStatement {
        if (expression !== node.expression) {
            let newNode = createReturnStatement(expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateWithStatement(node: WithStatement, expression: Expression, statement: Statement): WithStatement {
        if (expression !== node.expression || statement !== node.statement) {
            let newNode = createWithStatement(expression, statement);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateSwitchStatement(node: SwitchStatement, expression: Expression, caseBlock: CaseBlock): SwitchStatement {
        if (expression !== node.expression || caseBlock !== node.caseBlock) {
            let newNode = createSwitchStatement(expression, caseBlock);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateLabeledStatement(node: LabeledStatement, label: Identifier, statement: Statement): LabeledStatement {
        if (label !== node.label || statement !== node.statement) {
            let newNode = createLabeledStatement(label, statement);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateThrowStatement(node: ThrowStatement, expression: Expression): ThrowStatement {
        if (expression !== node.expression) {
            let newNode = createThrowStatement(expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateTryStatement(node: TryStatement, tryBlock: Block, catchClause: CatchClause, finallyBlock: Block): TryStatement {
        if (tryBlock !== node.tryBlock || catchClause !== node.catchClause || finallyBlock !== node.finallyBlock) {
            let newNode = createTryStatement(tryBlock, catchClause, finallyBlock);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateVariableDeclaration(node: VariableDeclaration, name: BindingPattern | Identifier, type: TypeNode, initializer: Expression): VariableDeclaration {
        if (name !== node.name || type !== node.type || initializer !== node.initializer) {
            let newNode = createVariableDeclaration(name, type, initializer);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateVariableDeclarationList(node: VariableDeclarationList, declarations: Array<VariableDeclaration>): VariableDeclarationList {
        if (declarations !== node.declarations) {
            let newNode = createVariableDeclarationList(declarations);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateFunctionDeclaration(node: FunctionDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: Identifier, typeParameters: Array<TypeParameterDeclaration>, parameters: Array<ParameterDeclaration>, type: TypeNode, body: FunctionBody): FunctionDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || parameters !== node.parameters || type !== node.type || body !== node.body) {
            let newNode = createFunctionDeclaration(decorators, modifiers, node.asteriskToken, name, typeParameters, parameters, type, body);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateClassDeclaration(node: ClassDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: Identifier, typeParameters: Array<TypeParameterDeclaration>, heritageClauses: Array<HeritageClause>, members: Array<ClassElement>): ClassDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || heritageClauses !== node.heritageClauses || members !== node.members) {
            let newNode = createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateInterfaceDeclaration(node: InterfaceDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: Identifier, typeParameters: Array<TypeParameterDeclaration>, heritageClauses: Array<HeritageClause>, members: Array<TypeElement>): InterfaceDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || heritageClauses !== node.heritageClauses || members !== node.members) {
            let newNode = createInterfaceDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateTypeAliasDeclaration(node: TypeAliasDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: Identifier, typeParameters: Array<TypeParameterDeclaration>, type: TypeNode): TypeAliasDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || type !== node.type) {
            let newNode = createTypeAliasDeclaration(decorators, modifiers, name, typeParameters, type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateEnumDeclaration(node: EnumDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: Identifier, members: Array<EnumMember>): EnumDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || members !== node.members) {
            let newNode = createEnumDeclaration(decorators, modifiers, name, members);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateModuleDeclaration(node: ModuleDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: Identifier | LiteralExpression, body: ModuleBody): ModuleDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || body !== node.body) {
            let newNode = createModuleDeclaration(decorators, modifiers, name, body);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateModuleBlock(node: ModuleBlock, statements: Array<Statement>): ModuleBlock {
        if (statements !== node.statements) {
            let newNode = createModuleBlock(statements);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateCaseBlock(node: CaseBlock, clauses: Array<CaseOrDefaultClause>): CaseBlock {
        if (clauses !== node.clauses) {
            let newNode = createCaseBlock(clauses);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateImportEqualsDeclaration(node: ImportEqualsDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, name: Identifier, moduleReference: EntityName | ExternalModuleReference): ImportEqualsDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || moduleReference !== node.moduleReference) {
            let newNode = createImportEqualsDeclaration(decorators, modifiers, name, moduleReference);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateImportDeclaration(node: ImportDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, importClause: ImportClause, moduleSpecifier: Expression): ImportDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || importClause !== node.importClause || moduleSpecifier !== node.moduleSpecifier) {
            let newNode = createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateImportClause(node: ImportClause, name: Identifier, namedBindings: NamedImports | NamespaceImport): ImportClause {
        if (name !== node.name || namedBindings !== node.namedBindings) {
            let newNode = createImportClause(name, namedBindings);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateNamespaceImport(node: NamespaceImport, name: Identifier): NamespaceImport {
        if (name !== node.name) {
            let newNode = createNamespaceImport(name);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateNamedImports(node: NamedImports, elements: Array<ImportSpecifier>): NamedImports {
        if (elements !== node.elements) {
            let newNode = createNamedImports(elements);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateImportSpecifier(node: ImportSpecifier, propertyName: Identifier, name: Identifier): ImportSpecifier {
        if (propertyName !== node.propertyName || name !== node.name) {
            let newNode = createImportSpecifier(propertyName, name);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateExportAssignment(node: ExportAssignment, decorators: Array<Decorator>, modifiers: Array<Modifier>, expression: Expression): ExportAssignment {
        if (decorators !== node.decorators || modifiers !== node.modifiers || expression !== node.expression) {
            let newNode = createExportAssignment(decorators, modifiers, expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateExportDeclaration(node: ExportDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>, exportClause: NamedExports, moduleSpecifier: Expression): ExportDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers || exportClause !== node.exportClause || moduleSpecifier !== node.moduleSpecifier) {
            let newNode = createExportDeclaration(decorators, modifiers, exportClause, moduleSpecifier);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateNamedExports(node: NamedExports, elements: Array<ExportSpecifier>): NamedExports {
        if (elements !== node.elements) {
            let newNode = createNamedExports(elements);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateExportSpecifier(node: ExportSpecifier, propertyName: Identifier, name: Identifier): ExportSpecifier {
        if (propertyName !== node.propertyName || name !== node.name) {
            let newNode = createExportSpecifier(propertyName, name);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateMissingDeclaration(node: MissingDeclaration, decorators: Array<Decorator>, modifiers: Array<Modifier>): MissingDeclaration {
        if (decorators !== node.decorators || modifiers !== node.modifiers) {
            let newNode = createMissingDeclaration(decorators, modifiers, node.questionToken);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateExternalModuleReference(node: ExternalModuleReference, expression: Expression): ExternalModuleReference {
        if (expression !== node.expression) {
            let newNode = createExternalModuleReference(expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJsxElement(node: JsxElement, openingElement: JsxOpeningElement, children: Array<JsxChild>, closingElement: JsxClosingElement): JsxElement {
        if (openingElement !== node.openingElement || children !== node.children || closingElement !== node.closingElement) {
            let newNode = createJsxElement(openingElement, children, closingElement);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJsxSelfClosingElement(node: JsxSelfClosingElement, tagName: EntityName, attributes: Array<JsxAttribute | JsxSpreadAttribute>): JsxSelfClosingElement {
        if (tagName !== node.tagName || attributes !== node.attributes) {
            let newNode = createJsxSelfClosingElement(tagName, attributes);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJsxOpeningElement(node: JsxOpeningElement, tagName: EntityName, attributes: Array<JsxAttribute | JsxSpreadAttribute>): JsxOpeningElement {
        if (tagName !== node.tagName || attributes !== node.attributes) {
            let newNode = createJsxOpeningElement(tagName, attributes);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJsxClosingElement(node: JsxClosingElement, tagName: EntityName): JsxClosingElement {
        if (tagName !== node.tagName) {
            let newNode = createJsxClosingElement(tagName);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJsxAttribute(node: JsxAttribute, name: Identifier, initializer: Expression): JsxAttribute {
        if (name !== node.name || initializer !== node.initializer) {
            let newNode = createJsxAttribute(name, initializer);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJsxSpreadAttribute(node: JsxSpreadAttribute, expression: Expression): JsxSpreadAttribute {
        if (expression !== node.expression) {
            let newNode = createJsxSpreadAttribute(expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJsxExpression(node: JsxExpression, expression: Expression): JsxExpression {
        if (expression !== node.expression) {
            let newNode = createJsxExpression(expression);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateCaseClause(node: CaseClause, expression: Expression, statements: Array<Statement>): CaseClause {
        if (expression !== node.expression || statements !== node.statements) {
            let newNode = createCaseClause(expression, statements);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateDefaultClause(node: DefaultClause, statements: Array<Statement>): DefaultClause {
        if (statements !== node.statements) {
            let newNode = createDefaultClause(statements);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateHeritageClause(node: HeritageClause, types: Array<ExpressionWithTypeArguments>): HeritageClause {
        if (types !== node.types) {
            let newNode = createHeritageClause(node.token, types);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateCatchClause(node: CatchClause, variableDeclaration: VariableDeclaration, block: Block): CatchClause {
        if (variableDeclaration !== node.variableDeclaration || block !== node.block) {
            let newNode = createCatchClause(variableDeclaration, block);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updatePropertyAssignment(node: PropertyAssignment, name: PropertyName, initializer: Expression): PropertyAssignment {
        if (name !== node.name || initializer !== node.initializer) {
            let newNode = createPropertyAssignment(name, initializer);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateShorthandPropertyAssignment(node: ShorthandPropertyAssignment, name: Identifier, equalsToken: Node, objectAssignmentInitializer: Expression): ShorthandPropertyAssignment {
        if (name !== node.name || equalsToken !== node.equalsToken || objectAssignmentInitializer !== node.objectAssignmentInitializer) {
            let newNode = createShorthandPropertyAssignment(name, equalsToken, objectAssignmentInitializer);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateEnumMember(node: EnumMember, name: DeclarationName, initializer: Expression): EnumMember {
        if (name !== node.name || initializer !== node.initializer) {
            let newNode = createEnumMember(name, initializer);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateSourceFileNode(node: SourceFile, statements: Array<Statement>, endOfFileToken: Node): SourceFile {
        if (statements !== node.statements || endOfFileToken !== node.endOfFileToken) {
            let newNode = createSourceFileNode(statements, endOfFileToken, node.fileName, node.text, node.amdDependencies, node.moduleName, node.referencedFiles, node.languageVariant, node.renamedDependencies, node.hasNoDefaultLib, node.languageVersion, node.externalModuleIndicator, node.isDefaultLib, node.identifiers, node.parseDiagnostics, node.bindDiagnostics, node.lineMap, node.classifiableNames, node.resolvedModules, node.imports);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocTypeExpression(node: JSDocTypeExpression, type: JSDocType): JSDocTypeExpression {
        if (type !== node.type) {
            let newNode = createJSDocTypeExpression(type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocArrayType(node: JSDocArrayType, elementType: JSDocType): JSDocArrayType {
        if (elementType !== node.elementType) {
            let newNode = createJSDocArrayType(elementType);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocUnionType(node: JSDocUnionType, types: Array<JSDocType>): JSDocUnionType {
        if (types !== node.types) {
            let newNode = createJSDocUnionType(types);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocTupleType(node: JSDocTupleType, types: Array<JSDocType>): JSDocTupleType {
        if (types !== node.types) {
            let newNode = createJSDocTupleType(types);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocNullableType(node: JSDocNullableType, type: JSDocType): JSDocNullableType {
        if (type !== node.type) {
            let newNode = createJSDocNullableType(type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocNonNullableType(node: JSDocNonNullableType, type: JSDocType): JSDocNonNullableType {
        if (type !== node.type) {
            let newNode = createJSDocNonNullableType(type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocRecordType(node: JSDocRecordType, members: Array<JSDocRecordMember>): JSDocRecordType {
        if (members !== node.members) {
            let newNode = createJSDocRecordType(members);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocRecordMember(node: JSDocRecordMember, name: Identifier | LiteralExpression, type: JSDocType): JSDocRecordMember {
        if (name !== node.name || type !== node.type) {
            let newNode = createJSDocRecordMember(name, type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocTypeReference(node: JSDocTypeReference, name: EntityName, typeArguments: Array<JSDocType>): JSDocTypeReference {
        if (name !== node.name || typeArguments !== node.typeArguments) {
            let newNode = createJSDocTypeReference(name, typeArguments);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocOptionalType(node: JSDocOptionalType, type: JSDocType): JSDocOptionalType {
        if (type !== node.type) {
            let newNode = createJSDocOptionalType(type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocFunctionType(node: JSDocFunctionType, parameters: Array<ParameterDeclaration>, type: JSDocType): JSDocFunctionType {
        if (parameters !== node.parameters || type !== node.type) {
            let newNode = createJSDocFunctionType(parameters, type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocVariadicType(node: JSDocVariadicType, type: JSDocType): JSDocVariadicType {
        if (type !== node.type) {
            let newNode = createJSDocVariadicType(type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocConstructorType(node: JSDocConstructorType, type: JSDocType): JSDocConstructorType {
        if (type !== node.type) {
            let newNode = createJSDocConstructorType(type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocThisType(node: JSDocThisType, type: JSDocType): JSDocThisType {
        if (type !== node.type) {
            let newNode = createJSDocThisType(type);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocComment(node: JSDocComment, tags: Array<JSDocTag>): JSDocComment {
        if (tags !== node.tags) {
            let newNode = createJSDocComment(tags);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocTag(node: JSDocTag, tagName: Identifier): JSDocTag {
        if (tagName !== node.tagName) {
            let newNode = createJSDocTag(node.atToken, tagName);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocParameterTag(node: JSDocParameterTag, preParameterName: Identifier, typeExpression: JSDocTypeExpression, postParameterName: Identifier, tagName: Identifier): JSDocParameterTag {
        if (preParameterName !== node.preParameterName || typeExpression !== node.typeExpression || postParameterName !== node.postParameterName || tagName !== node.tagName) {
            let newNode = createJSDocParameterTag(preParameterName, typeExpression, postParameterName, node.atToken, tagName);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocReturnTag(node: JSDocReturnTag, typeExpression: JSDocTypeExpression, tagName: Identifier): JSDocReturnTag {
        if (typeExpression !== node.typeExpression || tagName !== node.tagName) {
            let newNode = createJSDocReturnTag(typeExpression, node.atToken, tagName);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocTypeTag(node: JSDocTypeTag, typeExpression: JSDocTypeExpression, tagName: Identifier): JSDocTypeTag {
        if (typeExpression !== node.typeExpression || tagName !== node.tagName) {
            let newNode = createJSDocTypeTag(typeExpression, node.atToken, tagName);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function updateJSDocTemplateTag(node: JSDocTemplateTag, typeParameters: Array<TypeParameterDeclaration>, tagName: Identifier): JSDocTemplateTag {
        if (typeParameters !== node.typeParameters || tagName !== node.tagName) {
            let newNode = createJSDocTemplateTag(typeParameters, node.atToken, tagName);
            return updateFrom(node, newNode);
        }
        return node;
    }
    export function isNumericLiteral(node: Node): node is LiteralExpression {
        return node && node.kind === SyntaxKind.NumericLiteral;
    }
    export function isStringLiteral(node: Node): node is StringLiteral {
        return node && node.kind === SyntaxKind.StringLiteral;
    }
    export function isRegularExpressionLiteral(node: Node): node is LiteralExpression {
        return node && node.kind === SyntaxKind.RegularExpressionLiteral;
    }
    export function isNoSubstitutionTemplateLiteral(node: Node): node is LiteralExpression {
        return node && node.kind === SyntaxKind.NoSubstitutionTemplateLiteral;
    }
    export function isTemplateHead(node: Node): node is LiteralExpression {
        return node && node.kind === SyntaxKind.TemplateHead;
    }
    export function isTemplateMiddle(node: Node): node is LiteralExpression {
        return node && node.kind === SyntaxKind.TemplateMiddle;
    }
    export function isTemplateTail(node: Node): node is LiteralExpression {
        return node && node.kind === SyntaxKind.TemplateTail;
    }
    export function isIdentifier(node: Node): node is Identifier {
        return node && node.kind === SyntaxKind.Identifier;
    }
    export function isFalseKeyword(node: Node): node is PrimaryExpression {
        return node && node.kind === SyntaxKind.FalseKeyword;
    }
    export function isNullKeyword(node: Node): node is PrimaryExpression {
        return node && node.kind === SyntaxKind.NullKeyword;
    }
    export function isSuperKeyword(node: Node): node is PrimaryExpression {
        return node && node.kind === SyntaxKind.SuperKeyword;
    }
    export function isThisKeyword(node: Node): node is PrimaryExpression {
        return node && node.kind === SyntaxKind.ThisKeyword;
    }
    export function isTrueKeyword(node: Node): node is PrimaryExpression {
        return node && node.kind === SyntaxKind.TrueKeyword;
    }
    export function isQualifiedName(node: Node): node is QualifiedName {
        return node && node.kind === SyntaxKind.QualifiedName;
    }
    export function isComputedPropertyName(node: Node): node is ComputedPropertyName {
        return node && node.kind === SyntaxKind.ComputedPropertyName;
    }
    export function isTypeParameter(node: Node): node is TypeParameterDeclaration {
        return node && node.kind === SyntaxKind.TypeParameter;
    }
    export function isParameter(node: Node): node is ParameterDeclaration {
        return node && node.kind === SyntaxKind.Parameter;
    }
    export function isDecorator(node: Node): node is Decorator {
        return node && node.kind === SyntaxKind.Decorator;
    }
    export function isPropertySignature(node: Node): node is PropertySignature {
        return node && node.kind === SyntaxKind.PropertySignature;
    }
    export function isPropertyDeclaration(node: Node): node is PropertyDeclaration {
        return node && node.kind === SyntaxKind.PropertyDeclaration;
    }
    export function isMethodSignature(node: Node): node is MethodSignature {
        return node && node.kind === SyntaxKind.MethodSignature;
    }
    export function isMethodDeclaration(node: Node): node is MethodDeclaration {
        return node && node.kind === SyntaxKind.MethodDeclaration;
    }
    export function isConstructor(node: Node): node is ConstructorDeclaration {
        return node && node.kind === SyntaxKind.Constructor;
    }
    export function isGetAccessor(node: Node): node is GetAccessorDeclaration {
        return node && node.kind === SyntaxKind.GetAccessor;
    }
    export function isSetAccessor(node: Node): node is SetAccessorDeclaration {
        return node && node.kind === SyntaxKind.SetAccessor;
    }
    export function isCallSignature(node: Node): node is CallSignatureDeclaration {
        return node && node.kind === SyntaxKind.CallSignature;
    }
    export function isConstructSignature(node: Node): node is ConstructSignatureDeclaration {
        return node && node.kind === SyntaxKind.ConstructSignature;
    }
    export function isIndexSignature(node: Node): node is IndexSignatureDeclaration {
        return node && node.kind === SyntaxKind.IndexSignature;
    }
    export function isTypePredicate(node: Node): node is TypePredicateNode {
        return node && node.kind === SyntaxKind.TypePredicate;
    }
    export function isTypeReference(node: Node): node is TypeReferenceNode {
        return node && node.kind === SyntaxKind.TypeReference;
    }
    export function isFunctionType(node: Node): node is FunctionTypeNode {
        return node && node.kind === SyntaxKind.FunctionType;
    }
    export function isConstructorType(node: Node): node is ConstructorTypeNode {
        return node && node.kind === SyntaxKind.ConstructorType;
    }
    export function isTypeQuery(node: Node): node is TypeQueryNode {
        return node && node.kind === SyntaxKind.TypeQuery;
    }
    export function isTypeLiteral(node: Node): node is TypeLiteralNode {
        return node && node.kind === SyntaxKind.TypeLiteral;
    }
    export function isArrayType(node: Node): node is ArrayTypeNode {
        return node && node.kind === SyntaxKind.ArrayType;
    }
    export function isTupleType(node: Node): node is TupleTypeNode {
        return node && node.kind === SyntaxKind.TupleType;
    }
    export function isUnionType(node: Node): node is UnionTypeNode {
        return node && node.kind === SyntaxKind.UnionType;
    }
    export function isIntersectionType(node: Node): node is IntersectionTypeNode {
        return node && node.kind === SyntaxKind.IntersectionType;
    }
    export function isParenthesizedType(node: Node): node is ParenthesizedTypeNode {
        return node && node.kind === SyntaxKind.ParenthesizedType;
    }
    export function isObjectBindingPattern(node: Node): node is ObjectBindingPattern {
        return node && node.kind === SyntaxKind.ObjectBindingPattern;
    }
    export function isArrayBindingPattern(node: Node): node is ArrayBindingPattern {
        return node && node.kind === SyntaxKind.ArrayBindingPattern;
    }
    export function isBindingElement(node: Node): node is BindingElement {
        return node && node.kind === SyntaxKind.BindingElement;
    }
    export function isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression {
        return node && node.kind === SyntaxKind.ArrayLiteralExpression;
    }
    export function isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression {
        return node && node.kind === SyntaxKind.ObjectLiteralExpression;
    }
    export function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression {
        return node && node.kind === SyntaxKind.PropertyAccessExpression;
    }
    export function isElementAccessExpression(node: Node): node is ElementAccessExpression {
        return node && node.kind === SyntaxKind.ElementAccessExpression;
    }
    export function isCallExpression(node: Node): node is CallExpression {
        return node && node.kind === SyntaxKind.CallExpression;
    }
    export function isNewExpression(node: Node): node is NewExpression {
        return node && node.kind === SyntaxKind.NewExpression;
    }
    export function isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression {
        return node && node.kind === SyntaxKind.TaggedTemplateExpression;
    }
    export function isTypeAssertionExpression(node: Node): node is TypeAssertion {
        return node && node.kind === SyntaxKind.TypeAssertionExpression;
    }
    export function isParenthesizedExpression(node: Node): node is ParenthesizedExpression {
        return node && node.kind === SyntaxKind.ParenthesizedExpression;
    }
    export function isFunctionExpression(node: Node): node is FunctionExpression {
        return node && node.kind === SyntaxKind.FunctionExpression;
    }
    export function isArrowFunction(node: Node): node is ArrowFunction {
        return node && node.kind === SyntaxKind.ArrowFunction;
    }
    export function isDeleteExpression(node: Node): node is DeleteExpression {
        return node && node.kind === SyntaxKind.DeleteExpression;
    }
    export function isTypeOfExpression(node: Node): node is TypeOfExpression {
        return node && node.kind === SyntaxKind.TypeOfExpression;
    }
    export function isVoidExpression(node: Node): node is VoidExpression {
        return node && node.kind === SyntaxKind.VoidExpression;
    }
    export function isAwaitExpression(node: Node): node is AwaitExpression {
        return node && node.kind === SyntaxKind.AwaitExpression;
    }
    export function isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression {
        return node && node.kind === SyntaxKind.PrefixUnaryExpression;
    }
    export function isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression {
        return node && node.kind === SyntaxKind.PostfixUnaryExpression;
    }
    export function isBinaryExpression(node: Node): node is BinaryExpression {
        return node && node.kind === SyntaxKind.BinaryExpression;
    }
    export function isConditionalExpression(node: Node): node is ConditionalExpression {
        return node && node.kind === SyntaxKind.ConditionalExpression;
    }
    export function isTemplateExpression(node: Node): node is TemplateExpression {
        return node && node.kind === SyntaxKind.TemplateExpression;
    }
    export function isYieldExpression(node: Node): node is YieldExpression {
        return node && node.kind === SyntaxKind.YieldExpression;
    }
    export function isSpreadElementExpression(node: Node): node is SpreadElementExpression {
        return node && node.kind === SyntaxKind.SpreadElementExpression;
    }
    export function isClassExpression(node: Node): node is ClassExpression {
        return node && node.kind === SyntaxKind.ClassExpression;
    }
    export function isOmittedExpression(node: Node): node is OmittedExpression {
        return node && node.kind === SyntaxKind.OmittedExpression;
    }
    export function isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments {
        return node && node.kind === SyntaxKind.ExpressionWithTypeArguments;
    }
    export function isAsExpression(node: Node): node is AsExpression {
        return node && node.kind === SyntaxKind.AsExpression;
    }
    export function isTemplateSpan(node: Node): node is TemplateSpan {
        return node && node.kind === SyntaxKind.TemplateSpan;
    }
    export function isSemicolonClassElement(node: Node): node is SemicolonClassElement {
        return node && node.kind === SyntaxKind.SemicolonClassElement;
    }
    export function isBlock(node: Node): node is Block {
        return node && node.kind === SyntaxKind.Block;
    }
    export function isVariableStatement(node: Node): node is VariableStatement {
        return node && node.kind === SyntaxKind.VariableStatement;
    }
    export function isEmptyStatement(node: Node): node is EmptyStatement {
        return node && node.kind === SyntaxKind.EmptyStatement;
    }
    export function isExpressionStatement(node: Node): node is ExpressionStatement {
        return node && node.kind === SyntaxKind.ExpressionStatement;
    }
    export function isIfStatement(node: Node): node is IfStatement {
        return node && node.kind === SyntaxKind.IfStatement;
    }
    export function isDoStatement(node: Node): node is DoStatement {
        return node && node.kind === SyntaxKind.DoStatement;
    }
    export function isWhileStatement(node: Node): node is WhileStatement {
        return node && node.kind === SyntaxKind.WhileStatement;
    }
    export function isForStatement(node: Node): node is ForStatement {
        return node && node.kind === SyntaxKind.ForStatement;
    }
    export function isForInStatement(node: Node): node is ForInStatement {
        return node && node.kind === SyntaxKind.ForInStatement;
    }
    export function isForOfStatement(node: Node): node is ForOfStatement {
        return node && node.kind === SyntaxKind.ForOfStatement;
    }
    export function isContinueStatement(node: Node): node is ContinueStatement {
        return node && node.kind === SyntaxKind.ContinueStatement;
    }
    export function isBreakStatement(node: Node): node is BreakStatement {
        return node && node.kind === SyntaxKind.BreakStatement;
    }
    export function isReturnStatement(node: Node): node is ReturnStatement {
        return node && node.kind === SyntaxKind.ReturnStatement;
    }
    export function isWithStatement(node: Node): node is WithStatement {
        return node && node.kind === SyntaxKind.WithStatement;
    }
    export function isSwitchStatement(node: Node): node is SwitchStatement {
        return node && node.kind === SyntaxKind.SwitchStatement;
    }
    export function isLabeledStatement(node: Node): node is LabeledStatement {
        return node && node.kind === SyntaxKind.LabeledStatement;
    }
    export function isThrowStatement(node: Node): node is ThrowStatement {
        return node && node.kind === SyntaxKind.ThrowStatement;
    }
    export function isTryStatement(node: Node): node is TryStatement {
        return node && node.kind === SyntaxKind.TryStatement;
    }
    export function isDebuggerStatement(node: Node): node is DebuggerStatement {
        return node && node.kind === SyntaxKind.DebuggerStatement;
    }
    export function isVariableDeclaration(node: Node): node is VariableDeclaration {
        return node && node.kind === SyntaxKind.VariableDeclaration;
    }
    export function isVariableDeclarationList(node: Node): node is VariableDeclarationList {
        return node && node.kind === SyntaxKind.VariableDeclarationList;
    }
    export function isFunctionDeclaration(node: Node): node is FunctionDeclaration {
        return node && node.kind === SyntaxKind.FunctionDeclaration;
    }
    export function isClassDeclaration(node: Node): node is ClassDeclaration {
        return node && node.kind === SyntaxKind.ClassDeclaration;
    }
    export function isInterfaceDeclaration(node: Node): node is InterfaceDeclaration {
        return node && node.kind === SyntaxKind.InterfaceDeclaration;
    }
    export function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration {
        return node && node.kind === SyntaxKind.TypeAliasDeclaration;
    }
    export function isEnumDeclaration(node: Node): node is EnumDeclaration {
        return node && node.kind === SyntaxKind.EnumDeclaration;
    }
    export function isModuleDeclaration(node: Node): node is ModuleDeclaration {
        return node && node.kind === SyntaxKind.ModuleDeclaration;
    }
    export function isModuleBlock(node: Node): node is ModuleBlock {
        return node && node.kind === SyntaxKind.ModuleBlock;
    }
    export function isCaseBlock(node: Node): node is CaseBlock {
        return node && node.kind === SyntaxKind.CaseBlock;
    }
    export function isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration {
        return node && node.kind === SyntaxKind.ImportEqualsDeclaration;
    }
    export function isImportDeclaration(node: Node): node is ImportDeclaration {
        return node && node.kind === SyntaxKind.ImportDeclaration;
    }
    export function isImportClause(node: Node): node is ImportClause {
        return node && node.kind === SyntaxKind.ImportClause;
    }
    export function isNamespaceImport(node: Node): node is NamespaceImport {
        return node && node.kind === SyntaxKind.NamespaceImport;
    }
    export function isNamedImports(node: Node): node is NamedImports {
        return node && node.kind === SyntaxKind.NamedImports;
    }
    export function isImportSpecifier(node: Node): node is ImportSpecifier {
        return node && node.kind === SyntaxKind.ImportSpecifier;
    }
    export function isExportAssignment(node: Node): node is ExportAssignment {
        return node && node.kind === SyntaxKind.ExportAssignment;
    }
    export function isExportDeclaration(node: Node): node is ExportDeclaration {
        return node && node.kind === SyntaxKind.ExportDeclaration;
    }
    export function isNamedExports(node: Node): node is NamedExports {
        return node && node.kind === SyntaxKind.NamedExports;
    }
    export function isExportSpecifier(node: Node): node is ExportSpecifier {
        return node && node.kind === SyntaxKind.ExportSpecifier;
    }
    export function isMissingDeclaration(node: Node): node is MissingDeclaration {
        return node && node.kind === SyntaxKind.MissingDeclaration;
    }
    export function isExternalModuleReference(node: Node): node is ExternalModuleReference {
        return node && node.kind === SyntaxKind.ExternalModuleReference;
    }
    export function isJsxElement(node: Node): node is JsxElement {
        return node && node.kind === SyntaxKind.JsxElement;
    }
    export function isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement {
        return node && node.kind === SyntaxKind.JsxSelfClosingElement;
    }
    export function isJsxOpeningElement(node: Node): node is JsxOpeningElement {
        return node && node.kind === SyntaxKind.JsxOpeningElement;
    }
    export function isJsxText(node: Node): node is JsxText {
        return node && node.kind === SyntaxKind.JsxText;
    }
    export function isJsxClosingElement(node: Node): node is JsxClosingElement {
        return node && node.kind === SyntaxKind.JsxClosingElement;
    }
    export function isJsxAttribute(node: Node): node is JsxAttribute {
        return node && node.kind === SyntaxKind.JsxAttribute;
    }
    export function isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute {
        return node && node.kind === SyntaxKind.JsxSpreadAttribute;
    }
    export function isJsxExpression(node: Node): node is JsxExpression {
        return node && node.kind === SyntaxKind.JsxExpression;
    }
    export function isCaseClause(node: Node): node is CaseClause {
        return node && node.kind === SyntaxKind.CaseClause;
    }
    export function isDefaultClause(node: Node): node is DefaultClause {
        return node && node.kind === SyntaxKind.DefaultClause;
    }
    export function isHeritageClause(node: Node): node is HeritageClause {
        return node && node.kind === SyntaxKind.HeritageClause;
    }
    export function isCatchClause(node: Node): node is CatchClause {
        return node && node.kind === SyntaxKind.CatchClause;
    }
    export function isPropertyAssignment(node: Node): node is PropertyAssignment {
        return node && node.kind === SyntaxKind.PropertyAssignment;
    }
    export function isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment {
        return node && node.kind === SyntaxKind.ShorthandPropertyAssignment;
    }
    export function isEnumMember(node: Node): node is EnumMember {
        return node && node.kind === SyntaxKind.EnumMember;
    }
    export function isSourceFile(node: Node): node is SourceFile {
        return node && node.kind === SyntaxKind.SourceFile;
    }
    export function isJSDocTypeExpression(node: Node): node is JSDocTypeExpression {
        return node && node.kind === SyntaxKind.JSDocTypeExpression;
    }
    export function isJSDocAllType(node: Node): node is JSDocAllType {
        return node && node.kind === SyntaxKind.JSDocAllType;
    }
    export function isJSDocUnknownType(node: Node): node is JSDocUnknownType {
        return node && node.kind === SyntaxKind.JSDocUnknownType;
    }
    export function isJSDocArrayType(node: Node): node is JSDocArrayType {
        return node && node.kind === SyntaxKind.JSDocArrayType;
    }
    export function isJSDocUnionType(node: Node): node is JSDocUnionType {
        return node && node.kind === SyntaxKind.JSDocUnionType;
    }
    export function isJSDocTupleType(node: Node): node is JSDocTupleType {
        return node && node.kind === SyntaxKind.JSDocTupleType;
    }
    export function isJSDocNullableType(node: Node): node is JSDocNullableType {
        return node && node.kind === SyntaxKind.JSDocNullableType;
    }
    export function isJSDocNonNullableType(node: Node): node is JSDocNonNullableType {
        return node && node.kind === SyntaxKind.JSDocNonNullableType;
    }
    export function isJSDocRecordType(node: Node): node is JSDocRecordType {
        return node && node.kind === SyntaxKind.JSDocRecordType;
    }
    export function isJSDocRecordMember(node: Node): node is JSDocRecordMember {
        return node && node.kind === SyntaxKind.JSDocRecordMember;
    }
    export function isJSDocTypeReference(node: Node): node is JSDocTypeReference {
        return node && node.kind === SyntaxKind.JSDocTypeReference;
    }
    export function isJSDocOptionalType(node: Node): node is JSDocOptionalType {
        return node && node.kind === SyntaxKind.JSDocOptionalType;
    }
    export function isJSDocFunctionType(node: Node): node is JSDocFunctionType {
        return node && node.kind === SyntaxKind.JSDocFunctionType;
    }
    export function isJSDocVariadicType(node: Node): node is JSDocVariadicType {
        return node && node.kind === SyntaxKind.JSDocVariadicType;
    }
    export function isJSDocConstructorType(node: Node): node is JSDocConstructorType {
        return node && node.kind === SyntaxKind.JSDocConstructorType;
    }
    export function isJSDocThisType(node: Node): node is JSDocThisType {
        return node && node.kind === SyntaxKind.JSDocThisType;
    }
    export function isJSDocComment(node: Node): node is JSDocComment {
        return node && node.kind === SyntaxKind.JSDocComment;
    }
    export function isJSDocTag(node: Node): node is JSDocTag {
        return node && node.kind === SyntaxKind.JSDocTag;
    }
    export function isJSDocParameterTag(node: Node): node is JSDocParameterTag {
        return node && node.kind === SyntaxKind.JSDocParameterTag;
    }
    export function isJSDocReturnTag(node: Node): node is JSDocReturnTag {
        return node && node.kind === SyntaxKind.JSDocReturnTag;
    }
    export function isJSDocTypeTag(node: Node): node is JSDocTypeTag {
        return node && node.kind === SyntaxKind.JSDocTypeTag;
    }
    export function isJSDocTemplateTag(node: Node): node is JSDocTemplateTag {
        return node && node.kind === SyntaxKind.JSDocTemplateTag;
    }
    export function isRawExpression(node: Node): node is RawExpression {
        return node && node.kind === SyntaxKind.RawExpression;
    }
    export function isRawStatement(node: Node): node is RawStatement {
        return node && node.kind === SyntaxKind.RawStatement;
    }
    export function isFunctionBody(node: Node): node is FunctionBody {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.Block:
                    return true;
            }
        }
        return false;
    }
    export function isModifier(node: Node): node is Modifier {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.AbstractKeyword:
                case SyntaxKind.AsyncKeyword:
                case SyntaxKind.ConstKeyword:
                case SyntaxKind.DeclareKeyword:
                case SyntaxKind.DefaultKeyword:
                case SyntaxKind.ExportKeyword:
                case SyntaxKind.PublicKeyword:
                case SyntaxKind.PrivateKeyword:
                case SyntaxKind.ProtectedKeyword:
                case SyntaxKind.StaticKeyword:
                    return true;
            }
        }
        return false;
    }
    export function isExpressionNode(node: Node): node is Expression {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NullKeyword:
                case SyntaxKind.ThisKeyword:
                case SyntaxKind.SuperKeyword:
                case SyntaxKind.Identifier:
                case SyntaxKind.NumericLiteral:
                case SyntaxKind.RegularExpressionLiteral:
                case SyntaxKind.NoSubstitutionTemplateLiteral:
                case SyntaxKind.TemplateHead:
                case SyntaxKind.TemplateMiddle:
                case SyntaxKind.TemplateTail:
                case SyntaxKind.StringLiteral:
                case SyntaxKind.RawExpression:
                case SyntaxKind.ObjectLiteralExpression:
                case SyntaxKind.ArrayLiteralExpression:
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.TemplateExpression:
                case SyntaxKind.ParenthesizedExpression:
                case SyntaxKind.NewExpression:
                case SyntaxKind.JsxElement:
                case SyntaxKind.JsxSelfClosingElement:
                case SyntaxKind.ClassExpression:
                case SyntaxKind.PropertyAccessExpression:
                case SyntaxKind.ElementAccessExpression:
                case SyntaxKind.TaggedTemplateExpression:
                case SyntaxKind.CallExpression:
                case SyntaxKind.PrefixUnaryExpression:
                case SyntaxKind.PostfixUnaryExpression:
                case SyntaxKind.DeleteExpression:
                case SyntaxKind.TypeOfExpression:
                case SyntaxKind.VoidExpression:
                case SyntaxKind.AwaitExpression:
                case SyntaxKind.TypeAssertionExpression:
                case SyntaxKind.OmittedExpression:
                case SyntaxKind.YieldExpression:
                case SyntaxKind.BinaryExpression:
                case SyntaxKind.ConditionalExpression:
                case SyntaxKind.ArrowFunction:
                case SyntaxKind.SpreadElementExpression:
                case SyntaxKind.AsExpression:
                case SyntaxKind.JsxOpeningElement:
                case SyntaxKind.JsxExpression:
                    return true;
            }
        }
        return false;
    }
    export function isEntityName(node: Node): node is EntityName {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.Identifier:
                case SyntaxKind.QualifiedName:
                    return true;
            }
        }
        return false;
    }
    export function isDeclarationNameNode(node: Node): node is DeclarationName {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.ObjectBindingPattern:
                case SyntaxKind.ArrayBindingPattern:
                case SyntaxKind.ComputedPropertyName:
                case SyntaxKind.Identifier:
                case SyntaxKind.NumericLiteral:
                case SyntaxKind.RegularExpressionLiteral:
                case SyntaxKind.NoSubstitutionTemplateLiteral:
                case SyntaxKind.TemplateHead:
                case SyntaxKind.TemplateMiddle:
                case SyntaxKind.TemplateTail:
                case SyntaxKind.StringLiteral:
                case SyntaxKind.RawExpression:
                    return true;
            }
        }
        return false;
    }
    export function isPropertyName(node: Node): node is PropertyName {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.ComputedPropertyName:
                case SyntaxKind.Identifier:
                case SyntaxKind.NumericLiteral:
                case SyntaxKind.RegularExpressionLiteral:
                case SyntaxKind.NoSubstitutionTemplateLiteral:
                case SyntaxKind.TemplateHead:
                case SyntaxKind.TemplateMiddle:
                case SyntaxKind.TemplateTail:
                case SyntaxKind.StringLiteral:
                case SyntaxKind.RawExpression:
                    return true;
            }
        }
        return false;
    }
    export function isStatementNode(node: Node): node is Statement {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.MissingDeclaration:
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.TypeAliasDeclaration:
                case SyntaxKind.EnumDeclaration:
                case SyntaxKind.ModuleDeclaration:
                case SyntaxKind.ImportEqualsDeclaration:
                case SyntaxKind.ExportDeclaration:
                case SyntaxKind.ExportAssignment:
                case SyntaxKind.Block:
                case SyntaxKind.RawStatement:
                case SyntaxKind.EmptyStatement:
                case SyntaxKind.DebuggerStatement:
                case SyntaxKind.ModuleBlock:
                case SyntaxKind.VariableStatement:
                case SyntaxKind.ExpressionStatement:
                case SyntaxKind.IfStatement:
                case SyntaxKind.DoStatement:
                case SyntaxKind.WhileStatement:
                case SyntaxKind.ForStatement:
                case SyntaxKind.ForInStatement:
                case SyntaxKind.ForOfStatement:
                case SyntaxKind.BreakStatement:
                case SyntaxKind.ContinueStatement:
                case SyntaxKind.ReturnStatement:
                case SyntaxKind.WithStatement:
                case SyntaxKind.SwitchStatement:
                case SyntaxKind.LabeledStatement:
                case SyntaxKind.ThrowStatement:
                case SyntaxKind.TryStatement:
                case SyntaxKind.ImportDeclaration:
                    return true;
            }
        }
        return false;
    }
    export function isTypeNodeNode(node: Node): node is TypeNode {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.FunctionType:
                case SyntaxKind.ConstructorType:
                case SyntaxKind.TypeReference:
                case SyntaxKind.TypePredicate:
                case SyntaxKind.TypeQuery:
                case SyntaxKind.TypeLiteral:
                case SyntaxKind.JSDocRecordType:
                case SyntaxKind.ArrayType:
                case SyntaxKind.TupleType:
                case SyntaxKind.UnionType:
                case SyntaxKind.IntersectionType:
                case SyntaxKind.ParenthesizedType:
                case SyntaxKind.StringLiteral:
                case SyntaxKind.ExpressionWithTypeArguments:
                case SyntaxKind.JSDocAllType:
                case SyntaxKind.JSDocUnknownType:
                case SyntaxKind.JSDocArrayType:
                case SyntaxKind.JSDocUnionType:
                case SyntaxKind.JSDocTupleType:
                case SyntaxKind.JSDocNonNullableType:
                case SyntaxKind.JSDocNullableType:
                case SyntaxKind.JSDocTypeReference:
                case SyntaxKind.JSDocOptionalType:
                case SyntaxKind.JSDocFunctionType:
                case SyntaxKind.JSDocVariadicType:
                case SyntaxKind.JSDocConstructorType:
                case SyntaxKind.JSDocThisType:
                    return true;
            }
        }
        return false;
    }
    export function isTypeElement(node: Node): node is TypeElement {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.CallSignature:
                case SyntaxKind.ConstructSignature:
                case SyntaxKind.PropertySignature:
                case SyntaxKind.JSDocRecordMember:
                case SyntaxKind.MethodSignature:
                case SyntaxKind.IndexSignature:
                case SyntaxKind.MissingDeclaration:
                    return true;
            }
        }
        return false;
    }
    export function isBindingPatternOrIdentifier(node: Node): node is BindingPattern | Identifier {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.ObjectBindingPattern:
                case SyntaxKind.ArrayBindingPattern:
                case SyntaxKind.Identifier:
                    return true;
            }
        }
        return false;
    }
    export function isClassElement(node: Node): node is ClassElement {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.Constructor:
                case SyntaxKind.SemicolonClassElement:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                case SyntaxKind.IndexSignature:
                case SyntaxKind.MissingDeclaration:
                    return true;
            }
        }
        return false;
    }
    export function isObjectLiteralElement(node: Node): node is ObjectLiteralElement {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.PropertyAssignment:
                case SyntaxKind.ShorthandPropertyAssignment:
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                case SyntaxKind.MissingDeclaration:
                    return true;
            }
        }
        return false;
    }
    export function isUnaryExpression(node: Node): node is UnaryExpression {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NullKeyword:
                case SyntaxKind.ThisKeyword:
                case SyntaxKind.SuperKeyword:
                case SyntaxKind.Identifier:
                case SyntaxKind.NumericLiteral:
                case SyntaxKind.RegularExpressionLiteral:
                case SyntaxKind.NoSubstitutionTemplateLiteral:
                case SyntaxKind.TemplateHead:
                case SyntaxKind.TemplateMiddle:
                case SyntaxKind.TemplateTail:
                case SyntaxKind.StringLiteral:
                case SyntaxKind.RawExpression:
                case SyntaxKind.ObjectLiteralExpression:
                case SyntaxKind.ArrayLiteralExpression:
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.TemplateExpression:
                case SyntaxKind.ParenthesizedExpression:
                case SyntaxKind.NewExpression:
                case SyntaxKind.JsxElement:
                case SyntaxKind.JsxSelfClosingElement:
                case SyntaxKind.ClassExpression:
                case SyntaxKind.PropertyAccessExpression:
                case SyntaxKind.ElementAccessExpression:
                case SyntaxKind.TaggedTemplateExpression:
                case SyntaxKind.CallExpression:
                case SyntaxKind.PrefixUnaryExpression:
                case SyntaxKind.PostfixUnaryExpression:
                case SyntaxKind.DeleteExpression:
                case SyntaxKind.TypeOfExpression:
                case SyntaxKind.VoidExpression:
                case SyntaxKind.AwaitExpression:
                case SyntaxKind.TypeAssertionExpression:
                    return true;
            }
        }
        return false;
    }
    export function isLiteralExpression(node: Node): node is LiteralExpression {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.NumericLiteral:
                case SyntaxKind.RegularExpressionLiteral:
                case SyntaxKind.NoSubstitutionTemplateLiteral:
                case SyntaxKind.TemplateHead:
                case SyntaxKind.TemplateMiddle:
                case SyntaxKind.TemplateTail:
                case SyntaxKind.StringLiteral:
                case SyntaxKind.RawExpression:
                    return true;
            }
        }
        return false;
    }
    export function isConciseBody(node: Node): node is ConciseBody {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NullKeyword:
                case SyntaxKind.ThisKeyword:
                case SyntaxKind.SuperKeyword:
                case SyntaxKind.Identifier:
                case SyntaxKind.NumericLiteral:
                case SyntaxKind.RegularExpressionLiteral:
                case SyntaxKind.NoSubstitutionTemplateLiteral:
                case SyntaxKind.TemplateHead:
                case SyntaxKind.TemplateMiddle:
                case SyntaxKind.TemplateTail:
                case SyntaxKind.StringLiteral:
                case SyntaxKind.RawExpression:
                case SyntaxKind.ObjectLiteralExpression:
                case SyntaxKind.ArrayLiteralExpression:
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.TemplateExpression:
                case SyntaxKind.ParenthesizedExpression:
                case SyntaxKind.NewExpression:
                case SyntaxKind.JsxElement:
                case SyntaxKind.JsxSelfClosingElement:
                case SyntaxKind.ClassExpression:
                case SyntaxKind.PropertyAccessExpression:
                case SyntaxKind.ElementAccessExpression:
                case SyntaxKind.TaggedTemplateExpression:
                case SyntaxKind.CallExpression:
                case SyntaxKind.PrefixUnaryExpression:
                case SyntaxKind.PostfixUnaryExpression:
                case SyntaxKind.DeleteExpression:
                case SyntaxKind.TypeOfExpression:
                case SyntaxKind.VoidExpression:
                case SyntaxKind.AwaitExpression:
                case SyntaxKind.TypeAssertionExpression:
                case SyntaxKind.OmittedExpression:
                case SyntaxKind.YieldExpression:
                case SyntaxKind.BinaryExpression:
                case SyntaxKind.ConditionalExpression:
                case SyntaxKind.ArrowFunction:
                case SyntaxKind.SpreadElementExpression:
                case SyntaxKind.AsExpression:
                case SyntaxKind.JsxOpeningElement:
                case SyntaxKind.JsxExpression:
                case SyntaxKind.Block:
                    return true;
            }
        }
        return false;
    }
    export function isLiteralExpressionOrTemplateExpression(node: Node): node is LiteralExpression | TemplateExpression {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.NumericLiteral:
                case SyntaxKind.RegularExpressionLiteral:
                case SyntaxKind.NoSubstitutionTemplateLiteral:
                case SyntaxKind.TemplateHead:
                case SyntaxKind.TemplateMiddle:
                case SyntaxKind.TemplateTail:
                case SyntaxKind.StringLiteral:
                case SyntaxKind.RawExpression:
                case SyntaxKind.TemplateExpression:
                    return true;
            }
        }
        return false;
    }
    export function isJsxAttributeOrJsxSpreadAttribute(node: Node): node is JsxAttribute | JsxSpreadAttribute {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.JsxAttribute:
                case SyntaxKind.JsxSpreadAttribute:
                    return true;
            }
        }
        return false;
    }
    export function isJsxChild(node: Node): node is JsxChild {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.JsxElement:
                case SyntaxKind.JsxExpression:
                case SyntaxKind.JsxSelfClosingElement:
                case SyntaxKind.JsxText:
                    return true;
            }
        }
        return false;
    }
    export function isExpressionOrVariableDeclarationList(node: Node): node is Expression | VariableDeclarationList {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NullKeyword:
                case SyntaxKind.ThisKeyword:
                case SyntaxKind.SuperKeyword:
                case SyntaxKind.Identifier:
                case SyntaxKind.NumericLiteral:
                case SyntaxKind.RegularExpressionLiteral:
                case SyntaxKind.NoSubstitutionTemplateLiteral:
                case SyntaxKind.TemplateHead:
                case SyntaxKind.TemplateMiddle:
                case SyntaxKind.TemplateTail:
                case SyntaxKind.StringLiteral:
                case SyntaxKind.RawExpression:
                case SyntaxKind.ObjectLiteralExpression:
                case SyntaxKind.ArrayLiteralExpression:
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.TemplateExpression:
                case SyntaxKind.ParenthesizedExpression:
                case SyntaxKind.NewExpression:
                case SyntaxKind.JsxElement:
                case SyntaxKind.JsxSelfClosingElement:
                case SyntaxKind.ClassExpression:
                case SyntaxKind.PropertyAccessExpression:
                case SyntaxKind.ElementAccessExpression:
                case SyntaxKind.TaggedTemplateExpression:
                case SyntaxKind.CallExpression:
                case SyntaxKind.PrefixUnaryExpression:
                case SyntaxKind.PostfixUnaryExpression:
                case SyntaxKind.DeleteExpression:
                case SyntaxKind.TypeOfExpression:
                case SyntaxKind.VoidExpression:
                case SyntaxKind.AwaitExpression:
                case SyntaxKind.TypeAssertionExpression:
                case SyntaxKind.OmittedExpression:
                case SyntaxKind.YieldExpression:
                case SyntaxKind.BinaryExpression:
                case SyntaxKind.ConditionalExpression:
                case SyntaxKind.ArrowFunction:
                case SyntaxKind.SpreadElementExpression:
                case SyntaxKind.AsExpression:
                case SyntaxKind.JsxOpeningElement:
                case SyntaxKind.JsxExpression:
                case SyntaxKind.VariableDeclarationList:
                    return true;
            }
        }
        return false;
    }
    export function isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.CaseClause:
                case SyntaxKind.DefaultClause:
                    return true;
            }
        }
        return false;
    }
    export function isModuleBody(node: Node): node is ModuleBody {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.ModuleBlock:
                case SyntaxKind.ModuleDeclaration:
                    return true;
            }
        }
        return false;
    }
    export function isIdentifierOrLiteralExpression(node: Node): node is Identifier | LiteralExpression {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.Identifier:
                case SyntaxKind.NumericLiteral:
                case SyntaxKind.RegularExpressionLiteral:
                case SyntaxKind.NoSubstitutionTemplateLiteral:
                case SyntaxKind.TemplateHead:
                case SyntaxKind.TemplateMiddle:
                case SyntaxKind.TemplateTail:
                case SyntaxKind.StringLiteral:
                case SyntaxKind.RawExpression:
                    return true;
            }
        }
        return false;
    }
    export function isEntityNameOrExternalModuleReference(node: Node): node is EntityName | ExternalModuleReference {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.Identifier:
                case SyntaxKind.QualifiedName:
                case SyntaxKind.ExternalModuleReference:
                    return true;
            }
        }
        return false;
    }
    export function isNamedImportsOrNamespaceImport(node: Node): node is NamedImports | NamespaceImport {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.NamedImports:
                case SyntaxKind.NamespaceImport:
                    return true;
            }
        }
        return false;
    }
    export function isJSDocType(node: Node): node is JSDocType {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.JSDocAllType:
                case SyntaxKind.JSDocUnknownType:
                case SyntaxKind.JSDocArrayType:
                case SyntaxKind.JSDocUnionType:
                case SyntaxKind.JSDocTupleType:
                case SyntaxKind.JSDocNonNullableType:
                case SyntaxKind.JSDocNullableType:
                case SyntaxKind.JSDocRecordType:
                case SyntaxKind.JSDocTypeReference:
                case SyntaxKind.JSDocOptionalType:
                case SyntaxKind.JSDocFunctionType:
                case SyntaxKind.JSDocVariadicType:
                case SyntaxKind.JSDocConstructorType:
                case SyntaxKind.JSDocThisType:
                    return true;
            }
        }
        return false;
    }
    export function cloneNode<TNode extends Node>(node: TNode, location?: TextRange, flags?: NodeFlags): TNode;
    export function cloneNode(node: Node, location?: TextRange, flags: NodeFlags = node.flags): Node {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.NumericLiteral:
                    return createNumericLiteral((<LiteralExpression>node).text, location, flags);
                case SyntaxKind.StringLiteral:
                    return createStringLiteral((<StringLiteral>node).text, location, flags);
                case SyntaxKind.RegularExpressionLiteral:
                    return createRegularExpressionLiteral((<LiteralExpression>node).text, location, flags);
                case SyntaxKind.NoSubstitutionTemplateLiteral:
                    return createNoSubstitutionTemplateLiteral((<LiteralExpression>node).text, location, flags);
                case SyntaxKind.TemplateHead:
                    return createTemplateHead((<LiteralExpression>node).text, location, flags);
                case SyntaxKind.TemplateMiddle:
                    return createTemplateMiddle((<LiteralExpression>node).text, location, flags);
                case SyntaxKind.TemplateTail:
                    return createTemplateTail((<LiteralExpression>node).text, location, flags);
                case SyntaxKind.Identifier:
                    return createIdentifier((<Identifier>node).text, (<Identifier>node).originalKeywordKind, location, flags);
                case SyntaxKind.FalseKeyword:
                    return createFalseKeyword(location, flags);
                case SyntaxKind.NullKeyword:
                    return createNullKeyword(location, flags);
                case SyntaxKind.SuperKeyword:
                    return createSuperKeyword(location, flags);
                case SyntaxKind.ThisKeyword:
                    return createThisKeyword(location, flags);
                case SyntaxKind.TrueKeyword:
                    return createTrueKeyword(location, flags);
                case SyntaxKind.QualifiedName:
                    return createQualifiedName((<QualifiedName>node).left, (<QualifiedName>node).right, location, flags);
                case SyntaxKind.ComputedPropertyName:
                    return createComputedPropertyName((<ComputedPropertyName>node).expression, location, flags);
                case SyntaxKind.TypeParameter:
                    return createTypeParameter((<TypeParameterDeclaration>node).name, (<TypeParameterDeclaration>node).constraint, (<TypeParameterDeclaration>node).expression, location, flags);
                case SyntaxKind.Parameter:
                    return createParameter((<ParameterDeclaration>node).decorators, (<ParameterDeclaration>node).modifiers, (<ParameterDeclaration>node).dotDotDotToken, (<ParameterDeclaration>node).name, (<ParameterDeclaration>node).questionToken, (<ParameterDeclaration>node).type, (<ParameterDeclaration>node).initializer, location, flags);
                case SyntaxKind.Decorator:
                    return createDecorator((<Decorator>node).expression, location, flags);
                case SyntaxKind.PropertySignature:
                    return createPropertySignature((<PropertySignature>node).decorators, (<PropertySignature>node).modifiers, (<PropertySignature>node).name, (<PropertySignature>node).questionToken, (<PropertySignature>node).type, location, flags);
                case SyntaxKind.PropertyDeclaration:
                    return createPropertyDeclaration((<PropertyDeclaration>node).decorators, (<PropertyDeclaration>node).modifiers, (<PropertyDeclaration>node).name, (<PropertyDeclaration>node).type, (<PropertyDeclaration>node).initializer, location, flags);
                case SyntaxKind.MethodSignature:
                    return createMethodSignature((<MethodSignature>node).decorators, (<MethodSignature>node).modifiers, (<MethodSignature>node).name, (<MethodSignature>node).questionToken, (<MethodSignature>node).typeParameters, (<MethodSignature>node).parameters, (<MethodSignature>node).type, location, flags);
                case SyntaxKind.MethodDeclaration:
                    return createMethodDeclaration((<MethodDeclaration>node).decorators, (<MethodDeclaration>node).modifiers, (<MethodDeclaration>node).asteriskToken, (<MethodDeclaration>node).name, (<MethodDeclaration>node).typeParameters, (<MethodDeclaration>node).parameters, (<MethodDeclaration>node).type, (<MethodDeclaration>node).body, location, flags);
                case SyntaxKind.Constructor:
                    return createConstructor((<ConstructorDeclaration>node).decorators, (<ConstructorDeclaration>node).modifiers, (<ConstructorDeclaration>node).parameters, (<ConstructorDeclaration>node).type, (<ConstructorDeclaration>node).body, location, flags);
                case SyntaxKind.GetAccessor:
                    return createGetAccessor((<GetAccessorDeclaration>node).decorators, (<GetAccessorDeclaration>node).modifiers, (<GetAccessorDeclaration>node).name, (<GetAccessorDeclaration>node).parameters, (<GetAccessorDeclaration>node).type, (<GetAccessorDeclaration>node).body, location, flags);
                case SyntaxKind.SetAccessor:
                    return createSetAccessor((<SetAccessorDeclaration>node).decorators, (<SetAccessorDeclaration>node).modifiers, (<SetAccessorDeclaration>node).name, (<SetAccessorDeclaration>node).parameters, (<SetAccessorDeclaration>node).type, (<SetAccessorDeclaration>node).body, location, flags);
                case SyntaxKind.CallSignature:
                    return createCallSignature((<CallSignatureDeclaration>node).typeParameters, (<CallSignatureDeclaration>node).parameters, (<CallSignatureDeclaration>node).type, (<CallSignatureDeclaration>node).questionToken, location, flags);
                case SyntaxKind.ConstructSignature:
                    return createConstructSignature((<ConstructSignatureDeclaration>node).typeParameters, (<ConstructSignatureDeclaration>node).parameters, (<ConstructSignatureDeclaration>node).type, (<ConstructSignatureDeclaration>node).questionToken, location, flags);
                case SyntaxKind.IndexSignature:
                    return createIndexSignature((<IndexSignatureDeclaration>node).decorators, (<IndexSignatureDeclaration>node).modifiers, (<IndexSignatureDeclaration>node).parameters, (<IndexSignatureDeclaration>node).type, (<IndexSignatureDeclaration>node).questionToken, location, flags);
                case SyntaxKind.TypePredicate:
                    return createTypePredicate((<TypePredicateNode>node).parameterName, (<TypePredicateNode>node).type, location, flags);
                case SyntaxKind.TypeReference:
                    return createTypeReference((<TypeReferenceNode>node).typeName, (<TypeReferenceNode>node).typeArguments, location, flags);
                case SyntaxKind.FunctionType:
                    return createFunctionType((<FunctionTypeNode>node).typeParameters, (<FunctionTypeNode>node).parameters, (<FunctionTypeNode>node).type, location, flags);
                case SyntaxKind.ConstructorType:
                    return createConstructorType((<ConstructorTypeNode>node).typeParameters, (<ConstructorTypeNode>node).parameters, (<ConstructorTypeNode>node).type, location, flags);
                case SyntaxKind.TypeQuery:
                    return createTypeQuery((<TypeQueryNode>node).exprName, location, flags);
                case SyntaxKind.TypeLiteral:
                    return createTypeLiteral((<TypeLiteralNode>node).members, location, flags);
                case SyntaxKind.ArrayType:
                    return createArrayType((<ArrayTypeNode>node).elementType, location, flags);
                case SyntaxKind.TupleType:
                    return createTupleType((<TupleTypeNode>node).elementTypes, location, flags);
                case SyntaxKind.UnionType:
                    return createUnionType((<UnionTypeNode>node).types, location, flags);
                case SyntaxKind.IntersectionType:
                    return createIntersectionType((<IntersectionTypeNode>node).types, location, flags);
                case SyntaxKind.ParenthesizedType:
                    return createParenthesizedType((<ParenthesizedTypeNode>node).type, location, flags);
                case SyntaxKind.ObjectBindingPattern:
                    return createObjectBindingPattern((<ObjectBindingPattern>node).elements, location, flags);
                case SyntaxKind.ArrayBindingPattern:
                    return createArrayBindingPattern((<ArrayBindingPattern>node).elements, location, flags);
                case SyntaxKind.BindingElement:
                    return createBindingElement((<BindingElement>node).propertyName, (<BindingElement>node).dotDotDotToken, (<BindingElement>node).name, (<BindingElement>node).initializer, location, flags);
                case SyntaxKind.ArrayLiteralExpression:
                    return createArrayLiteralExpression((<ArrayLiteralExpression>node).elements, location, flags);
                case SyntaxKind.ObjectLiteralExpression:
                    return createObjectLiteralExpression((<ObjectLiteralExpression>node).properties, location, flags);
                case SyntaxKind.PropertyAccessExpression:
                    return createPropertyAccessExpression((<PropertyAccessExpression>node).expression, (<PropertyAccessExpression>node).dotToken, (<PropertyAccessExpression>node).name, location, flags);
                case SyntaxKind.ElementAccessExpression:
                    return createElementAccessExpression((<ElementAccessExpression>node).expression, (<ElementAccessExpression>node).argumentExpression, location, flags);
                case SyntaxKind.CallExpression:
                    return createCallExpression((<CallExpression>node).expression, (<CallExpression>node).typeArguments, (<CallExpression>node).arguments, location, flags);
                case SyntaxKind.NewExpression:
                    return createNewExpression((<NewExpression>node).expression, (<NewExpression>node).typeArguments, (<NewExpression>node).arguments, location, flags);
                case SyntaxKind.TaggedTemplateExpression:
                    return createTaggedTemplateExpression((<TaggedTemplateExpression>node).tag, (<TaggedTemplateExpression>node).template, location, flags);
                case SyntaxKind.TypeAssertionExpression:
                    return createTypeAssertionExpression((<TypeAssertion>node).type, (<TypeAssertion>node).expression, location, flags);
                case SyntaxKind.ParenthesizedExpression:
                    return createParenthesizedExpression((<ParenthesizedExpression>node).expression, location, flags);
                case SyntaxKind.FunctionExpression:
                    return createFunctionExpression((<FunctionExpression>node).decorators, (<FunctionExpression>node).modifiers, (<FunctionExpression>node).asteriskToken, (<FunctionExpression>node).name, (<FunctionExpression>node).typeParameters, (<FunctionExpression>node).parameters, (<FunctionExpression>node).type, (<FunctionExpression>node).body, location, flags);
                case SyntaxKind.ArrowFunction:
                    return createArrowFunction((<ArrowFunction>node).decorators, (<ArrowFunction>node).modifiers, (<ArrowFunction>node).typeParameters, (<ArrowFunction>node).parameters, (<ArrowFunction>node).type, (<ArrowFunction>node).equalsGreaterThanToken, (<ArrowFunction>node).body, location, flags);
                case SyntaxKind.DeleteExpression:
                    return createDeleteExpression((<DeleteExpression>node).expression, location, flags);
                case SyntaxKind.TypeOfExpression:
                    return createTypeOfExpression((<TypeOfExpression>node).expression, location, flags);
                case SyntaxKind.VoidExpression:
                    return createVoidExpression((<VoidExpression>node).expression, location, flags);
                case SyntaxKind.AwaitExpression:
                    return createAwaitExpression((<AwaitExpression>node).expression, location, flags);
                case SyntaxKind.PrefixUnaryExpression:
                    return createPrefixUnaryExpression((<PrefixUnaryExpression>node).operator, (<PrefixUnaryExpression>node).operand, location, flags);
                case SyntaxKind.PostfixUnaryExpression:
                    return createPostfixUnaryExpression((<PostfixUnaryExpression>node).operand, (<PostfixUnaryExpression>node).operator, location, flags);
                case SyntaxKind.BinaryExpression:
                    return createBinaryExpression((<BinaryExpression>node).left, (<BinaryExpression>node).operatorToken, (<BinaryExpression>node).right, location, flags);
                case SyntaxKind.ConditionalExpression:
                    return createConditionalExpression((<ConditionalExpression>node).condition, (<ConditionalExpression>node).questionToken, (<ConditionalExpression>node).whenTrue, (<ConditionalExpression>node).colonToken, (<ConditionalExpression>node).whenFalse, location, flags);
                case SyntaxKind.TemplateExpression:
                    return createTemplateExpression((<TemplateExpression>node).head, (<TemplateExpression>node).templateSpans, location, flags);
                case SyntaxKind.YieldExpression:
                    return createYieldExpression((<YieldExpression>node).asteriskToken, (<YieldExpression>node).expression, location, flags);
                case SyntaxKind.SpreadElementExpression:
                    return createSpreadElementExpression((<SpreadElementExpression>node).expression, location, flags);
                case SyntaxKind.ClassExpression:
                    return createClassExpression((<ClassExpression>node).decorators, (<ClassExpression>node).modifiers, (<ClassExpression>node).name, (<ClassExpression>node).typeParameters, (<ClassExpression>node).heritageClauses, (<ClassExpression>node).members, location, flags);
                case SyntaxKind.OmittedExpression:
                    return createOmittedExpression(location, flags);
                case SyntaxKind.ExpressionWithTypeArguments:
                    return createExpressionWithTypeArguments((<ExpressionWithTypeArguments>node).expression, (<ExpressionWithTypeArguments>node).typeArguments, location, flags);
                case SyntaxKind.AsExpression:
                    return createAsExpression((<AsExpression>node).expression, (<AsExpression>node).type, location, flags);
                case SyntaxKind.TemplateSpan:
                    return createTemplateSpan((<TemplateSpan>node).expression, (<TemplateSpan>node).literal, location, flags);
                case SyntaxKind.SemicolonClassElement:
                    return createSemicolonClassElement(location, flags);
                case SyntaxKind.Block:
                    return createBlock((<Block>node).statements, location, flags);
                case SyntaxKind.VariableStatement:
                    return createVariableStatement((<VariableStatement>node).decorators, (<VariableStatement>node).modifiers, (<VariableStatement>node).declarationList, location, flags);
                case SyntaxKind.EmptyStatement:
                    return createEmptyStatement(location, flags);
                case SyntaxKind.ExpressionStatement:
                    return createExpressionStatement((<ExpressionStatement>node).expression, location, flags);
                case SyntaxKind.IfStatement:
                    return createIfStatement((<IfStatement>node).expression, (<IfStatement>node).thenStatement, (<IfStatement>node).elseStatement, location, flags);
                case SyntaxKind.DoStatement:
                    return createDoStatement((<DoStatement>node).statement, (<DoStatement>node).expression, location, flags);
                case SyntaxKind.WhileStatement:
                    return createWhileStatement((<WhileStatement>node).expression, (<WhileStatement>node).statement, location, flags);
                case SyntaxKind.ForStatement:
                    return createForStatement((<ForStatement>node).initializer, (<ForStatement>node).condition, (<ForStatement>node).incrementor, (<ForStatement>node).statement, location, flags);
                case SyntaxKind.ForInStatement:
                    return createForInStatement((<ForInStatement>node).initializer, (<ForInStatement>node).expression, (<ForInStatement>node).statement, location, flags);
                case SyntaxKind.ForOfStatement:
                    return createForOfStatement((<ForOfStatement>node).initializer, (<ForOfStatement>node).expression, (<ForOfStatement>node).statement, location, flags);
                case SyntaxKind.ContinueStatement:
                    return createContinueStatement((<ContinueStatement>node).label, location, flags);
                case SyntaxKind.BreakStatement:
                    return createBreakStatement((<BreakStatement>node).label, location, flags);
                case SyntaxKind.ReturnStatement:
                    return createReturnStatement((<ReturnStatement>node).expression, location, flags);
                case SyntaxKind.WithStatement:
                    return createWithStatement((<WithStatement>node).expression, (<WithStatement>node).statement, location, flags);
                case SyntaxKind.SwitchStatement:
                    return createSwitchStatement((<SwitchStatement>node).expression, (<SwitchStatement>node).caseBlock, location, flags);
                case SyntaxKind.LabeledStatement:
                    return createLabeledStatement((<LabeledStatement>node).label, (<LabeledStatement>node).statement, location, flags);
                case SyntaxKind.ThrowStatement:
                    return createThrowStatement((<ThrowStatement>node).expression, location, flags);
                case SyntaxKind.TryStatement:
                    return createTryStatement((<TryStatement>node).tryBlock, (<TryStatement>node).catchClause, (<TryStatement>node).finallyBlock, location, flags);
                case SyntaxKind.DebuggerStatement:
                    return createDebuggerStatement(location, flags);
                case SyntaxKind.VariableDeclaration:
                    return createVariableDeclaration((<VariableDeclaration>node).name, (<VariableDeclaration>node).type, (<VariableDeclaration>node).initializer, location, flags);
                case SyntaxKind.VariableDeclarationList:
                    return createVariableDeclarationList((<VariableDeclarationList>node).declarations, location, flags);
                case SyntaxKind.FunctionDeclaration:
                    return createFunctionDeclaration((<FunctionDeclaration>node).decorators, (<FunctionDeclaration>node).modifiers, (<FunctionDeclaration>node).asteriskToken, (<FunctionDeclaration>node).name, (<FunctionDeclaration>node).typeParameters, (<FunctionDeclaration>node).parameters, (<FunctionDeclaration>node).type, (<FunctionDeclaration>node).body, location, flags);
                case SyntaxKind.ClassDeclaration:
                    return createClassDeclaration((<ClassDeclaration>node).decorators, (<ClassDeclaration>node).modifiers, (<ClassDeclaration>node).name, (<ClassDeclaration>node).typeParameters, (<ClassDeclaration>node).heritageClauses, (<ClassDeclaration>node).members, location, flags);
                case SyntaxKind.InterfaceDeclaration:
                    return createInterfaceDeclaration((<InterfaceDeclaration>node).decorators, (<InterfaceDeclaration>node).modifiers, (<InterfaceDeclaration>node).name, (<InterfaceDeclaration>node).typeParameters, (<InterfaceDeclaration>node).heritageClauses, (<InterfaceDeclaration>node).members, location, flags);
                case SyntaxKind.TypeAliasDeclaration:
                    return createTypeAliasDeclaration((<TypeAliasDeclaration>node).decorators, (<TypeAliasDeclaration>node).modifiers, (<TypeAliasDeclaration>node).name, (<TypeAliasDeclaration>node).typeParameters, (<TypeAliasDeclaration>node).type, location, flags);
                case SyntaxKind.EnumDeclaration:
                    return createEnumDeclaration((<EnumDeclaration>node).decorators, (<EnumDeclaration>node).modifiers, (<EnumDeclaration>node).name, (<EnumDeclaration>node).members, location, flags);
                case SyntaxKind.ModuleDeclaration:
                    return createModuleDeclaration((<ModuleDeclaration>node).decorators, (<ModuleDeclaration>node).modifiers, (<ModuleDeclaration>node).name, (<ModuleDeclaration>node).body, location, flags);
                case SyntaxKind.ModuleBlock:
                    return createModuleBlock((<ModuleBlock>node).statements, location, flags);
                case SyntaxKind.CaseBlock:
                    return createCaseBlock((<CaseBlock>node).clauses, location, flags);
                case SyntaxKind.ImportEqualsDeclaration:
                    return createImportEqualsDeclaration((<ImportEqualsDeclaration>node).decorators, (<ImportEqualsDeclaration>node).modifiers, (<ImportEqualsDeclaration>node).name, (<ImportEqualsDeclaration>node).moduleReference, location, flags);
                case SyntaxKind.ImportDeclaration:
                    return createImportDeclaration((<ImportDeclaration>node).decorators, (<ImportDeclaration>node).modifiers, (<ImportDeclaration>node).importClause, (<ImportDeclaration>node).moduleSpecifier, location, flags);
                case SyntaxKind.ImportClause:
                    return createImportClause((<ImportClause>node).name, (<ImportClause>node).namedBindings, location, flags);
                case SyntaxKind.NamespaceImport:
                    return createNamespaceImport((<NamespaceImport>node).name, location, flags);
                case SyntaxKind.NamedImports:
                    return createNamedImports((<NamedImports>node).elements, location, flags);
                case SyntaxKind.ImportSpecifier:
                    return createImportSpecifier((<ImportSpecifier>node).propertyName, (<ImportSpecifier>node).name, location, flags);
                case SyntaxKind.ExportAssignment:
                    return createExportAssignment((<ExportAssignment>node).decorators, (<ExportAssignment>node).modifiers, (<ExportAssignment>node).expression, location, flags);
                case SyntaxKind.ExportDeclaration:
                    return createExportDeclaration((<ExportDeclaration>node).decorators, (<ExportDeclaration>node).modifiers, (<ExportDeclaration>node).exportClause, (<ExportDeclaration>node).moduleSpecifier, location, flags);
                case SyntaxKind.NamedExports:
                    return createNamedExports((<NamedExports>node).elements, location, flags);
                case SyntaxKind.ExportSpecifier:
                    return createExportSpecifier((<ExportSpecifier>node).propertyName, (<ExportSpecifier>node).name, location, flags);
                case SyntaxKind.MissingDeclaration:
                    return createMissingDeclaration((<MissingDeclaration>node).decorators, (<MissingDeclaration>node).modifiers, (<MissingDeclaration>node).questionToken, location, flags);
                case SyntaxKind.ExternalModuleReference:
                    return createExternalModuleReference((<ExternalModuleReference>node).expression, location, flags);
                case SyntaxKind.JsxElement:
                    return createJsxElement((<JsxElement>node).openingElement, (<JsxElement>node).children, (<JsxElement>node).closingElement, location, flags);
                case SyntaxKind.JsxSelfClosingElement:
                    return createJsxSelfClosingElement((<JsxSelfClosingElement>node).tagName, (<JsxSelfClosingElement>node).attributes, location, flags);
                case SyntaxKind.JsxOpeningElement:
                    return createJsxOpeningElement((<JsxOpeningElement>node).tagName, (<JsxOpeningElement>node).attributes, location, flags);
                case SyntaxKind.JsxText:
                    return createJsxText(location, flags);
                case SyntaxKind.JsxClosingElement:
                    return createJsxClosingElement((<JsxClosingElement>node).tagName, location, flags);
                case SyntaxKind.JsxAttribute:
                    return createJsxAttribute((<JsxAttribute>node).name, (<JsxAttribute>node).initializer, location, flags);
                case SyntaxKind.JsxSpreadAttribute:
                    return createJsxSpreadAttribute((<JsxSpreadAttribute>node).expression, location, flags);
                case SyntaxKind.JsxExpression:
                    return createJsxExpression((<JsxExpression>node).expression, location, flags);
                case SyntaxKind.CaseClause:
                    return createCaseClause((<CaseClause>node).expression, (<CaseClause>node).statements, location, flags);
                case SyntaxKind.DefaultClause:
                    return createDefaultClause((<DefaultClause>node).statements, location, flags);
                case SyntaxKind.HeritageClause:
                    return createHeritageClause((<HeritageClause>node).token, (<HeritageClause>node).types, location, flags);
                case SyntaxKind.CatchClause:
                    return createCatchClause((<CatchClause>node).variableDeclaration, (<CatchClause>node).block, location, flags);
                case SyntaxKind.PropertyAssignment:
                    return createPropertyAssignment((<PropertyAssignment>node).name, (<PropertyAssignment>node).initializer, location, flags);
                case SyntaxKind.ShorthandPropertyAssignment:
                    return createShorthandPropertyAssignment((<ShorthandPropertyAssignment>node).name, (<ShorthandPropertyAssignment>node).equalsToken, (<ShorthandPropertyAssignment>node).objectAssignmentInitializer, location, flags);
                case SyntaxKind.EnumMember:
                    return createEnumMember((<EnumMember>node).name, (<EnumMember>node).initializer, location, flags);
                case SyntaxKind.SourceFile:
                    return createSourceFileNode((<SourceFile>node).statements, (<SourceFile>node).endOfFileToken, (<SourceFile>node).fileName, (<SourceFile>node).text, (<SourceFile>node).amdDependencies, (<SourceFile>node).moduleName, (<SourceFile>node).referencedFiles, (<SourceFile>node).languageVariant, (<SourceFile>node).renamedDependencies, (<SourceFile>node).hasNoDefaultLib, (<SourceFile>node).languageVersion, (<SourceFile>node).externalModuleIndicator, (<SourceFile>node).isDefaultLib, (<SourceFile>node).identifiers, (<SourceFile>node).parseDiagnostics, (<SourceFile>node).bindDiagnostics, (<SourceFile>node).lineMap, (<SourceFile>node).classifiableNames, (<SourceFile>node).resolvedModules, (<SourceFile>node).imports, location, flags);
                case SyntaxKind.JSDocTypeExpression:
                    return createJSDocTypeExpression((<JSDocTypeExpression>node).type, location, flags);
                case SyntaxKind.JSDocAllType:
                    return createJSDocAllType(location, flags);
                case SyntaxKind.JSDocUnknownType:
                    return createJSDocUnknownType(location, flags);
                case SyntaxKind.JSDocArrayType:
                    return createJSDocArrayType((<JSDocArrayType>node).elementType, location, flags);
                case SyntaxKind.JSDocUnionType:
                    return createJSDocUnionType((<JSDocUnionType>node).types, location, flags);
                case SyntaxKind.JSDocTupleType:
                    return createJSDocTupleType((<JSDocTupleType>node).types, location, flags);
                case SyntaxKind.JSDocNullableType:
                    return createJSDocNullableType((<JSDocNullableType>node).type, location, flags);
                case SyntaxKind.JSDocNonNullableType:
                    return createJSDocNonNullableType((<JSDocNonNullableType>node).type, location, flags);
                case SyntaxKind.JSDocRecordType:
                    return createJSDocRecordType((<JSDocRecordType>node).members, location, flags);
                case SyntaxKind.JSDocRecordMember:
                    return createJSDocRecordMember((<JSDocRecordMember>node).name, (<JSDocRecordMember>node).type, location, flags);
                case SyntaxKind.JSDocTypeReference:
                    return createJSDocTypeReference((<JSDocTypeReference>node).name, (<JSDocTypeReference>node).typeArguments, location, flags);
                case SyntaxKind.JSDocOptionalType:
                    return createJSDocOptionalType((<JSDocOptionalType>node).type, location, flags);
                case SyntaxKind.JSDocFunctionType:
                    return createJSDocFunctionType((<JSDocFunctionType>node).parameters, (<JSDocFunctionType>node).type, location, flags);
                case SyntaxKind.JSDocVariadicType:
                    return createJSDocVariadicType((<JSDocVariadicType>node).type, location, flags);
                case SyntaxKind.JSDocConstructorType:
                    return createJSDocConstructorType((<JSDocConstructorType>node).type, location, flags);
                case SyntaxKind.JSDocThisType:
                    return createJSDocThisType((<JSDocThisType>node).type, location, flags);
                case SyntaxKind.JSDocComment:
                    return createJSDocComment((<JSDocComment>node).tags, location, flags);
                case SyntaxKind.JSDocTag:
                    return createJSDocTag((<JSDocTag>node).atToken, (<JSDocTag>node).tagName, location, flags);
                case SyntaxKind.JSDocParameterTag:
                    return createJSDocParameterTag((<JSDocParameterTag>node).preParameterName, (<JSDocParameterTag>node).typeExpression, (<JSDocParameterTag>node).postParameterName, (<JSDocParameterTag>node).atToken, (<JSDocParameterTag>node).tagName, location, flags);
                case SyntaxKind.JSDocReturnTag:
                    return createJSDocReturnTag((<JSDocReturnTag>node).typeExpression, (<JSDocReturnTag>node).atToken, (<JSDocReturnTag>node).tagName, location, flags);
                case SyntaxKind.JSDocTypeTag:
                    return createJSDocTypeTag((<JSDocTypeTag>node).typeExpression, (<JSDocTypeTag>node).atToken, (<JSDocTypeTag>node).tagName, location, flags);
                case SyntaxKind.JSDocTemplateTag:
                    return createJSDocTemplateTag((<JSDocTemplateTag>node).typeParameters, (<JSDocTemplateTag>node).atToken, (<JSDocTemplateTag>node).tagName, location, flags);
                case SyntaxKind.RawExpression:
                    return createRawExpression((<RawExpression>node).text, location, flags);
                case SyntaxKind.RawStatement:
                    return createRawStatement((<RawStatement>node).text, location, flags);
            }
        }
        return node;
    }
    export function acceptTransformer(transformer: Transformer, node: Node, visitor: (node: Node, write: (node: Node) => void) => void): Node {
        if (node) {
            switch (node.kind) {
                case SyntaxKind.QualifiedName:
                    return updateQualifiedName(<QualifiedName>node, transformer.visitNode((<QualifiedName>node).left, visitor, isEntityName), transformer.visitNode((<QualifiedName>node).right, visitor, isIdentifier));
                case SyntaxKind.ComputedPropertyName:
                    return updateComputedPropertyName(<ComputedPropertyName>node, transformer.visitNode((<ComputedPropertyName>node).expression, visitor, isExpressionNode));
                case SyntaxKind.TypeParameter:
                    return updateTypeParameter(<TypeParameterDeclaration>node, transformer.visitNode((<TypeParameterDeclaration>node).name, visitor, isIdentifier), transformer.visitNode((<TypeParameterDeclaration>node).constraint, visitor, isTypeNodeNode), transformer.visitNode((<TypeParameterDeclaration>node).expression, visitor, isExpressionNode));
                case SyntaxKind.Parameter:
                    return updateParameter(<ParameterDeclaration>node, transformer.visitNodes((<ParameterDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<ParameterDeclaration>node).modifiers, visitor, isModifier), transformer.visitNode((<ParameterDeclaration>node).name, visitor, isBindingPatternOrIdentifier), (<ParameterDeclaration>node).questionToken, transformer.visitNode((<ParameterDeclaration>node).type, visitor, isTypeNodeNode), transformer.visitNode((<ParameterDeclaration>node).initializer, visitor, isExpressionNode));
                case SyntaxKind.Decorator:
                    return updateDecorator(<Decorator>node, transformer.visitNode((<Decorator>node).expression, visitor, isLeftHandSideExpression));
                case SyntaxKind.PropertySignature:
                    return updatePropertySignature(<PropertySignature>node, transformer.visitNodes((<PropertySignature>node).decorators, visitor, isDecorator), transformer.visitNodes((<PropertySignature>node).modifiers, visitor, isModifier), transformer.visitNode((<PropertySignature>node).name, visitor, isPropertyName), transformer.visitNode((<PropertySignature>node).type, visitor, isTypeNodeNode));
                case SyntaxKind.PropertyDeclaration:
                    return updatePropertyDeclaration(<PropertyDeclaration>node, transformer.visitNodes((<PropertyDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<PropertyDeclaration>node).modifiers, visitor, isModifier), transformer.visitNode((<PropertyDeclaration>node).name, visitor, isPropertyName), transformer.visitNode((<PropertyDeclaration>node).type, visitor, isTypeNodeNode), transformer.visitNode((<PropertyDeclaration>node).initializer, visitor, isExpressionNode));
                case SyntaxKind.MethodSignature:
                    return updateMethodSignature(<MethodSignature>node, transformer.visitNodes((<MethodSignature>node).decorators, visitor, isDecorator), transformer.visitNodes((<MethodSignature>node).modifiers, visitor, isModifier), transformer.visitNode((<MethodSignature>node).name, visitor, isPropertyName), transformer.visitNodes((<MethodSignature>node).typeParameters, visitor, isTypeParameter), transformer.visitNodes((<MethodSignature>node).parameters, visitor, isParameter), transformer.visitNode((<MethodSignature>node).type, visitor, isTypeNodeNode));
                case SyntaxKind.MethodDeclaration:
                    return updateMethodDeclaration(<MethodDeclaration>node, transformer.visitNodes((<MethodDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<MethodDeclaration>node).modifiers, visitor, isModifier), transformer.visitNode((<MethodDeclaration>node).name, visitor, isPropertyName), transformer.visitNodes((<MethodDeclaration>node).typeParameters, visitor, isTypeParameter), transformer.visitNodes((<MethodDeclaration>node).parameters, visitor, isParameter), transformer.visitNode((<MethodDeclaration>node).type, visitor, isTypeNodeNode), transformer.visitFunctionBody((<MethodDeclaration>node).body, visitor));
                case SyntaxKind.Constructor:
                    return updateConstructor(<ConstructorDeclaration>node, transformer.visitNodes((<ConstructorDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<ConstructorDeclaration>node).modifiers, visitor, isModifier), transformer.visitNodes((<ConstructorDeclaration>node).parameters, visitor, isParameter), transformer.visitNode((<ConstructorDeclaration>node).type, visitor, isTypeNodeNode), transformer.visitFunctionBody((<ConstructorDeclaration>node).body, visitor));
                case SyntaxKind.GetAccessor:
                    return updateGetAccessor(<GetAccessorDeclaration>node, transformer.visitNodes((<GetAccessorDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<GetAccessorDeclaration>node).modifiers, visitor, isModifier), transformer.visitNode((<GetAccessorDeclaration>node).name, visitor, isPropertyName), transformer.visitNodes((<GetAccessorDeclaration>node).parameters, visitor, isParameter), transformer.visitNode((<GetAccessorDeclaration>node).type, visitor, isTypeNodeNode), transformer.visitFunctionBody((<GetAccessorDeclaration>node).body, visitor));
                case SyntaxKind.SetAccessor:
                    return updateSetAccessor(<SetAccessorDeclaration>node, transformer.visitNodes((<SetAccessorDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<SetAccessorDeclaration>node).modifiers, visitor, isModifier), transformer.visitNode((<SetAccessorDeclaration>node).name, visitor, isPropertyName), transformer.visitNodes((<SetAccessorDeclaration>node).parameters, visitor, isParameter), transformer.visitNode((<SetAccessorDeclaration>node).type, visitor, isTypeNodeNode), transformer.visitFunctionBody((<SetAccessorDeclaration>node).body, visitor));
                case SyntaxKind.CallSignature:
                    return updateCallSignature(<CallSignatureDeclaration>node, transformer.visitNodes((<CallSignatureDeclaration>node).typeParameters, visitor, isTypeParameter), transformer.visitNodes((<CallSignatureDeclaration>node).parameters, visitor, isParameter), transformer.visitNode((<CallSignatureDeclaration>node).type, visitor, isTypeNodeNode));
                case SyntaxKind.ConstructSignature:
                    return updateConstructSignature(<ConstructSignatureDeclaration>node, transformer.visitNodes((<ConstructSignatureDeclaration>node).typeParameters, visitor, isTypeParameter), transformer.visitNodes((<ConstructSignatureDeclaration>node).parameters, visitor, isParameter), transformer.visitNode((<ConstructSignatureDeclaration>node).type, visitor, isTypeNodeNode));
                case SyntaxKind.IndexSignature:
                    return updateIndexSignature(<IndexSignatureDeclaration>node, transformer.visitNodes((<IndexSignatureDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<IndexSignatureDeclaration>node).modifiers, visitor, isModifier), transformer.visitNodes((<IndexSignatureDeclaration>node).parameters, visitor, isParameter), transformer.visitNode((<IndexSignatureDeclaration>node).type, visitor, isTypeNodeNode));
                case SyntaxKind.TypePredicate:
                    return updateTypePredicate(<TypePredicateNode>node, transformer.visitNode((<TypePredicateNode>node).parameterName, visitor, isIdentifier), transformer.visitNode((<TypePredicateNode>node).type, visitor, isTypeNodeNode));
                case SyntaxKind.TypeReference:
                    return updateTypeReference(<TypeReferenceNode>node, transformer.visitNode((<TypeReferenceNode>node).typeName, visitor, isEntityName), transformer.visitNodes((<TypeReferenceNode>node).typeArguments, visitor, isTypeNodeNode));
                case SyntaxKind.FunctionType:
                    return updateFunctionType(<FunctionTypeNode>node, transformer.visitNodes((<FunctionTypeNode>node).typeParameters, visitor, isTypeParameter), transformer.visitNodes((<FunctionTypeNode>node).parameters, visitor, isParameter), transformer.visitNode((<FunctionTypeNode>node).type, visitor, isTypeNodeNode));
                case SyntaxKind.ConstructorType:
                    return updateConstructorType(<ConstructorTypeNode>node, transformer.visitNodes((<ConstructorTypeNode>node).typeParameters, visitor, isTypeParameter), transformer.visitNodes((<ConstructorTypeNode>node).parameters, visitor, isParameter), transformer.visitNode((<ConstructorTypeNode>node).type, visitor, isTypeNodeNode));
                case SyntaxKind.TypeQuery:
                    return updateTypeQuery(<TypeQueryNode>node, transformer.visitNode((<TypeQueryNode>node).exprName, visitor, isEntityName));
                case SyntaxKind.TypeLiteral:
                    return updateTypeLiteral(<TypeLiteralNode>node, transformer.visitNodes((<TypeLiteralNode>node).members, visitor, isTypeElement));
                case SyntaxKind.ArrayType:
                    return updateArrayType(<ArrayTypeNode>node, transformer.visitNode((<ArrayTypeNode>node).elementType, visitor, isTypeNodeNode));
                case SyntaxKind.TupleType:
                    return updateTupleType(<TupleTypeNode>node, transformer.visitNodes((<TupleTypeNode>node).elementTypes, visitor, isTypeNodeNode));
                case SyntaxKind.UnionType:
                    return updateUnionType(<UnionTypeNode>node, transformer.visitNodes((<UnionTypeNode>node).types, visitor, isTypeNodeNode));
                case SyntaxKind.IntersectionType:
                    return updateIntersectionType(<IntersectionTypeNode>node, transformer.visitNodes((<IntersectionTypeNode>node).types, visitor, isTypeNodeNode));
                case SyntaxKind.ParenthesizedType:
                    return updateParenthesizedType(<ParenthesizedTypeNode>node, transformer.visitNode((<ParenthesizedTypeNode>node).type, visitor, isTypeNodeNode));
                case SyntaxKind.ObjectBindingPattern:
                    return updateObjectBindingPattern(<ObjectBindingPattern>node, transformer.visitNodes((<ObjectBindingPattern>node).elements, visitor, isBindingElement));
                case SyntaxKind.ArrayBindingPattern:
                    return updateArrayBindingPattern(<ArrayBindingPattern>node, transformer.visitNodes((<ArrayBindingPattern>node).elements, visitor, isBindingElement));
                case SyntaxKind.BindingElement:
                    return updateBindingElement(<BindingElement>node, transformer.visitNode((<BindingElement>node).propertyName, visitor, isIdentifier), transformer.visitNode((<BindingElement>node).name, visitor, isBindingPatternOrIdentifier), transformer.visitNode((<BindingElement>node).initializer, visitor, isExpressionNode));
                case SyntaxKind.ArrayLiteralExpression:
                    return updateArrayLiteralExpression(<ArrayLiteralExpression>node, transformer.visitNodes((<ArrayLiteralExpression>node).elements, visitor, isExpressionNode));
                case SyntaxKind.ObjectLiteralExpression:
                    return updateObjectLiteralExpression(<ObjectLiteralExpression>node, transformer.visitNodes((<ObjectLiteralExpression>node).properties, visitor, isObjectLiteralElement));
                case SyntaxKind.PropertyAccessExpression:
                    return updatePropertyAccessExpression(<PropertyAccessExpression>node, transformer.visitNode((<PropertyAccessExpression>node).expression, visitor, isLeftHandSideExpression), transformer.visitNode((<PropertyAccessExpression>node).name, visitor, isIdentifier));
                case SyntaxKind.ElementAccessExpression:
                    return updateElementAccessExpression(<ElementAccessExpression>node, transformer.visitNode((<ElementAccessExpression>node).expression, visitor, isLeftHandSideExpression), transformer.visitNode((<ElementAccessExpression>node).argumentExpression, visitor, isExpressionNode));
                case SyntaxKind.CallExpression:
                    return updateCallExpression(<CallExpression>node, transformer.visitNode((<CallExpression>node).expression, visitor, isLeftHandSideExpression), transformer.visitNodes((<CallExpression>node).typeArguments, visitor, isTypeNodeNode), transformer.visitNodes((<CallExpression>node).arguments, visitor, isExpressionNode));
                case SyntaxKind.NewExpression:
                    return updateNewExpression(<NewExpression>node, transformer.visitNode((<NewExpression>node).expression, visitor, isLeftHandSideExpression), transformer.visitNodes((<NewExpression>node).typeArguments, visitor, isTypeNodeNode), transformer.visitNodes((<NewExpression>node).arguments, visitor, isExpressionNode));
                case SyntaxKind.TaggedTemplateExpression:
                    return updateTaggedTemplateExpression(<TaggedTemplateExpression>node, transformer.visitNode((<TaggedTemplateExpression>node).tag, visitor, isLeftHandSideExpression), transformer.visitNode((<TaggedTemplateExpression>node).template, visitor, isLiteralExpressionOrTemplateExpression));
                case SyntaxKind.TypeAssertionExpression:
                    return updateTypeAssertionExpression(<TypeAssertion>node, transformer.visitNode((<TypeAssertion>node).type, visitor, isTypeNodeNode), transformer.visitNode((<TypeAssertion>node).expression, visitor, isUnaryExpression));
                case SyntaxKind.ParenthesizedExpression:
                    return updateParenthesizedExpression(<ParenthesizedExpression>node, transformer.visitNode((<ParenthesizedExpression>node).expression, visitor, isExpressionNode));
                case SyntaxKind.FunctionExpression:
                    return updateFunctionExpression(<FunctionExpression>node, transformer.visitNodes((<FunctionExpression>node).decorators, visitor, isDecorator), transformer.visitNodes((<FunctionExpression>node).modifiers, visitor, isModifier), transformer.visitNode((<FunctionExpression>node).name, visitor, isIdentifier), transformer.visitNodes((<FunctionExpression>node).typeParameters, visitor, isTypeParameter), transformer.visitNodes((<FunctionExpression>node).parameters, visitor, isParameter), transformer.visitNode((<FunctionExpression>node).type, visitor, isTypeNodeNode), transformer.visitFunctionBody((<FunctionExpression>node).body, visitor));
                case SyntaxKind.ArrowFunction:
                    return updateArrowFunction(<ArrowFunction>node, transformer.visitNodes((<ArrowFunction>node).decorators, visitor, isDecorator), transformer.visitNodes((<ArrowFunction>node).modifiers, visitor, isModifier), transformer.visitNodes((<ArrowFunction>node).typeParameters, visitor, isTypeParameter), transformer.visitNodes((<ArrowFunction>node).parameters, visitor, isParameter), transformer.visitNode((<ArrowFunction>node).type, visitor, isTypeNodeNode), transformer.visitConciseBody((<ArrowFunction>node).body, visitor));
                case SyntaxKind.DeleteExpression:
                    return updateDeleteExpression(<DeleteExpression>node, transformer.visitNode((<DeleteExpression>node).expression, visitor, isUnaryExpression));
                case SyntaxKind.TypeOfExpression:
                    return updateTypeOfExpression(<TypeOfExpression>node, transformer.visitNode((<TypeOfExpression>node).expression, visitor, isUnaryExpression));
                case SyntaxKind.VoidExpression:
                    return updateVoidExpression(<VoidExpression>node, transformer.visitNode((<VoidExpression>node).expression, visitor, isUnaryExpression));
                case SyntaxKind.AwaitExpression:
                    return updateAwaitExpression(<AwaitExpression>node, transformer.visitNode((<AwaitExpression>node).expression, visitor, isUnaryExpression));
                case SyntaxKind.PrefixUnaryExpression:
                    return updatePrefixUnaryExpression(<PrefixUnaryExpression>node, transformer.visitNode((<PrefixUnaryExpression>node).operand, visitor, isUnaryExpression));
                case SyntaxKind.PostfixUnaryExpression:
                    return updatePostfixUnaryExpression(<PostfixUnaryExpression>node, transformer.visitNode((<PostfixUnaryExpression>node).operand, visitor, isLeftHandSideExpression));
                case SyntaxKind.BinaryExpression:
                    return updateBinaryExpression(<BinaryExpression>node, transformer.visitNode((<BinaryExpression>node).left, visitor, isExpressionNode), transformer.visitNode((<BinaryExpression>node).right, visitor, isExpressionNode));
                case SyntaxKind.ConditionalExpression:
                    return updateConditionalExpression(<ConditionalExpression>node, transformer.visitNode((<ConditionalExpression>node).condition, visitor, isExpressionNode), transformer.visitNode((<ConditionalExpression>node).whenTrue, visitor, isExpressionNode), transformer.visitNode((<ConditionalExpression>node).whenFalse, visitor, isExpressionNode));
                case SyntaxKind.TemplateExpression:
                    return updateTemplateExpression(<TemplateExpression>node, transformer.visitNode((<TemplateExpression>node).head, visitor, isLiteralExpression), transformer.visitNodes((<TemplateExpression>node).templateSpans, visitor, isTemplateSpan));
                case SyntaxKind.YieldExpression:
                    return updateYieldExpression(<YieldExpression>node, transformer.visitNode((<YieldExpression>node).expression, visitor, isExpressionNode));
                case SyntaxKind.SpreadElementExpression:
                    return updateSpreadElementExpression(<SpreadElementExpression>node, transformer.visitNode((<SpreadElementExpression>node).expression, visitor, isExpressionNode));
                case SyntaxKind.ClassExpression:
                    return updateClassExpression(<ClassExpression>node, transformer.visitNodes((<ClassExpression>node).decorators, visitor, isDecorator), transformer.visitNodes((<ClassExpression>node).modifiers, visitor, isModifier), transformer.visitNode((<ClassExpression>node).name, visitor, isIdentifier), transformer.visitNodes((<ClassExpression>node).typeParameters, visitor, isTypeParameter), transformer.visitNodes((<ClassExpression>node).heritageClauses, visitor, isHeritageClause), transformer.visitNodes((<ClassExpression>node).members, visitor, isClassElement));
                case SyntaxKind.ExpressionWithTypeArguments:
                    return updateExpressionWithTypeArguments(<ExpressionWithTypeArguments>node, transformer.visitNode((<ExpressionWithTypeArguments>node).expression, visitor, isLeftHandSideExpression), transformer.visitNodes((<ExpressionWithTypeArguments>node).typeArguments, visitor, isTypeNodeNode));
                case SyntaxKind.AsExpression:
                    return updateAsExpression(<AsExpression>node, transformer.visitNode((<AsExpression>node).expression, visitor, isExpressionNode), transformer.visitNode((<AsExpression>node).type, visitor, isTypeNodeNode));
                case SyntaxKind.TemplateSpan:
                    return updateTemplateSpan(<TemplateSpan>node, transformer.visitNode((<TemplateSpan>node).expression, visitor, isExpressionNode), transformer.visitNode((<TemplateSpan>node).literal, visitor, isLiteralExpression));
                case SyntaxKind.Block:
                    return updateBlock(<Block>node, transformer.visitNodes((<Block>node).statements, visitor, isStatementNode));
                case SyntaxKind.VariableStatement:
                    return updateVariableStatement(<VariableStatement>node, transformer.visitNodes((<VariableStatement>node).decorators, visitor, isDecorator), transformer.visitNodes((<VariableStatement>node).modifiers, visitor, isModifier), transformer.visitNode((<VariableStatement>node).declarationList, visitor, isVariableDeclarationList));
                case SyntaxKind.ExpressionStatement:
                    return updateExpressionStatement(<ExpressionStatement>node, transformer.visitNode((<ExpressionStatement>node).expression, visitor, isExpressionNode));
                case SyntaxKind.IfStatement:
                    return updateIfStatement(<IfStatement>node, transformer.visitNode((<IfStatement>node).expression, visitor, isExpressionNode), transformer.visitStatement((<IfStatement>node).thenStatement, visitor), transformer.visitStatement((<IfStatement>node).elseStatement, visitor));
                case SyntaxKind.DoStatement:
                    return updateDoStatement(<DoStatement>node, transformer.visitStatement((<DoStatement>node).statement, visitor), transformer.visitNode((<DoStatement>node).expression, visitor, isExpressionNode));
                case SyntaxKind.WhileStatement:
                    return updateWhileStatement(<WhileStatement>node, transformer.visitNode((<WhileStatement>node).expression, visitor, isExpressionNode), transformer.visitStatement((<WhileStatement>node).statement, visitor));
                case SyntaxKind.ForStatement:
                    return updateForStatement(<ForStatement>node, transformer.visitNode((<ForStatement>node).initializer, visitor, isExpressionOrVariableDeclarationList), transformer.visitNode((<ForStatement>node).condition, visitor, isExpressionNode), transformer.visitNode((<ForStatement>node).incrementor, visitor, isExpressionNode), transformer.visitStatement((<ForStatement>node).statement, visitor));
                case SyntaxKind.ForInStatement:
                    return updateForInStatement(<ForInStatement>node, transformer.visitNode((<ForInStatement>node).initializer, visitor, isExpressionOrVariableDeclarationList), transformer.visitNode((<ForInStatement>node).expression, visitor, isExpressionNode), transformer.visitStatement((<ForInStatement>node).statement, visitor));
                case SyntaxKind.ForOfStatement:
                    return updateForOfStatement(<ForOfStatement>node, transformer.visitNode((<ForOfStatement>node).initializer, visitor, isExpressionOrVariableDeclarationList), transformer.visitNode((<ForOfStatement>node).expression, visitor, isExpressionNode), transformer.visitStatement((<ForOfStatement>node).statement, visitor));
                case SyntaxKind.ContinueStatement:
                    return updateContinueStatement(<ContinueStatement>node, transformer.visitNode((<ContinueStatement>node).label, visitor, isIdentifier));
                case SyntaxKind.BreakStatement:
                    return updateBreakStatement(<BreakStatement>node, transformer.visitNode((<BreakStatement>node).label, visitor, isIdentifier));
                case SyntaxKind.ReturnStatement:
                    return updateReturnStatement(<ReturnStatement>node, transformer.visitNode((<ReturnStatement>node).expression, visitor, isExpressionNode));
                case SyntaxKind.WithStatement:
                    return updateWithStatement(<WithStatement>node, transformer.visitNode((<WithStatement>node).expression, visitor, isExpressionNode), transformer.visitStatement((<WithStatement>node).statement, visitor));
                case SyntaxKind.SwitchStatement:
                    return updateSwitchStatement(<SwitchStatement>node, transformer.visitNode((<SwitchStatement>node).expression, visitor, isExpressionNode), transformer.visitNode((<SwitchStatement>node).caseBlock, visitor, isCaseBlock));
                case SyntaxKind.LabeledStatement:
                    return updateLabeledStatement(<LabeledStatement>node, transformer.visitNode((<LabeledStatement>node).label, visitor, isIdentifier), transformer.visitStatement((<LabeledStatement>node).statement, visitor));
                case SyntaxKind.ThrowStatement:
                    return updateThrowStatement(<ThrowStatement>node, transformer.visitNode((<ThrowStatement>node).expression, visitor, isExpressionNode));
                case SyntaxKind.TryStatement:
                    return updateTryStatement(<TryStatement>node, transformer.visitNode((<TryStatement>node).tryBlock, visitor, isBlock), transformer.visitNode((<TryStatement>node).catchClause, visitor, isCatchClause), transformer.visitNode((<TryStatement>node).finallyBlock, visitor, isBlock));
                case SyntaxKind.VariableDeclaration:
                    return updateVariableDeclaration(<VariableDeclaration>node, transformer.visitNode((<VariableDeclaration>node).name, visitor, isBindingPatternOrIdentifier), transformer.visitNode((<VariableDeclaration>node).type, visitor, isTypeNodeNode), transformer.visitNode((<VariableDeclaration>node).initializer, visitor, isExpressionNode));
                case SyntaxKind.VariableDeclarationList:
                    return updateVariableDeclarationList(<VariableDeclarationList>node, transformer.visitNodes((<VariableDeclarationList>node).declarations, visitor, isVariableDeclaration));
                case SyntaxKind.FunctionDeclaration:
                    return updateFunctionDeclaration(<FunctionDeclaration>node, transformer.visitNodes((<FunctionDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<FunctionDeclaration>node).modifiers, visitor, isModifier), transformer.visitNode((<FunctionDeclaration>node).name, visitor, isIdentifier), transformer.visitNodes((<FunctionDeclaration>node).typeParameters, visitor, isTypeParameter), transformer.visitNodes((<FunctionDeclaration>node).parameters, visitor, isParameter), transformer.visitNode((<FunctionDeclaration>node).type, visitor, isTypeNodeNode), transformer.visitFunctionBody((<FunctionDeclaration>node).body, visitor));
                case SyntaxKind.ClassDeclaration:
                    return updateClassDeclaration(<ClassDeclaration>node, transformer.visitNodes((<ClassDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<ClassDeclaration>node).modifiers, visitor, isModifier), transformer.visitNode((<ClassDeclaration>node).name, visitor, isIdentifier), transformer.visitNodes((<ClassDeclaration>node).typeParameters, visitor, isTypeParameter), transformer.visitNodes((<ClassDeclaration>node).heritageClauses, visitor, isHeritageClause), transformer.visitNodes((<ClassDeclaration>node).members, visitor, isClassElement));
                case SyntaxKind.InterfaceDeclaration:
                    return updateInterfaceDeclaration(<InterfaceDeclaration>node, transformer.visitNodes((<InterfaceDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<InterfaceDeclaration>node).modifiers, visitor, isModifier), transformer.visitNode((<InterfaceDeclaration>node).name, visitor, isIdentifier), transformer.visitNodes((<InterfaceDeclaration>node).typeParameters, visitor, isTypeParameter), transformer.visitNodes((<InterfaceDeclaration>node).heritageClauses, visitor, isHeritageClause), transformer.visitNodes((<InterfaceDeclaration>node).members, visitor, isTypeElement));
                case SyntaxKind.TypeAliasDeclaration:
                    return updateTypeAliasDeclaration(<TypeAliasDeclaration>node, transformer.visitNodes((<TypeAliasDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<TypeAliasDeclaration>node).modifiers, visitor, isModifier), transformer.visitNode((<TypeAliasDeclaration>node).name, visitor, isIdentifier), transformer.visitNodes((<TypeAliasDeclaration>node).typeParameters, visitor, isTypeParameter), transformer.visitNode((<TypeAliasDeclaration>node).type, visitor, isTypeNodeNode));
                case SyntaxKind.EnumDeclaration:
                    return updateEnumDeclaration(<EnumDeclaration>node, transformer.visitNodes((<EnumDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<EnumDeclaration>node).modifiers, visitor, isModifier), transformer.visitNode((<EnumDeclaration>node).name, visitor, isIdentifier), transformer.visitNodes((<EnumDeclaration>node).members, visitor, isEnumMember));
                case SyntaxKind.ModuleDeclaration:
                    return updateModuleDeclaration(<ModuleDeclaration>node, transformer.visitNodes((<ModuleDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<ModuleDeclaration>node).modifiers, visitor, isModifier), transformer.visitNode((<ModuleDeclaration>node).name, visitor, isIdentifierOrLiteralExpression), transformer.visitModuleBody((<ModuleDeclaration>node).body, visitor));
                case SyntaxKind.ModuleBlock:
                    return updateModuleBlock(<ModuleBlock>node, transformer.visitNodes((<ModuleBlock>node).statements, visitor, isStatementNode));
                case SyntaxKind.CaseBlock:
                    return updateCaseBlock(<CaseBlock>node, transformer.visitNodes((<CaseBlock>node).clauses, visitor, isCaseOrDefaultClause));
                case SyntaxKind.ImportEqualsDeclaration:
                    return updateImportEqualsDeclaration(<ImportEqualsDeclaration>node, transformer.visitNodes((<ImportEqualsDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<ImportEqualsDeclaration>node).modifiers, visitor, isModifier), transformer.visitNode((<ImportEqualsDeclaration>node).name, visitor, isIdentifier), transformer.visitNode((<ImportEqualsDeclaration>node).moduleReference, visitor, isEntityNameOrExternalModuleReference));
                case SyntaxKind.ImportDeclaration:
                    return updateImportDeclaration(<ImportDeclaration>node, transformer.visitNodes((<ImportDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<ImportDeclaration>node).modifiers, visitor, isModifier), transformer.visitNode((<ImportDeclaration>node).importClause, visitor, isImportClause), transformer.visitNode((<ImportDeclaration>node).moduleSpecifier, visitor, isExpressionNode));
                case SyntaxKind.ImportClause:
                    return updateImportClause(<ImportClause>node, transformer.visitNode((<ImportClause>node).name, visitor, isIdentifier), transformer.visitNode((<ImportClause>node).namedBindings, visitor, isNamedImportsOrNamespaceImport));
                case SyntaxKind.NamespaceImport:
                    return updateNamespaceImport(<NamespaceImport>node, transformer.visitNode((<NamespaceImport>node).name, visitor, isIdentifier));
                case SyntaxKind.NamedImports:
                    return updateNamedImports(<NamedImports>node, transformer.visitNodes((<NamedImports>node).elements, visitor, isImportSpecifier));
                case SyntaxKind.ImportSpecifier:
                    return updateImportSpecifier(<ImportSpecifier>node, transformer.visitNode((<ImportSpecifier>node).propertyName, visitor, isIdentifier), transformer.visitNode((<ImportSpecifier>node).name, visitor, isIdentifier));
                case SyntaxKind.ExportAssignment:
                    return updateExportAssignment(<ExportAssignment>node, transformer.visitNodes((<ExportAssignment>node).decorators, visitor, isDecorator), transformer.visitNodes((<ExportAssignment>node).modifiers, visitor, isModifier), transformer.visitNode((<ExportAssignment>node).expression, visitor, isExpressionNode));
                case SyntaxKind.ExportDeclaration:
                    return updateExportDeclaration(<ExportDeclaration>node, transformer.visitNodes((<ExportDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<ExportDeclaration>node).modifiers, visitor, isModifier), transformer.visitNode((<ExportDeclaration>node).exportClause, visitor, isNamedExports), transformer.visitNode((<ExportDeclaration>node).moduleSpecifier, visitor, isExpressionNode));
                case SyntaxKind.NamedExports:
                    return updateNamedExports(<NamedExports>node, transformer.visitNodes((<NamedExports>node).elements, visitor, isExportSpecifier));
                case SyntaxKind.ExportSpecifier:
                    return updateExportSpecifier(<ExportSpecifier>node, transformer.visitNode((<ExportSpecifier>node).propertyName, visitor, isIdentifier), transformer.visitNode((<ExportSpecifier>node).name, visitor, isIdentifier));
                case SyntaxKind.MissingDeclaration:
                    return updateMissingDeclaration(<MissingDeclaration>node, transformer.visitNodes((<MissingDeclaration>node).decorators, visitor, isDecorator), transformer.visitNodes((<MissingDeclaration>node).modifiers, visitor, isModifier));
                case SyntaxKind.ExternalModuleReference:
                    return updateExternalModuleReference(<ExternalModuleReference>node, transformer.visitNode((<ExternalModuleReference>node).expression, visitor, isExpressionNode));
                case SyntaxKind.JsxElement:
                    return updateJsxElement(<JsxElement>node, transformer.visitNode((<JsxElement>node).openingElement, visitor, isJsxOpeningElement), transformer.visitNodes((<JsxElement>node).children, visitor, isJsxChild), transformer.visitNode((<JsxElement>node).closingElement, visitor, isJsxClosingElement));
                case SyntaxKind.JsxSelfClosingElement:
                    return updateJsxSelfClosingElement(<JsxSelfClosingElement>node, transformer.visitNode((<JsxSelfClosingElement>node).tagName, visitor, isEntityName), transformer.visitNodes((<JsxSelfClosingElement>node).attributes, visitor, isJsxAttributeOrJsxSpreadAttribute));
                case SyntaxKind.JsxOpeningElement:
                    return updateJsxOpeningElement(<JsxOpeningElement>node, transformer.visitNode((<JsxOpeningElement>node).tagName, visitor, isEntityName), transformer.visitNodes((<JsxOpeningElement>node).attributes, visitor, isJsxAttributeOrJsxSpreadAttribute));
                case SyntaxKind.JsxClosingElement:
                    return updateJsxClosingElement(<JsxClosingElement>node, transformer.visitNode((<JsxClosingElement>node).tagName, visitor, isEntityName));
                case SyntaxKind.JsxAttribute:
                    return updateJsxAttribute(<JsxAttribute>node, transformer.visitNode((<JsxAttribute>node).name, visitor, isIdentifier), transformer.visitNode((<JsxAttribute>node).initializer, visitor, isExpressionNode));
                case SyntaxKind.JsxSpreadAttribute:
                    return updateJsxSpreadAttribute(<JsxSpreadAttribute>node, transformer.visitNode((<JsxSpreadAttribute>node).expression, visitor, isExpressionNode));
                case SyntaxKind.JsxExpression:
                    return updateJsxExpression(<JsxExpression>node, transformer.visitNode((<JsxExpression>node).expression, visitor, isExpressionNode));
                case SyntaxKind.CaseClause:
                    return updateCaseClause(<CaseClause>node, transformer.visitNode((<CaseClause>node).expression, visitor, isExpressionNode), transformer.visitNodes((<CaseClause>node).statements, visitor, isStatementNode));
                case SyntaxKind.DefaultClause:
                    return updateDefaultClause(<DefaultClause>node, transformer.visitNodes((<DefaultClause>node).statements, visitor, isStatementNode));
                case SyntaxKind.HeritageClause:
                    return updateHeritageClause(<HeritageClause>node, transformer.visitNodes((<HeritageClause>node).types, visitor, isExpressionWithTypeArguments));
                case SyntaxKind.CatchClause:
                    return updateCatchClause(<CatchClause>node, transformer.visitNode((<CatchClause>node).variableDeclaration, visitor, isVariableDeclaration), transformer.visitNode((<CatchClause>node).block, visitor, isBlock));
                case SyntaxKind.PropertyAssignment:
                    return updatePropertyAssignment(<PropertyAssignment>node, transformer.visitNode((<PropertyAssignment>node).name, visitor, isPropertyName), transformer.visitNode((<PropertyAssignment>node).initializer, visitor, isExpressionNode));
                case SyntaxKind.ShorthandPropertyAssignment:
                    return updateShorthandPropertyAssignment(<ShorthandPropertyAssignment>node, transformer.visitNode((<ShorthandPropertyAssignment>node).name, visitor, isIdentifier), (<ShorthandPropertyAssignment>node).equalsToken, transformer.visitNode((<ShorthandPropertyAssignment>node).objectAssignmentInitializer, visitor, isExpressionNode));
                case SyntaxKind.EnumMember:
                    return updateEnumMember(<EnumMember>node, transformer.visitNode((<EnumMember>node).name, visitor, isDeclarationNameNode), transformer.visitNode((<EnumMember>node).initializer, visitor, isExpressionNode));
                case SyntaxKind.SourceFile:
                    return updateSourceFileNode(<SourceFile>node, transformer.visitNodes((<SourceFile>node).statements, visitor, isStatementNode), (<SourceFile>node).endOfFileToken);
                case SyntaxKind.JSDocTypeExpression:
                    return updateJSDocTypeExpression(<JSDocTypeExpression>node, transformer.visitNode((<JSDocTypeExpression>node).type, visitor, isJSDocType));
                case SyntaxKind.JSDocArrayType:
                    return updateJSDocArrayType(<JSDocArrayType>node, transformer.visitNode((<JSDocArrayType>node).elementType, visitor, isJSDocType));
                case SyntaxKind.JSDocUnionType:
                    return updateJSDocUnionType(<JSDocUnionType>node, transformer.visitNodes((<JSDocUnionType>node).types, visitor, isJSDocType));
                case SyntaxKind.JSDocTupleType:
                    return updateJSDocTupleType(<JSDocTupleType>node, transformer.visitNodes((<JSDocTupleType>node).types, visitor, isJSDocType));
                case SyntaxKind.JSDocNullableType:
                    return updateJSDocNullableType(<JSDocNullableType>node, transformer.visitNode((<JSDocNullableType>node).type, visitor, isJSDocType));
                case SyntaxKind.JSDocNonNullableType:
                    return updateJSDocNonNullableType(<JSDocNonNullableType>node, transformer.visitNode((<JSDocNonNullableType>node).type, visitor, isJSDocType));
                case SyntaxKind.JSDocRecordType:
                    return updateJSDocRecordType(<JSDocRecordType>node, transformer.visitNodes((<JSDocRecordType>node).members, visitor, isJSDocRecordMember));
                case SyntaxKind.JSDocRecordMember:
                    return updateJSDocRecordMember(<JSDocRecordMember>node, transformer.visitNode((<JSDocRecordMember>node).name, visitor, isIdentifierOrLiteralExpression), transformer.visitNode((<JSDocRecordMember>node).type, visitor, isJSDocType));
                case SyntaxKind.JSDocTypeReference:
                    return updateJSDocTypeReference(<JSDocTypeReference>node, transformer.visitNode((<JSDocTypeReference>node).name, visitor, isEntityName), transformer.visitNodes((<JSDocTypeReference>node).typeArguments, visitor, isJSDocType));
                case SyntaxKind.JSDocOptionalType:
                    return updateJSDocOptionalType(<JSDocOptionalType>node, transformer.visitNode((<JSDocOptionalType>node).type, visitor, isJSDocType));
                case SyntaxKind.JSDocFunctionType:
                    return updateJSDocFunctionType(<JSDocFunctionType>node, transformer.visitNodes((<JSDocFunctionType>node).parameters, visitor, isParameter), transformer.visitNode((<JSDocFunctionType>node).type, visitor, isJSDocType));
                case SyntaxKind.JSDocVariadicType:
                    return updateJSDocVariadicType(<JSDocVariadicType>node, transformer.visitNode((<JSDocVariadicType>node).type, visitor, isJSDocType));
                case SyntaxKind.JSDocConstructorType:
                    return updateJSDocConstructorType(<JSDocConstructorType>node, transformer.visitNode((<JSDocConstructorType>node).type, visitor, isJSDocType));
                case SyntaxKind.JSDocThisType:
                    return updateJSDocThisType(<JSDocThisType>node, transformer.visitNode((<JSDocThisType>node).type, visitor, isJSDocType));
                case SyntaxKind.JSDocComment:
                    return updateJSDocComment(<JSDocComment>node, transformer.visitNodes((<JSDocComment>node).tags, visitor, isJSDocTag));
                case SyntaxKind.JSDocTag:
                    return updateJSDocTag(<JSDocTag>node, transformer.visitNode((<JSDocTag>node).tagName, visitor, isIdentifier));
                case SyntaxKind.JSDocParameterTag:
                    return updateJSDocParameterTag(<JSDocParameterTag>node, transformer.visitNode((<JSDocParameterTag>node).preParameterName, visitor, isIdentifier), transformer.visitNode((<JSDocParameterTag>node).typeExpression, visitor, isJSDocTypeExpression), transformer.visitNode((<JSDocParameterTag>node).postParameterName, visitor, isIdentifier), transformer.visitNode((<JSDocParameterTag>node).tagName, visitor, isIdentifier));
                case SyntaxKind.JSDocReturnTag:
                    return updateJSDocReturnTag(<JSDocReturnTag>node, transformer.visitNode((<JSDocReturnTag>node).typeExpression, visitor, isJSDocTypeExpression), transformer.visitNode((<JSDocReturnTag>node).tagName, visitor, isIdentifier));
                case SyntaxKind.JSDocTypeTag:
                    return updateJSDocTypeTag(<JSDocTypeTag>node, transformer.visitNode((<JSDocTypeTag>node).typeExpression, visitor, isJSDocTypeExpression), transformer.visitNode((<JSDocTypeTag>node).tagName, visitor, isIdentifier));
                case SyntaxKind.JSDocTemplateTag:
                    return updateJSDocTemplateTag(<JSDocTemplateTag>node, transformer.visitNodes((<JSDocTemplateTag>node).typeParameters, visitor, isTypeParameter), transformer.visitNode((<JSDocTemplateTag>node).tagName, visitor, isIdentifier));
            }
        }
        return node;
    }
}