// <auto-generated />
/// <reference path="parser.ts" />
/// <reference path="factory.ts" />
namespace ts {
    export namespace factory {
        export function createNumericLiteral(text?: string, location?: TextRange): LiteralExpression {
            let node = createNode<LiteralExpression>(SyntaxKind.NumericLiteral, location);
            node.text = text;
            return node;
        }
        export function createStringLiteral(text?: string, location?: TextRange): StringLiteral {
            let node = createNode<StringLiteral>(SyntaxKind.StringLiteral, location);
            node.text = text;
            return node;
        }
        export function createRegularExpressionLiteral(text?: string, location?: TextRange): LiteralExpression {
            let node = createNode<LiteralExpression>(SyntaxKind.RegularExpressionLiteral, location);
            node.text = text;
            return node;
        }
        export function createNoSubstitutionTemplateLiteral(text?: string, location?: TextRange): LiteralExpression {
            let node = createNode<LiteralExpression>(SyntaxKind.NoSubstitutionTemplateLiteral, location);
            node.text = text;
            return node;
        }
        export function createTemplateHead(text?: string, location?: TextRange): LiteralExpression {
            let node = createNode<LiteralExpression>(SyntaxKind.TemplateHead, location);
            node.text = text;
            return node;
        }
        export function createTemplateMiddle(text?: string, location?: TextRange): LiteralExpression {
            let node = createNode<LiteralExpression>(SyntaxKind.TemplateMiddle, location);
            node.text = text;
            return node;
        }
        export function createTemplateTail(text?: string, location?: TextRange): LiteralExpression {
            let node = createNode<LiteralExpression>(SyntaxKind.TemplateTail, location);
            node.text = text;
            return node;
        }
        export function createIdentifier(text?: string, originalKeywordKind?: SyntaxKind, location?: TextRange): Identifier {
            let node = createNode<Identifier>(SyntaxKind.Identifier, location);
            if (arguments.length) {
                node.text = text;
                node.originalKeywordKind = originalKeywordKind;
            }
            return node;
        }
        export function createQualifiedName(left?: EntityName, right?: Identifier, location?: TextRange): QualifiedName {
            let node = createNode<QualifiedName>(SyntaxKind.QualifiedName, location);
            if (arguments.length) {
                node.left = left;
                node.right = right;
            }
            return node;
        }
        export function updateQualifiedName(node: QualifiedName, left: EntityName, right: Identifier): QualifiedName {
            if (left !== node.left || right !== node.right) {
                let newNode = createQualifiedName(left, right);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createComputedPropertyName(expression?: Expression, location?: TextRange): ComputedPropertyName {
            let node = createNode<ComputedPropertyName>(SyntaxKind.ComputedPropertyName, location);
            node.expression = expression;
            return node;
        }
        export function updateComputedPropertyName(node: ComputedPropertyName, expression: Expression): ComputedPropertyName {
            if (expression !== node.expression) {
                let newNode = createComputedPropertyName(expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createTypeParameter(name?: Identifier, constraint?: TypeNode, expression?: Expression, 
            location?: TextRange): TypeParameterDeclaration {
            let node = createNode<TypeParameterDeclaration>(SyntaxKind.TypeParameter, location);
            if (arguments.length) {
                node.name = name;
                node.constraint = constraint;
                node.expression = expression;
            }
            return node;
        }
        export function updateTypeParameter(node: TypeParameterDeclaration, name: Identifier, constraint: TypeNode, expression: Expression
            ): TypeParameterDeclaration {
            if (name !== node.name || constraint !== node.constraint || expression !== node.expression) {
                let newNode = createTypeParameter(name, constraint, expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createParameter(decorators?: Array<Decorator>, modifiers?: Array<Node>, dotDotDotToken?: Node, 
            name?: Identifier | BindingPattern, questionToken?: Node, type?: TypeNode, initializer?: Expression, 
            location?: TextRange): ParameterDeclaration {
            let node = createNode<ParameterDeclaration>(SyntaxKind.Parameter, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.dotDotDotToken = dotDotDotToken;
                node.name = name;
                node.questionToken = questionToken;
                node.type = type;
                node.initializer = initializer;
            }
            return node;
        }
        export function updateParameter(node: ParameterDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>
            , name: Identifier | BindingPattern, type: TypeNode, initializer: Expression): ParameterDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || type !== node.type || 
                initializer !== node.initializer) {
                let newNode = createParameter(decorators, modifiers, node.dotDotDotToken, name, node.questionToken, type, initializer);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createDecorator(expression?: LeftHandSideExpression, location?: TextRange): Decorator {
            let node = createNode<Decorator>(SyntaxKind.Decorator, location);
            node.expression = expression;
            return node;
        }
        export function updateDecorator(node: Decorator, expression: LeftHandSideExpression): Decorator {
            if (expression !== node.expression) {
                let newNode = createDecorator(expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createPropertySignature(decorators?: Array<Decorator>, modifiers?: Array<Node>, name?: DeclarationName, questionToken?: Node, 
            type?: TypeNode, location?: TextRange): PropertySignature {
            let node = createNode<PropertySignature>(SyntaxKind.PropertySignature, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.name = name;
                node.questionToken = questionToken;
                node.type = type;
            }
            return node;
        }
        export function updatePropertySignature(node: PropertySignature, decorators: Array<Decorator>, modifiers: Array<Node>, name: DeclarationName
            , type: TypeNode): PropertySignature {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || type !== node.type) {
                let newNode = createPropertySignature(decorators, modifiers, name, node.questionToken, type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createPropertyDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Node>, name?: DeclarationName, 
            questionToken?: Node, type?: TypeNode, initializer?: Expression, location?: TextRange): PropertyDeclaration {
            let node = createNode<PropertyDeclaration>(SyntaxKind.PropertyDeclaration, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.name = name;
                node.questionToken = questionToken;
                node.type = type;
                node.initializer = initializer;
            }
            return node;
        }
        export function updatePropertyDeclaration(node: PropertyDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>
            , name: DeclarationName, type: TypeNode, initializer: Expression): PropertyDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || type !== node.type || 
                initializer !== node.initializer) {
                let newNode = createPropertyDeclaration(decorators, modifiers, name, node.questionToken, type, initializer);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createMethodSignature(decorators?: Array<Decorator>, modifiers?: Array<Node>, name?: DeclarationName, questionToken?: Node, 
            typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, type?: TypeNode, 
            location?: TextRange): MethodSignature {
            let node = createNode<MethodSignature>(SyntaxKind.MethodSignature, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.name = name;
                node.questionToken = questionToken;
                node.typeParameters = typeParameters && createNodeArray(typeParameters)
                node.parameters = parameters && createNodeArray(parameters)
                node.type = type;
            }
            return node;
        }
        export function updateMethodSignature(node: MethodSignature, decorators: Array<Decorator>, modifiers: Array<Node>, name: DeclarationName
            , typeParameters: Array<TypeParameterDeclaration>, parameters: Array<ParameterDeclaration>, type: TypeNode): MethodSignature {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || 
                parameters !== node.parameters || type !== node.type) {
                let newNode = createMethodSignature(decorators, modifiers, name, node.questionToken, typeParameters, parameters, type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createMethodDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Node>, name?: DeclarationName, 
            typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, type?: TypeNode, body?: Block, 
            location?: TextRange): MethodDeclaration {
            let node = createNode<MethodDeclaration>(SyntaxKind.MethodDeclaration, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.name = name;
                node.typeParameters = typeParameters && createNodeArray(typeParameters)
                node.parameters = parameters && createNodeArray(parameters)
                node.type = type;
                node.body = body;
            }
            return node;
        }
        export function updateMethodDeclaration(node: MethodDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>, name: DeclarationName
            , typeParameters: Array<TypeParameterDeclaration>, parameters: Array<ParameterDeclaration>, type: TypeNode, body: Block
            ): MethodDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || 
                parameters !== node.parameters || type !== node.type || body !== node.body) {
                let newNode = createMethodDeclaration(decorators, modifiers, name, typeParameters, parameters, type, body);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createConstructor(decorators?: Array<Decorator>, modifiers?: Array<Node>, parameters?: Array<ParameterDeclaration>, 
            type?: TypeNode, body?: Block, location?: TextRange): ConstructorDeclaration {
            let node = createNode<ConstructorDeclaration>(SyntaxKind.Constructor, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.parameters = parameters && createNodeArray(parameters)
                node.type = type;
                node.body = body;
            }
            return node;
        }
        export function updateConstructor(node: ConstructorDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>
            , parameters: Array<ParameterDeclaration>, type: TypeNode, body: Block): ConstructorDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || parameters !== node.parameters || type !== node.type || 
                body !== node.body) {
                let newNode = createConstructor(decorators, modifiers, parameters, type, body);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createGetAccessor(decorators?: Array<Decorator>, modifiers?: Array<Node>, name?: DeclarationName, 
            parameters?: Array<ParameterDeclaration>, type?: TypeNode, body?: Block, location?: TextRange): GetAccessorDeclaration {
            let node = createNode<GetAccessorDeclaration>(SyntaxKind.GetAccessor, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.name = name;
                node.parameters = parameters && createNodeArray(parameters)
                node.type = type;
                node.body = body;
            }
            return node;
        }
        export function updateGetAccessor(node: GetAccessorDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>, name: DeclarationName
            , parameters: Array<ParameterDeclaration>, type: TypeNode, body: Block): GetAccessorDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || parameters !== node.parameters || 
                type !== node.type || body !== node.body) {
                let newNode = createGetAccessor(decorators, modifiers, name, parameters, type, body);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createSetAccessor(decorators?: Array<Decorator>, modifiers?: Array<Node>, name?: DeclarationName, 
            parameters?: Array<ParameterDeclaration>, type?: TypeNode, body?: Block, location?: TextRange): SetAccessorDeclaration {
            let node = createNode<SetAccessorDeclaration>(SyntaxKind.SetAccessor, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.name = name;
                node.parameters = parameters && createNodeArray(parameters)
                node.type = type;
                node.body = body;
            }
            return node;
        }
        export function updateSetAccessor(node: SetAccessorDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>, name: DeclarationName
            , parameters: Array<ParameterDeclaration>, type: TypeNode, body: Block): SetAccessorDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || parameters !== node.parameters || 
                type !== node.type || body !== node.body) {
                let newNode = createSetAccessor(decorators, modifiers, name, parameters, type, body);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createCallSignature(typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, 
            type?: TypeNode, location?: TextRange): CallSignatureDeclaration {
            let node = createNode<CallSignatureDeclaration>(SyntaxKind.CallSignature, location);
            if (arguments.length) {
                node.typeParameters = typeParameters && createNodeArray(typeParameters)
                node.parameters = parameters && createNodeArray(parameters)
                node.type = type;
            }
            return node;
        }
        export function updateCallSignature(node: CallSignatureDeclaration, typeParameters: Array<TypeParameterDeclaration>
            , parameters: Array<ParameterDeclaration>, type: TypeNode): CallSignatureDeclaration {
            if (typeParameters !== node.typeParameters || parameters !== node.parameters || type !== node.type) {
                let newNode = createCallSignature(typeParameters, parameters, type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createConstructSignature(typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, 
            type?: TypeNode, location?: TextRange): ConstructSignatureDeclaration {
            let node = createNode<ConstructSignatureDeclaration>(SyntaxKind.ConstructSignature, location);
            if (arguments.length) {
                node.typeParameters = typeParameters && createNodeArray(typeParameters)
                node.parameters = parameters && createNodeArray(parameters)
                node.type = type;
            }
            return node;
        }
        export function updateConstructSignature(node: ConstructSignatureDeclaration, typeParameters: Array<TypeParameterDeclaration>
            , parameters: Array<ParameterDeclaration>, type: TypeNode): ConstructSignatureDeclaration {
            if (typeParameters !== node.typeParameters || parameters !== node.parameters || type !== node.type) {
                let newNode = createConstructSignature(typeParameters, parameters, type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createIndexSignature(decorators?: Array<Decorator>, modifiers?: Array<Node>, parameters?: Array<ParameterDeclaration>, 
            type?: TypeNode, location?: TextRange): IndexSignatureDeclaration {
            let node = createNode<IndexSignatureDeclaration>(SyntaxKind.IndexSignature, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.parameters = parameters && createNodeArray(parameters)
                node.type = type;
            }
            return node;
        }
        export function updateIndexSignature(node: IndexSignatureDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>
            , parameters: Array<ParameterDeclaration>, type: TypeNode): IndexSignatureDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || parameters !== node.parameters || type !== node.type) {
                let newNode = createIndexSignature(decorators, modifiers, parameters, type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createTypePredicate(parameterName?: Identifier, type?: TypeNode, location?: TextRange): TypePredicateNode {
            let node = createNode<TypePredicateNode>(SyntaxKind.TypePredicate, location);
            if (arguments.length) {
                node.parameterName = parameterName;
                node.type = type;
            }
            return node;
        }
        export function updateTypePredicate(node: TypePredicateNode, parameterName: Identifier, type: TypeNode): TypePredicateNode {
            if (parameterName !== node.parameterName || type !== node.type) {
                let newNode = createTypePredicate(parameterName, type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createTypeReference(typeName?: EntityName, typeArguments?: Array<TypeNode>, location?: TextRange): TypeReferenceNode {
            let node = createNode<TypeReferenceNode>(SyntaxKind.TypeReference, location);
            if (arguments.length) {
                node.typeName = typeName;
                node.typeArguments = typeArguments && createNodeArray(typeArguments)
            }
            return node;
        }
        export function updateTypeReference(node: TypeReferenceNode, typeName: EntityName, typeArguments: Array<TypeNode>): TypeReferenceNode {
            if (typeName !== node.typeName || typeArguments !== node.typeArguments) {
                let newNode = createTypeReference(typeName, typeArguments);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createFunctionType(typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, 
            type?: TypeNode, location?: TextRange): FunctionTypeNode {
            let node = createNode<FunctionTypeNode>(SyntaxKind.FunctionType, location);
            if (arguments.length) {
                node.typeParameters = typeParameters && createNodeArray(typeParameters)
                node.parameters = parameters && createNodeArray(parameters)
                node.type = type;
            }
            return node;
        }
        export function updateFunctionType(node: FunctionTypeNode, typeParameters: Array<TypeParameterDeclaration>
            , parameters: Array<ParameterDeclaration>, type: TypeNode): FunctionTypeNode {
            if (typeParameters !== node.typeParameters || parameters !== node.parameters || type !== node.type) {
                let newNode = createFunctionType(typeParameters, parameters, type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createConstructorType(typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, 
            type?: TypeNode, location?: TextRange): ConstructorTypeNode {
            let node = createNode<ConstructorTypeNode>(SyntaxKind.ConstructorType, location);
            if (arguments.length) {
                node.typeParameters = typeParameters && createNodeArray(typeParameters)
                node.parameters = parameters && createNodeArray(parameters)
                node.type = type;
            }
            return node;
        }
        export function updateConstructorType(node: ConstructorTypeNode, typeParameters: Array<TypeParameterDeclaration>
            , parameters: Array<ParameterDeclaration>, type: TypeNode): ConstructorTypeNode {
            if (typeParameters !== node.typeParameters || parameters !== node.parameters || type !== node.type) {
                let newNode = createConstructorType(typeParameters, parameters, type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createTypeQuery(exprName?: EntityName, location?: TextRange): TypeQueryNode {
            let node = createNode<TypeQueryNode>(SyntaxKind.TypeQuery, location);
            node.exprName = exprName;
            return node;
        }
        export function updateTypeQuery(node: TypeQueryNode, exprName: EntityName): TypeQueryNode {
            if (exprName !== node.exprName) {
                let newNode = createTypeQuery(exprName);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createTypeLiteral(members?: Array<Node>, location?: TextRange): TypeLiteralNode {
            let node = createNode<TypeLiteralNode>(SyntaxKind.TypeLiteral, location);
            node.members = members && createNodeArray(members)
            return node;
        }
        export function updateTypeLiteral(node: TypeLiteralNode, members: Array<Node>): TypeLiteralNode {
            if (members !== node.members) {
                let newNode = createTypeLiteral(members);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createArrayType(elementType?: TypeNode, location?: TextRange): ArrayTypeNode {
            let node = createNode<ArrayTypeNode>(SyntaxKind.ArrayType, location);
            node.elementType = elementType;
            return node;
        }
        export function updateArrayType(node: ArrayTypeNode, elementType: TypeNode): ArrayTypeNode {
            if (elementType !== node.elementType) {
                let newNode = createArrayType(elementType);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createTupleType(elementTypes?: Array<TypeNode>, location?: TextRange): TupleTypeNode {
            let node = createNode<TupleTypeNode>(SyntaxKind.TupleType, location);
            node.elementTypes = elementTypes && createNodeArray(elementTypes)
            return node;
        }
        export function updateTupleType(node: TupleTypeNode, elementTypes: Array<TypeNode>): TupleTypeNode {
            if (elementTypes !== node.elementTypes) {
                let newNode = createTupleType(elementTypes);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createUnionType(types?: Array<TypeNode>, location?: TextRange): UnionTypeNode {
            let node = createNode<UnionTypeNode>(SyntaxKind.UnionType, location);
            node.types = types && createNodeArray(types)
            return node;
        }
        export function updateUnionType(node: UnionTypeNode, types: Array<TypeNode>): UnionTypeNode {
            if (types !== node.types) {
                let newNode = createUnionType(types);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createIntersectionType(types?: Array<TypeNode>, location?: TextRange): IntersectionTypeNode {
            let node = createNode<IntersectionTypeNode>(SyntaxKind.IntersectionType, location);
            node.types = types && createNodeArray(types)
            return node;
        }
        export function updateIntersectionType(node: IntersectionTypeNode, types: Array<TypeNode>): IntersectionTypeNode {
            if (types !== node.types) {
                let newNode = createIntersectionType(types);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createParenthesizedType(type?: TypeNode, location?: TextRange): ParenthesizedTypeNode {
            let node = createNode<ParenthesizedTypeNode>(SyntaxKind.ParenthesizedType, location);
            node.type = type;
            return node;
        }
        export function updateParenthesizedType(node: ParenthesizedTypeNode, type: TypeNode): ParenthesizedTypeNode {
            if (type !== node.type) {
                let newNode = createParenthesizedType(type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createObjectBindingPattern(elements?: Array<BindingElement>, location?: TextRange): ObjectBindingPattern {
            let node = createNode<ObjectBindingPattern>(SyntaxKind.ObjectBindingPattern, location);
            node.elements = elements && createNodeArray(elements)
            return node;
        }
        export function updateObjectBindingPattern(node: ObjectBindingPattern, elements: Array<BindingElement>): ObjectBindingPattern {
            if (elements !== node.elements) {
                let newNode = createObjectBindingPattern(elements);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createArrayBindingPattern(elements?: Array<BindingElement>, location?: TextRange): ArrayBindingPattern {
            let node = createNode<ArrayBindingPattern>(SyntaxKind.ArrayBindingPattern, location);
            node.elements = elements && createNodeArray(elements)
            return node;
        }
        export function updateArrayBindingPattern(node: ArrayBindingPattern, elements: Array<BindingElement>): ArrayBindingPattern {
            if (elements !== node.elements) {
                let newNode = createArrayBindingPattern(elements);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createBindingElement(decorators?: Array<Decorator>, modifiers?: Array<Node>, propertyName?: Identifier, 
            dotDotDotToken?: Node, name?: Identifier | BindingPattern, initializer?: Expression, location?: TextRange): BindingElement {
            let node = createNode<BindingElement>(SyntaxKind.BindingElement, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.propertyName = propertyName;
                node.dotDotDotToken = dotDotDotToken;
                node.name = name;
                node.initializer = initializer;
            }
            return node;
        }
        export function updateBindingElement(node: BindingElement, decorators: Array<Decorator>, modifiers: Array<Node>, propertyName: Identifier
            , name: Identifier | BindingPattern, initializer: Expression): BindingElement {
            if (decorators !== node.decorators || modifiers !== node.modifiers || propertyName !== node.propertyName || name !== node.name || 
                initializer !== node.initializer) {
                let newNode = createBindingElement(decorators, modifiers, propertyName, node.dotDotDotToken, name, initializer);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createArrayLiteralExpression(elements?: Array<Expression>, location?: TextRange): ArrayLiteralExpression {
            let node = createNode<ArrayLiteralExpression>(SyntaxKind.ArrayLiteralExpression, location);
            node.elements = elements && createNodeArray(elements)
            return node;
        }
        export function updateArrayLiteralExpression(node: ArrayLiteralExpression, elements: Array<Expression>): ArrayLiteralExpression {
            if (elements !== node.elements) {
                let newNode = createArrayLiteralExpression(elements);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createObjectLiteralExpression(decorators?: Array<Decorator>, modifiers?: Array<Node>, 
            properties?: Array<ObjectLiteralElement>, location?: TextRange): ObjectLiteralExpression {
            let node = createNode<ObjectLiteralExpression>(SyntaxKind.ObjectLiteralExpression, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.properties = properties && createNodeArray(properties)
            }
            return node;
        }
        export function updateObjectLiteralExpression(node: ObjectLiteralExpression, decorators: Array<Decorator>, modifiers: Array<Node>
            , properties: Array<ObjectLiteralElement>): ObjectLiteralExpression {
            if (decorators !== node.decorators || modifiers !== node.modifiers || properties !== node.properties) {
                let newNode = createObjectLiteralExpression(decorators, modifiers, properties);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createPropertyAccessExpression(expression?: LeftHandSideExpression, dotToken?: Node, name?: Identifier, 
            location?: TextRange): PropertyAccessExpression {
            let node = createNode<PropertyAccessExpression>(SyntaxKind.PropertyAccessExpression, location);
            if (arguments.length) {
                node.expression = expression;
                node.dotToken = dotToken;
                node.name = name;
            }
            return node;
        }
        export function updatePropertyAccessExpression(node: PropertyAccessExpression, expression: LeftHandSideExpression, name: Identifier
            ): PropertyAccessExpression {
            if (expression !== node.expression || name !== node.name) {
                let newNode = createPropertyAccessExpression(expression, node.dotToken, name);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createElementAccessExpression(expression?: LeftHandSideExpression, argumentExpression?: Expression, 
            location?: TextRange): ElementAccessExpression {
            let node = createNode<ElementAccessExpression>(SyntaxKind.ElementAccessExpression, location);
            if (arguments.length) {
                node.expression = expression;
                node.argumentExpression = argumentExpression;
            }
            return node;
        }
        export function updateElementAccessExpression(node: ElementAccessExpression, expression: LeftHandSideExpression
            , argumentExpression: Expression): ElementAccessExpression {
            if (expression !== node.expression || argumentExpression !== node.argumentExpression) {
                let newNode = createElementAccessExpression(expression, argumentExpression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createCallExpression(expression?: LeftHandSideExpression, typeArguments?: Array<TypeNode>, _arguments?: Array<Expression>, 
            location?: TextRange): CallExpression {
            let node = createNode<CallExpression>(SyntaxKind.CallExpression, location);
            if (arguments.length) {
                node.expression = expression;
                node.typeArguments = typeArguments && createNodeArray(typeArguments)
                node.arguments = _arguments && createNodeArray(_arguments)
            }
            return node;
        }
        export function updateCallExpression(node: CallExpression, expression: LeftHandSideExpression, typeArguments: Array<TypeNode>
            , _arguments: Array<Expression>): CallExpression {
            if (expression !== node.expression || typeArguments !== node.typeArguments || _arguments !== node.arguments) {
                let newNode = createCallExpression(expression, typeArguments, _arguments);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createNewExpression(expression?: LeftHandSideExpression, typeArguments?: Array<TypeNode>, _arguments?: Array<Expression>, 
            location?: TextRange): NewExpression {
            let node = createNode<NewExpression>(SyntaxKind.NewExpression, location);
            if (arguments.length) {
                node.expression = expression;
                node.typeArguments = typeArguments && createNodeArray(typeArguments)
                node.arguments = _arguments && createNodeArray(_arguments)
            }
            return node;
        }
        export function updateNewExpression(node: NewExpression, expression: LeftHandSideExpression, typeArguments: Array<TypeNode>
            , _arguments: Array<Expression>): NewExpression {
            if (expression !== node.expression || typeArguments !== node.typeArguments || _arguments !== node.arguments) {
                let newNode = createNewExpression(expression, typeArguments, _arguments);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createTaggedTemplateExpression(tag?: LeftHandSideExpression, template?: LiteralExpression | TemplateExpression, 
            location?: TextRange): TaggedTemplateExpression {
            let node = createNode<TaggedTemplateExpression>(SyntaxKind.TaggedTemplateExpression, location);
            if (arguments.length) {
                node.tag = tag;
                node.template = template;
            }
            return node;
        }
        export function updateTaggedTemplateExpression(node: TaggedTemplateExpression, tag: LeftHandSideExpression
            , template: LiteralExpression | TemplateExpression): TaggedTemplateExpression {
            if (tag !== node.tag || template !== node.template) {
                let newNode = createTaggedTemplateExpression(tag, template);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createTypeAssertionExpression(type?: TypeNode, expression?: UnaryExpression, location?: TextRange): TypeAssertion {
            let node = createNode<TypeAssertion>(SyntaxKind.TypeAssertionExpression, location);
            if (arguments.length) {
                node.type = type;
                node.expression = expression;
            }
            return node;
        }
        export function updateTypeAssertionExpression(node: TypeAssertion, type: TypeNode, expression: UnaryExpression): TypeAssertion {
            if (type !== node.type || expression !== node.expression) {
                let newNode = createTypeAssertionExpression(type, expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createParenthesizedExpression(expression?: Expression, location?: TextRange): ParenthesizedExpression {
            let node = createNode<ParenthesizedExpression>(SyntaxKind.ParenthesizedExpression, location);
            node.expression = expression;
            return node;
        }
        export function updateParenthesizedExpression(node: ParenthesizedExpression, expression: Expression): ParenthesizedExpression {
            if (expression !== node.expression) {
                let newNode = createParenthesizedExpression(expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createFunctionExpression(decorators?: Array<Decorator>, modifiers?: Array<Node>, asteriskToken?: Node, name?: Identifier, 
            typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, type?: TypeNode, body?: Block | Expression, 
            location?: TextRange): FunctionExpression {
            let node = createNode<FunctionExpression>(SyntaxKind.FunctionExpression, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.asteriskToken = asteriskToken;
                node.name = name;
                node.typeParameters = typeParameters && createNodeArray(typeParameters)
                node.parameters = parameters && createNodeArray(parameters)
                node.type = type;
                node.body = body;
            }
            return node;
        }
        export function updateFunctionExpression(node: FunctionExpression, decorators: Array<Decorator>, modifiers: Array<Node>, name: Identifier
            , typeParameters: Array<TypeParameterDeclaration>, parameters: Array<ParameterDeclaration>, type: TypeNode, body: Block | Expression
            ): FunctionExpression {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || 
                parameters !== node.parameters || type !== node.type || body !== node.body) {
                let newNode = createFunctionExpression(decorators, modifiers, node.asteriskToken, name, typeParameters, parameters, type, body);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createArrowFunction(decorators?: Array<Decorator>, modifiers?: Array<Node>, typeParameters?: Array<TypeParameterDeclaration>, 
            parameters?: Array<ParameterDeclaration>, type?: TypeNode, equalsGreaterThanToken?: Node, body?: Block | Expression, 
            location?: TextRange): ArrowFunction {
            let node = createNode<ArrowFunction>(SyntaxKind.ArrowFunction, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.typeParameters = typeParameters && createNodeArray(typeParameters)
                node.parameters = parameters && createNodeArray(parameters)
                node.type = type;
                node.equalsGreaterThanToken = equalsGreaterThanToken;
                node.body = body;
            }
            return node;
        }
        export function updateArrowFunction(node: ArrowFunction, decorators: Array<Decorator>, modifiers: Array<Node>
            , typeParameters: Array<TypeParameterDeclaration>, parameters: Array<ParameterDeclaration>, type: TypeNode, body: Block | Expression
            ): ArrowFunction {
            if (decorators !== node.decorators || modifiers !== node.modifiers || typeParameters !== node.typeParameters || 
                parameters !== node.parameters || type !== node.type || body !== node.body) {
                let newNode = createArrowFunction(decorators, modifiers, typeParameters, parameters, type, node.equalsGreaterThanToken, body);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createDeleteExpression(expression?: UnaryExpression, location?: TextRange): DeleteExpression {
            let node = createNode<DeleteExpression>(SyntaxKind.DeleteExpression, location);
            node.expression = expression;
            return node;
        }
        export function updateDeleteExpression(node: DeleteExpression, expression: UnaryExpression): DeleteExpression {
            if (expression !== node.expression) {
                let newNode = createDeleteExpression(expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createTypeOfExpression(expression?: UnaryExpression, location?: TextRange): TypeOfExpression {
            let node = createNode<TypeOfExpression>(SyntaxKind.TypeOfExpression, location);
            node.expression = expression;
            return node;
        }
        export function updateTypeOfExpression(node: TypeOfExpression, expression: UnaryExpression): TypeOfExpression {
            if (expression !== node.expression) {
                let newNode = createTypeOfExpression(expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createVoidExpression(expression?: UnaryExpression, location?: TextRange): VoidExpression {
            let node = createNode<VoidExpression>(SyntaxKind.VoidExpression, location);
            node.expression = expression;
            return node;
        }
        export function updateVoidExpression(node: VoidExpression, expression: UnaryExpression): VoidExpression {
            if (expression !== node.expression) {
                let newNode = createVoidExpression(expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createAwaitExpression(expression?: UnaryExpression, location?: TextRange): AwaitExpression {
            let node = createNode<AwaitExpression>(SyntaxKind.AwaitExpression, location);
            node.expression = expression;
            return node;
        }
        export function updateAwaitExpression(node: AwaitExpression, expression: UnaryExpression): AwaitExpression {
            if (expression !== node.expression) {
                let newNode = createAwaitExpression(expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createPrefixUnaryExpression(operator?: SyntaxKind, operand?: UnaryExpression, location?: TextRange): PrefixUnaryExpression {
            let node = createNode<PrefixUnaryExpression>(SyntaxKind.PrefixUnaryExpression, location);
            if (arguments.length) {
                node.operator = operator;
                node.operand = operand;
            }
            return node;
        }
        export function updatePrefixUnaryExpression(node: PrefixUnaryExpression, operand: UnaryExpression): PrefixUnaryExpression {
            if (operand !== node.operand) {
                let newNode = createPrefixUnaryExpression(node.operator, operand);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createPostfixUnaryExpression(operand?: LeftHandSideExpression, operator?: SyntaxKind, 
            location?: TextRange): PostfixUnaryExpression {
            let node = createNode<PostfixUnaryExpression>(SyntaxKind.PostfixUnaryExpression, location);
            if (arguments.length) {
                node.operand = operand;
                node.operator = operator;
            }
            return node;
        }
        export function updatePostfixUnaryExpression(node: PostfixUnaryExpression, operand: LeftHandSideExpression): PostfixUnaryExpression {
            if (operand !== node.operand) {
                let newNode = createPostfixUnaryExpression(operand, node.operator);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createBinaryExpression(left?: Expression, operatorToken?: Node, right?: Expression, location?: TextRange): BinaryExpression {
            let node = createNode<BinaryExpression>(SyntaxKind.BinaryExpression, location);
            if (arguments.length) {
                node.left = left;
                node.operatorToken = operatorToken;
                node.right = right;
            }
            return node;
        }
        export function updateBinaryExpression(node: BinaryExpression, left: Expression, right: Expression): BinaryExpression {
            if (left !== node.left || right !== node.right) {
                let newNode = createBinaryExpression(left, node.operatorToken, right);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createConditionalExpression(condition?: Expression, questionToken?: Node, whenTrue?: Expression, colonToken?: Node, 
            whenFalse?: Expression, location?: TextRange): ConditionalExpression {
            let node = createNode<ConditionalExpression>(SyntaxKind.ConditionalExpression, location);
            if (arguments.length) {
                node.condition = condition;
                node.questionToken = questionToken;
                node.whenTrue = whenTrue;
                node.colonToken = colonToken;
                node.whenFalse = whenFalse;
            }
            return node;
        }
        export function updateConditionalExpression(node: ConditionalExpression, condition: Expression, whenTrue: Expression, whenFalse: Expression
            ): ConditionalExpression {
            if (condition !== node.condition || whenTrue !== node.whenTrue || whenFalse !== node.whenFalse) {
                let newNode = createConditionalExpression(condition, node.questionToken, whenTrue, node.colonToken, whenFalse);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createTemplateExpression(head?: LiteralExpression, templateSpans?: Array<TemplateSpan>, 
            location?: TextRange): TemplateExpression {
            let node = createNode<TemplateExpression>(SyntaxKind.TemplateExpression, location);
            if (arguments.length) {
                node.head = head;
                node.templateSpans = templateSpans && createNodeArray(templateSpans)
            }
            return node;
        }
        export function updateTemplateExpression(node: TemplateExpression, head: LiteralExpression, templateSpans: Array<TemplateSpan>
            ): TemplateExpression {
            if (head !== node.head || templateSpans !== node.templateSpans) {
                let newNode = createTemplateExpression(head, templateSpans);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createYieldExpression(asteriskToken?: Node, expression?: Expression, location?: TextRange): YieldExpression {
            let node = createNode<YieldExpression>(SyntaxKind.YieldExpression, location);
            if (arguments.length) {
                node.asteriskToken = asteriskToken;
                node.expression = expression;
            }
            return node;
        }
        export function updateYieldExpression(node: YieldExpression, expression: Expression): YieldExpression {
            if (expression !== node.expression) {
                let newNode = createYieldExpression(node.asteriskToken, expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createSpreadElementExpression(expression?: Expression, location?: TextRange): SpreadElementExpression {
            let node = createNode<SpreadElementExpression>(SyntaxKind.SpreadElementExpression, location);
            node.expression = expression;
            return node;
        }
        export function updateSpreadElementExpression(node: SpreadElementExpression, expression: Expression): SpreadElementExpression {
            if (expression !== node.expression) {
                let newNode = createSpreadElementExpression(expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createClassExpression(decorators?: Array<Decorator>, modifiers?: Array<Node>, name?: Identifier, 
            typeParameters?: Array<TypeParameterDeclaration>, heritageClauses?: Array<HeritageClause>, members?: Array<ClassElement>, 
            location?: TextRange): ClassExpression {
            let node = createNode<ClassExpression>(SyntaxKind.ClassExpression, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.name = name;
                node.typeParameters = typeParameters && createNodeArray(typeParameters)
                node.heritageClauses = heritageClauses && createNodeArray(heritageClauses)
                node.members = members && createNodeArray(members)
            }
            return node;
        }
        export function updateClassExpression(node: ClassExpression, decorators: Array<Decorator>, modifiers: Array<Node>, name: Identifier
            , typeParameters: Array<TypeParameterDeclaration>, heritageClauses: Array<HeritageClause>, members: Array<ClassElement>
            ): ClassExpression {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || 
                heritageClauses !== node.heritageClauses || members !== node.members) {
                let newNode = createClassExpression(decorators, modifiers, name, typeParameters, heritageClauses, members);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createOmittedExpression(location?: TextRange): Expression {
            return createNode<Expression>(SyntaxKind.OmittedExpression);
        }
        export function createExpressionWithTypeArguments(expression?: LeftHandSideExpression, typeArguments?: Array<TypeNode>, 
            location?: TextRange): ExpressionWithTypeArguments {
            let node = createNode<ExpressionWithTypeArguments>(SyntaxKind.ExpressionWithTypeArguments, location);
            if (arguments.length) {
                node.expression = expression;
                node.typeArguments = typeArguments && createNodeArray(typeArguments)
            }
            return node;
        }
        export function updateExpressionWithTypeArguments(node: ExpressionWithTypeArguments, expression: LeftHandSideExpression
            , typeArguments: Array<TypeNode>): ExpressionWithTypeArguments {
            if (expression !== node.expression || typeArguments !== node.typeArguments) {
                let newNode = createExpressionWithTypeArguments(expression, typeArguments);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createAsExpression(expression?: Expression, type?: TypeNode, location?: TextRange): AsExpression {
            let node = createNode<AsExpression>(SyntaxKind.AsExpression, location);
            if (arguments.length) {
                node.expression = expression;
                node.type = type;
            }
            return node;
        }
        export function updateAsExpression(node: AsExpression, expression: Expression, type: TypeNode): AsExpression {
            if (expression !== node.expression || type !== node.type) {
                let newNode = createAsExpression(expression, type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createTemplateSpan(expression?: Expression, literal?: LiteralExpression, location?: TextRange): TemplateSpan {
            let node = createNode<TemplateSpan>(SyntaxKind.TemplateSpan, location);
            if (arguments.length) {
                node.expression = expression;
                node.literal = literal;
            }
            return node;
        }
        export function updateTemplateSpan(node: TemplateSpan, expression: Expression, literal: LiteralExpression): TemplateSpan {
            if (expression !== node.expression || literal !== node.literal) {
                let newNode = createTemplateSpan(expression, literal);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createSemicolonClassElement(location?: TextRange): SemicolonClassElement {
            return createNode<SemicolonClassElement>(SyntaxKind.SemicolonClassElement);
        }
        export function createBlock(statements?: Array<Statement>, location?: TextRange): Block {
            let node = createNode<Block>(SyntaxKind.Block, location);
            node.statements = statements && createNodeArray(statements)
            return node;
        }
        export function updateBlock(node: Block, statements: Array<Statement>): Block {
            if (statements !== node.statements) {
                let newNode = createBlock(statements);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createVariableStatement(declarationList?: VariableDeclarationList, location?: TextRange): VariableStatement {
            let node = createNode<VariableStatement>(SyntaxKind.VariableStatement, location);
            node.declarationList = declarationList;
            return node;
        }
        export function updateVariableStatement(node: VariableStatement, declarationList: VariableDeclarationList): VariableStatement {
            if (declarationList !== node.declarationList) {
                let newNode = createVariableStatement(declarationList);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createEmptyStatement(location?: TextRange): Statement {
            return createNode<Statement>(SyntaxKind.EmptyStatement);
        }
        export function createExpressionStatement(expression?: Expression, location?: TextRange): ExpressionStatement {
            let node = createNode<ExpressionStatement>(SyntaxKind.ExpressionStatement, location);
            node.expression = expression;
            return node;
        }
        export function updateExpressionStatement(node: ExpressionStatement, expression: Expression): ExpressionStatement {
            if (expression !== node.expression) {
                let newNode = createExpressionStatement(expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createIfStatement(expression?: Expression, thenStatement?: Statement, elseStatement?: Statement, 
            location?: TextRange): IfStatement {
            let node = createNode<IfStatement>(SyntaxKind.IfStatement, location);
            if (arguments.length) {
                node.expression = expression;
                node.thenStatement = thenStatement;
                node.elseStatement = elseStatement;
            }
            return node;
        }
        export function updateIfStatement(node: IfStatement, expression: Expression, thenStatement: Statement, elseStatement: Statement
            ): IfStatement {
            if (expression !== node.expression || thenStatement !== node.thenStatement || elseStatement !== node.elseStatement) {
                let newNode = createIfStatement(expression, thenStatement, elseStatement);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createDoStatement(statement?: Statement, expression?: Expression, location?: TextRange): DoStatement {
            let node = createNode<DoStatement>(SyntaxKind.DoStatement, location);
            if (arguments.length) {
                node.statement = statement;
                node.expression = expression;
            }
            return node;
        }
        export function updateDoStatement(node: DoStatement, statement: Statement, expression: Expression): DoStatement {
            if (statement !== node.statement || expression !== node.expression) {
                let newNode = createDoStatement(statement, expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createWhileStatement(expression?: Expression, statement?: Statement, location?: TextRange): WhileStatement {
            let node = createNode<WhileStatement>(SyntaxKind.WhileStatement, location);
            if (arguments.length) {
                node.expression = expression;
                node.statement = statement;
            }
            return node;
        }
        export function updateWhileStatement(node: WhileStatement, expression: Expression, statement: Statement): WhileStatement {
            if (expression !== node.expression || statement !== node.statement) {
                let newNode = createWhileStatement(expression, statement);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createForStatement(initializer?: VariableDeclarationList | Expression, condition?: Expression, incrementor?: Expression, 
            statement?: Statement, location?: TextRange): ForStatement {
            let node = createNode<ForStatement>(SyntaxKind.ForStatement, location);
            if (arguments.length) {
                node.initializer = initializer;
                node.condition = condition;
                node.incrementor = incrementor;
                node.statement = statement;
            }
            return node;
        }
        export function updateForStatement(node: ForStatement, initializer: VariableDeclarationList | Expression, condition: Expression
            , incrementor: Expression, statement: Statement): ForStatement {
            if (initializer !== node.initializer || condition !== node.condition || incrementor !== node.incrementor || statement !== node.statement
                ) {
                let newNode = createForStatement(initializer, condition, incrementor, statement);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createForInStatement(initializer?: VariableDeclarationList | Expression, expression?: Expression, statement?: Statement, 
            location?: TextRange): ForInStatement {
            let node = createNode<ForInStatement>(SyntaxKind.ForInStatement, location);
            if (arguments.length) {
                node.initializer = initializer;
                node.expression = expression;
                node.statement = statement;
            }
            return node;
        }
        export function updateForInStatement(node: ForInStatement, initializer: VariableDeclarationList | Expression, expression: Expression
            , statement: Statement): ForInStatement {
            if (initializer !== node.initializer || expression !== node.expression || statement !== node.statement) {
                let newNode = createForInStatement(initializer, expression, statement);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createForOfStatement(initializer?: VariableDeclarationList | Expression, expression?: Expression, statement?: Statement, 
            location?: TextRange): ForOfStatement {
            let node = createNode<ForOfStatement>(SyntaxKind.ForOfStatement, location);
            if (arguments.length) {
                node.initializer = initializer;
                node.expression = expression;
                node.statement = statement;
            }
            return node;
        }
        export function updateForOfStatement(node: ForOfStatement, initializer: VariableDeclarationList | Expression, expression: Expression
            , statement: Statement): ForOfStatement {
            if (initializer !== node.initializer || expression !== node.expression || statement !== node.statement) {
                let newNode = createForOfStatement(initializer, expression, statement);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createContinueStatement(label?: Identifier, location?: TextRange): ContinueStatement {
            let node = createNode<ContinueStatement>(SyntaxKind.ContinueStatement, location);
            node.label = label;
            return node;
        }
        export function updateContinueStatement(node: ContinueStatement, label: Identifier): ContinueStatement {
            if (label !== node.label) {
                let newNode = createContinueStatement(label);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createBreakStatement(label?: Identifier, location?: TextRange): BreakStatement {
            let node = createNode<BreakStatement>(SyntaxKind.BreakStatement, location);
            node.label = label;
            return node;
        }
        export function updateBreakStatement(node: BreakStatement, label: Identifier): BreakStatement {
            if (label !== node.label) {
                let newNode = createBreakStatement(label);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createReturnStatement(expression?: Expression, location?: TextRange): ReturnStatement {
            let node = createNode<ReturnStatement>(SyntaxKind.ReturnStatement, location);
            node.expression = expression;
            return node;
        }
        export function updateReturnStatement(node: ReturnStatement, expression: Expression): ReturnStatement {
            if (expression !== node.expression) {
                let newNode = createReturnStatement(expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createWithStatement(expression?: Expression, statement?: Statement, location?: TextRange): WithStatement {
            let node = createNode<WithStatement>(SyntaxKind.WithStatement, location);
            if (arguments.length) {
                node.expression = expression;
                node.statement = statement;
            }
            return node;
        }
        export function updateWithStatement(node: WithStatement, expression: Expression, statement: Statement): WithStatement {
            if (expression !== node.expression || statement !== node.statement) {
                let newNode = createWithStatement(expression, statement);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createSwitchStatement(expression?: Expression, caseBlock?: CaseBlock, location?: TextRange): SwitchStatement {
            let node = createNode<SwitchStatement>(SyntaxKind.SwitchStatement, location);
            if (arguments.length) {
                node.expression = expression;
                node.caseBlock = caseBlock;
            }
            return node;
        }
        export function updateSwitchStatement(node: SwitchStatement, expression: Expression, caseBlock: CaseBlock): SwitchStatement {
            if (expression !== node.expression || caseBlock !== node.caseBlock) {
                let newNode = createSwitchStatement(expression, caseBlock);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createLabeledStatement(label?: Identifier, statement?: Statement, location?: TextRange): LabeledStatement {
            let node = createNode<LabeledStatement>(SyntaxKind.LabeledStatement, location);
            if (arguments.length) {
                node.label = label;
                node.statement = statement;
            }
            return node;
        }
        export function updateLabeledStatement(node: LabeledStatement, label: Identifier, statement: Statement): LabeledStatement {
            if (label !== node.label || statement !== node.statement) {
                let newNode = createLabeledStatement(label, statement);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createThrowStatement(expression?: Expression, location?: TextRange): ThrowStatement {
            let node = createNode<ThrowStatement>(SyntaxKind.ThrowStatement, location);
            node.expression = expression;
            return node;
        }
        export function updateThrowStatement(node: ThrowStatement, expression: Expression): ThrowStatement {
            if (expression !== node.expression) {
                let newNode = createThrowStatement(expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createTryStatement(tryBlock?: Block, catchClause?: CatchClause, finallyBlock?: Block, location?: TextRange): TryStatement {
            let node = createNode<TryStatement>(SyntaxKind.TryStatement, location);
            if (arguments.length) {
                node.tryBlock = tryBlock;
                node.catchClause = catchClause;
                node.finallyBlock = finallyBlock;
            }
            return node;
        }
        export function updateTryStatement(node: TryStatement, tryBlock: Block, catchClause: CatchClause, finallyBlock: Block): TryStatement {
            if (tryBlock !== node.tryBlock || catchClause !== node.catchClause || finallyBlock !== node.finallyBlock) {
                let newNode = createTryStatement(tryBlock, catchClause, finallyBlock);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createDebuggerStatement(location?: TextRange): Statement {
            return createNode<Statement>(SyntaxKind.DebuggerStatement);
        }
        export function createVariableDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Node>, name?: Identifier | BindingPattern, 
            type?: TypeNode, initializer?: Expression, location?: TextRange): VariableDeclaration {
            let node = createNode<VariableDeclaration>(SyntaxKind.VariableDeclaration, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.name = name;
                node.type = type;
                node.initializer = initializer;
            }
            return node;
        }
        export function updateVariableDeclaration(node: VariableDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>
            , name: Identifier | BindingPattern, type: TypeNode, initializer: Expression): VariableDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || type !== node.type || 
                initializer !== node.initializer) {
                let newNode = createVariableDeclaration(decorators, modifiers, name, type, initializer);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createVariableDeclarationList(declarations?: Array<VariableDeclaration>, location?: TextRange): VariableDeclarationList {
            let node = createNode<VariableDeclarationList>(SyntaxKind.VariableDeclarationList, location);
            node.declarations = declarations && createNodeArray(declarations)
            return node;
        }
        export function updateVariableDeclarationList(node: VariableDeclarationList, declarations: Array<VariableDeclaration>
            ): VariableDeclarationList {
            if (declarations !== node.declarations) {
                let newNode = createVariableDeclarationList(declarations);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createFunctionDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Node>, asteriskToken?: Node, name?: Identifier, 
            typeParameters?: Array<TypeParameterDeclaration>, parameters?: Array<ParameterDeclaration>, type?: TypeNode, body?: Block, 
            location?: TextRange): FunctionDeclaration {
            let node = createNode<FunctionDeclaration>(SyntaxKind.FunctionDeclaration, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.asteriskToken = asteriskToken;
                node.name = name;
                node.typeParameters = typeParameters && createNodeArray(typeParameters)
                node.parameters = parameters && createNodeArray(parameters)
                node.type = type;
                node.body = body;
            }
            return node;
        }
        export function updateFunctionDeclaration(node: FunctionDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>, name: Identifier
            , typeParameters: Array<TypeParameterDeclaration>, parameters: Array<ParameterDeclaration>, type: TypeNode, body: Block
            ): FunctionDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || 
                parameters !== node.parameters || type !== node.type || body !== node.body) {
                let newNode = createFunctionDeclaration(decorators, modifiers, node.asteriskToken, name, typeParameters, parameters, type, body);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createClassDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Node>, name?: Identifier, 
            typeParameters?: Array<TypeParameterDeclaration>, heritageClauses?: Array<HeritageClause>, members?: Array<ClassElement>, 
            location?: TextRange): ClassDeclaration {
            let node = createNode<ClassDeclaration>(SyntaxKind.ClassDeclaration, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.name = name;
                node.typeParameters = typeParameters && createNodeArray(typeParameters)
                node.heritageClauses = heritageClauses && createNodeArray(heritageClauses)
                node.members = members && createNodeArray(members)
            }
            return node;
        }
        export function updateClassDeclaration(node: ClassDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>, name: Identifier
            , typeParameters: Array<TypeParameterDeclaration>, heritageClauses: Array<HeritageClause>, members: Array<ClassElement>
            ): ClassDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || 
                heritageClauses !== node.heritageClauses || members !== node.members) {
                let newNode = createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createInterfaceDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Node>, name?: Identifier, 
            typeParameters?: Array<TypeParameterDeclaration>, heritageClauses?: Array<HeritageClause>, members?: Array<Declaration>, 
            location?: TextRange): InterfaceDeclaration {
            let node = createNode<InterfaceDeclaration>(SyntaxKind.InterfaceDeclaration, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.name = name;
                node.typeParameters = typeParameters && createNodeArray(typeParameters)
                node.heritageClauses = heritageClauses && createNodeArray(heritageClauses)
                node.members = members && createNodeArray(members)
            }
            return node;
        }
        export function updateInterfaceDeclaration(node: InterfaceDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>, name: Identifier
            , typeParameters: Array<TypeParameterDeclaration>, heritageClauses: Array<HeritageClause>, members: Array<Declaration>
            ): InterfaceDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || 
                heritageClauses !== node.heritageClauses || members !== node.members) {
                let newNode = createInterfaceDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createTypeAliasDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Node>, name?: Identifier, 
            typeParameters?: Array<TypeParameterDeclaration>, type?: TypeNode, location?: TextRange): TypeAliasDeclaration {
            let node = createNode<TypeAliasDeclaration>(SyntaxKind.TypeAliasDeclaration, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.name = name;
                node.typeParameters = typeParameters && createNodeArray(typeParameters)
                node.type = type;
            }
            return node;
        }
        export function updateTypeAliasDeclaration(node: TypeAliasDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>, name: Identifier
            , typeParameters: Array<TypeParameterDeclaration>, type: TypeNode): TypeAliasDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || typeParameters !== node.typeParameters || 
                type !== node.type) {
                let newNode = createTypeAliasDeclaration(decorators, modifiers, name, typeParameters, type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createEnumDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Node>, name?: Identifier, members?: Array<EnumMember>, 
            location?: TextRange): EnumDeclaration {
            let node = createNode<EnumDeclaration>(SyntaxKind.EnumDeclaration, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.name = name;
                node.members = members && createNodeArray(members)
            }
            return node;
        }
        export function updateEnumDeclaration(node: EnumDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>, name: Identifier
            , members: Array<EnumMember>): EnumDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || members !== node.members) {
                let newNode = createEnumDeclaration(decorators, modifiers, name, members);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createModuleDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Node>, name?: Identifier | LiteralExpression, 
            body?: ModuleBlock | ModuleDeclaration, location?: TextRange): ModuleDeclaration {
            let node = createNode<ModuleDeclaration>(SyntaxKind.ModuleDeclaration, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.name = name;
                node.body = body;
            }
            return node;
        }
        export function updateModuleDeclaration(node: ModuleDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>
            , name: Identifier | LiteralExpression, body: ModuleBlock | ModuleDeclaration): ModuleDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || body !== node.body) {
                let newNode = createModuleDeclaration(decorators, modifiers, name, body);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createModuleBlock(statements?: Array<Statement>, location?: TextRange): ModuleBlock {
            let node = createNode<ModuleBlock>(SyntaxKind.ModuleBlock, location);
            node.statements = statements && createNodeArray(statements)
            return node;
        }
        export function updateModuleBlock(node: ModuleBlock, statements: Array<Statement>): ModuleBlock {
            if (statements !== node.statements) {
                let newNode = createModuleBlock(statements);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createCaseBlock(clauses?: Array<CaseOrDefaultClause>, location?: TextRange): CaseBlock {
            let node = createNode<CaseBlock>(SyntaxKind.CaseBlock, location);
            node.clauses = clauses && createNodeArray(clauses)
            return node;
        }
        export function updateCaseBlock(node: CaseBlock, clauses: Array<CaseOrDefaultClause>): CaseBlock {
            if (clauses !== node.clauses) {
                let newNode = createCaseBlock(clauses);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createImportEqualsDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Node>, name?: Identifier, 
            moduleReference?: EntityName | ExternalModuleReference, location?: TextRange): ImportEqualsDeclaration {
            let node = createNode<ImportEqualsDeclaration>(SyntaxKind.ImportEqualsDeclaration, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.name = name;
                node.moduleReference = moduleReference;
            }
            return node;
        }
        export function updateImportEqualsDeclaration(node: ImportEqualsDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>
            , name: Identifier, moduleReference: EntityName | ExternalModuleReference): ImportEqualsDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || name !== node.name || moduleReference !== node.moduleReference) {
                let newNode = createImportEqualsDeclaration(decorators, modifiers, name, moduleReference);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createImportDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Node>, importClause?: ImportClause, 
            moduleSpecifier?: Expression, location?: TextRange): ImportDeclaration {
            let node = createNode<ImportDeclaration>(SyntaxKind.ImportDeclaration, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.importClause = importClause;
                node.moduleSpecifier = moduleSpecifier;
            }
            return node;
        }
        export function updateImportDeclaration(node: ImportDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>
            , importClause: ImportClause, moduleSpecifier: Expression): ImportDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || importClause !== node.importClause || 
                moduleSpecifier !== node.moduleSpecifier) {
                let newNode = createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createImportClause(name?: Identifier, namedBindings?: NamespaceImport | NamedImports, location?: TextRange): ImportClause {
            let node = createNode<ImportClause>(SyntaxKind.ImportClause, location);
            if (arguments.length) {
                node.name = name;
                node.namedBindings = namedBindings;
            }
            return node;
        }
        export function updateImportClause(node: ImportClause, name: Identifier, namedBindings: NamespaceImport | NamedImports): ImportClause {
            if (name !== node.name || namedBindings !== node.namedBindings) {
                let newNode = createImportClause(name, namedBindings);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createNamespaceImport(name?: Identifier, location?: TextRange): NamespaceImport {
            let node = createNode<NamespaceImport>(SyntaxKind.NamespaceImport, location);
            node.name = name;
            return node;
        }
        export function updateNamespaceImport(node: NamespaceImport, name: Identifier): NamespaceImport {
            if (name !== node.name) {
                let newNode = createNamespaceImport(name);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createNamedImports(elements?: Array<ImportOrExportSpecifier>, location?: TextRange): NamedImports {
            let node = createNode<NamedImports>(SyntaxKind.NamedImports, location);
            node.elements = elements && createNodeArray(elements)
            return node;
        }
        export function updateNamedImports(node: NamedImports, elements: Array<ImportOrExportSpecifier>): NamedImports {
            if (elements !== node.elements) {
                let newNode = createNamedImports(elements);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createImportSpecifier(propertyName?: Identifier, name?: Identifier, location?: TextRange): ImportSpecifier {
            let node = createNode<ImportSpecifier>(SyntaxKind.ImportSpecifier, location);
            if (arguments.length) {
                node.propertyName = propertyName;
                node.name = name;
            }
            return node;
        }
        export function updateImportSpecifier(node: ImportSpecifier, propertyName: Identifier, name: Identifier): ImportSpecifier {
            if (propertyName !== node.propertyName || name !== node.name) {
                let newNode = createImportSpecifier(propertyName, name);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createExportAssignment(decorators?: Array<Decorator>, modifiers?: Array<Node>, expression?: Expression, 
            location?: TextRange): ExportAssignment {
            let node = createNode<ExportAssignment>(SyntaxKind.ExportAssignment, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.expression = expression;
            }
            return node;
        }
        export function updateExportAssignment(node: ExportAssignment, decorators: Array<Decorator>, modifiers: Array<Node>, expression: Expression
            ): ExportAssignment {
            if (decorators !== node.decorators || modifiers !== node.modifiers || expression !== node.expression) {
                let newNode = createExportAssignment(decorators, modifiers, expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createExportDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Node>, exportClause?: NamedExports, 
            moduleSpecifier?: Expression, location?: TextRange): ExportDeclaration {
            let node = createNode<ExportDeclaration>(SyntaxKind.ExportDeclaration, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
                node.exportClause = exportClause;
                node.moduleSpecifier = moduleSpecifier;
            }
            return node;
        }
        export function updateExportDeclaration(node: ExportDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>
            , exportClause: NamedExports, moduleSpecifier: Expression): ExportDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers || exportClause !== node.exportClause || 
                moduleSpecifier !== node.moduleSpecifier) {
                let newNode = createExportDeclaration(decorators, modifiers, exportClause, moduleSpecifier);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createNamedExports(elements?: Array<ImportOrExportSpecifier>, location?: TextRange): NamedExports {
            let node = createNode<NamedExports>(SyntaxKind.NamedExports, location);
            node.elements = elements && createNodeArray(elements)
            return node;
        }
        export function updateNamedExports(node: NamedExports, elements: Array<ImportOrExportSpecifier>): NamedExports {
            if (elements !== node.elements) {
                let newNode = createNamedExports(elements);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createExportSpecifier(propertyName?: Identifier, name?: Identifier, location?: TextRange): ExportSpecifier {
            let node = createNode<ExportSpecifier>(SyntaxKind.ExportSpecifier, location);
            if (arguments.length) {
                node.propertyName = propertyName;
                node.name = name;
            }
            return node;
        }
        export function updateExportSpecifier(node: ExportSpecifier, propertyName: Identifier, name: Identifier): ExportSpecifier {
            if (propertyName !== node.propertyName || name !== node.name) {
                let newNode = createExportSpecifier(propertyName, name);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createMissingDeclaration(decorators?: Array<Decorator>, modifiers?: Array<Node>, location?: TextRange): MissingDeclaration {
            let node = createNode<MissingDeclaration>(SyntaxKind.MissingDeclaration, location);
            if (arguments.length) {
                node.decorators = decorators && createNodeArray(decorators)
                setModifiers(node, modifiers);
            }
            return node;
        }
        export function updateMissingDeclaration(node: MissingDeclaration, decorators: Array<Decorator>, modifiers: Array<Node>
            ): MissingDeclaration {
            if (decorators !== node.decorators || modifiers !== node.modifiers) {
                let newNode = createMissingDeclaration(decorators, modifiers);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createExternalModuleReference(expression?: Expression, location?: TextRange): ExternalModuleReference {
            let node = createNode<ExternalModuleReference>(SyntaxKind.ExternalModuleReference, location);
            node.expression = expression;
            return node;
        }
        export function updateExternalModuleReference(node: ExternalModuleReference, expression: Expression): ExternalModuleReference {
            if (expression !== node.expression) {
                let newNode = createExternalModuleReference(expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJsxElement(openingElement?: JsxOpeningElement, children?: Array<JsxChild>, closingElement?: JsxClosingElement, 
            location?: TextRange): JsxElement {
            let node = createNode<JsxElement>(SyntaxKind.JsxElement, location);
            if (arguments.length) {
                node.openingElement = openingElement;
                node.children = children && createNodeArray(children)
                node.closingElement = closingElement;
            }
            return node;
        }
        export function updateJsxElement(node: JsxElement, openingElement: JsxOpeningElement, children: Array<JsxChild>
            , closingElement: JsxClosingElement): JsxElement {
            if (openingElement !== node.openingElement || children !== node.children || closingElement !== node.closingElement) {
                let newNode = createJsxElement(openingElement, children, closingElement);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJsxSelfClosingElement(tagName?: EntityName, attributes?: Array<JsxAttribute | JsxSpreadAttribute>, 
            location?: TextRange): JsxSelfClosingElement {
            let node = createNode<JsxSelfClosingElement>(SyntaxKind.JsxSelfClosingElement, location);
            if (arguments.length) {
                node.tagName = tagName;
                node.attributes = attributes && createNodeArray(attributes)
            }
            return node;
        }
        export function updateJsxSelfClosingElement(node: JsxSelfClosingElement, tagName: EntityName
            , attributes: Array<JsxAttribute | JsxSpreadAttribute>): JsxSelfClosingElement {
            if (tagName !== node.tagName || attributes !== node.attributes) {
                let newNode = createJsxSelfClosingElement(tagName, attributes);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJsxOpeningElement(tagName?: EntityName, attributes?: Array<JsxAttribute | JsxSpreadAttribute>, 
            location?: TextRange): JsxOpeningElement {
            let node = createNode<JsxOpeningElement>(SyntaxKind.JsxOpeningElement, location);
            if (arguments.length) {
                node.tagName = tagName;
                node.attributes = attributes && createNodeArray(attributes)
            }
            return node;
        }
        export function updateJsxOpeningElement(node: JsxOpeningElement, tagName: EntityName, attributes: Array<JsxAttribute | JsxSpreadAttribute>
            ): JsxOpeningElement {
            if (tagName !== node.tagName || attributes !== node.attributes) {
                let newNode = createJsxOpeningElement(tagName, attributes);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJsxText(location?: TextRange): JsxText {
            return createNode<JsxText>(SyntaxKind.JsxText);
        }
        export function createJsxClosingElement(tagName?: EntityName, location?: TextRange): JsxClosingElement {
            let node = createNode<JsxClosingElement>(SyntaxKind.JsxClosingElement, location);
            node.tagName = tagName;
            return node;
        }
        export function updateJsxClosingElement(node: JsxClosingElement, tagName: EntityName): JsxClosingElement {
            if (tagName !== node.tagName) {
                let newNode = createJsxClosingElement(tagName);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJsxAttribute(name?: Identifier, initializer?: Expression, location?: TextRange): JsxAttribute {
            let node = createNode<JsxAttribute>(SyntaxKind.JsxAttribute, location);
            if (arguments.length) {
                node.name = name;
                node.initializer = initializer;
            }
            return node;
        }
        export function updateJsxAttribute(node: JsxAttribute, name: Identifier, initializer: Expression): JsxAttribute {
            if (name !== node.name || initializer !== node.initializer) {
                let newNode = createJsxAttribute(name, initializer);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJsxSpreadAttribute(expression?: Expression, location?: TextRange): JsxSpreadAttribute {
            let node = createNode<JsxSpreadAttribute>(SyntaxKind.JsxSpreadAttribute, location);
            node.expression = expression;
            return node;
        }
        export function updateJsxSpreadAttribute(node: JsxSpreadAttribute, expression: Expression): JsxSpreadAttribute {
            if (expression !== node.expression) {
                let newNode = createJsxSpreadAttribute(expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJsxExpression(expression?: Expression, location?: TextRange): JsxExpression {
            let node = createNode<JsxExpression>(SyntaxKind.JsxExpression, location);
            node.expression = expression;
            return node;
        }
        export function updateJsxExpression(node: JsxExpression, expression: Expression): JsxExpression {
            if (expression !== node.expression) {
                let newNode = createJsxExpression(expression);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createCaseClause(expression?: Expression, statements?: Array<Statement>, location?: TextRange): CaseClause {
            let node = createNode<CaseClause>(SyntaxKind.CaseClause, location);
            if (arguments.length) {
                node.expression = expression;
                node.statements = statements && createNodeArray(statements)
            }
            return node;
        }
        export function updateCaseClause(node: CaseClause, expression: Expression, statements: Array<Statement>): CaseClause {
            if (expression !== node.expression || statements !== node.statements) {
                let newNode = createCaseClause(expression, statements);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createDefaultClause(statements?: Array<Statement>, location?: TextRange): DefaultClause {
            let node = createNode<DefaultClause>(SyntaxKind.DefaultClause, location);
            node.statements = statements && createNodeArray(statements)
            return node;
        }
        export function updateDefaultClause(node: DefaultClause, statements: Array<Statement>): DefaultClause {
            if (statements !== node.statements) {
                let newNode = createDefaultClause(statements);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createHeritageClause(types?: Array<ExpressionWithTypeArguments>, location?: TextRange): HeritageClause {
            let node = createNode<HeritageClause>(SyntaxKind.HeritageClause, location);
            node.types = types && createNodeArray(types)
            return node;
        }
        export function updateHeritageClause(node: HeritageClause, types: Array<ExpressionWithTypeArguments>): HeritageClause {
            if (types !== node.types) {
                let newNode = createHeritageClause(types);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createCatchClause(variableDeclaration?: VariableDeclaration, block?: Block, location?: TextRange): CatchClause {
            let node = createNode<CatchClause>(SyntaxKind.CatchClause, location);
            if (arguments.length) {
                node.variableDeclaration = variableDeclaration;
                node.block = block;
            }
            return node;
        }
        export function updateCatchClause(node: CatchClause, variableDeclaration: VariableDeclaration, block: Block): CatchClause {
            if (variableDeclaration !== node.variableDeclaration || block !== node.block) {
                let newNode = createCatchClause(variableDeclaration, block);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createPropertyAssignment(name?: DeclarationName, questionToken?: Node, initializer?: Expression, 
            location?: TextRange): PropertyAssignment {
            let node = createNode<PropertyAssignment>(SyntaxKind.PropertyAssignment, location);
            if (arguments.length) {
                node.name = name;
                node.questionToken = questionToken;
                node.initializer = initializer;
            }
            return node;
        }
        export function updatePropertyAssignment(node: PropertyAssignment, name: DeclarationName, initializer: Expression): PropertyAssignment {
            if (name !== node.name || initializer !== node.initializer) {
                let newNode = createPropertyAssignment(name, node.questionToken, initializer);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createShorthandPropertyAssignment(name?: Identifier, questionToken?: Node, 
            location?: TextRange): ShorthandPropertyAssignment {
            let node = createNode<ShorthandPropertyAssignment>(SyntaxKind.ShorthandPropertyAssignment, location);
            if (arguments.length) {
                node.name = name;
                node.questionToken = questionToken;
            }
            return node;
        }
        export function updateShorthandPropertyAssignment(node: ShorthandPropertyAssignment, name: Identifier): ShorthandPropertyAssignment {
            if (name !== node.name) {
                let newNode = createShorthandPropertyAssignment(name, node.questionToken);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createEnumMember(name?: DeclarationName, initializer?: Expression, location?: TextRange): EnumMember {
            let node = createNode<EnumMember>(SyntaxKind.EnumMember, location);
            if (arguments.length) {
                node.name = name;
                node.initializer = initializer;
            }
            return node;
        }
        export function updateEnumMember(node: EnumMember, name: DeclarationName, initializer: Expression): EnumMember {
            if (name !== node.name || initializer !== node.initializer) {
                let newNode = createEnumMember(name, initializer);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocTypeExpression(type?: JSDocType, location?: TextRange): JSDocTypeExpression {
            let node = createNode<JSDocTypeExpression>(SyntaxKind.JSDocTypeExpression, location);
            node.type = type;
            return node;
        }
        export function updateJSDocTypeExpression(node: JSDocTypeExpression, type: JSDocType): JSDocTypeExpression {
            if (type !== node.type) {
                let newNode = createJSDocTypeExpression(type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocAllType(location?: TextRange): JSDocAllType {
            return createNode<JSDocAllType>(SyntaxKind.JSDocAllType);
        }
        export function createJSDocUnknownType(location?: TextRange): JSDocUnknownType {
            return createNode<JSDocUnknownType>(SyntaxKind.JSDocUnknownType);
        }
        export function createJSDocArrayType(elementType?: JSDocType, location?: TextRange): JSDocArrayType {
            let node = createNode<JSDocArrayType>(SyntaxKind.JSDocArrayType, location);
            node.elementType = elementType;
            return node;
        }
        export function updateJSDocArrayType(node: JSDocArrayType, elementType: JSDocType): JSDocArrayType {
            if (elementType !== node.elementType) {
                let newNode = createJSDocArrayType(elementType);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocUnionType(types?: Array<JSDocType>, location?: TextRange): JSDocUnionType {
            let node = createNode<JSDocUnionType>(SyntaxKind.JSDocUnionType, location);
            node.types = types && createNodeArray(types)
            return node;
        }
        export function updateJSDocUnionType(node: JSDocUnionType, types: Array<JSDocType>): JSDocUnionType {
            if (types !== node.types) {
                let newNode = createJSDocUnionType(types);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocTupleType(types?: Array<JSDocType>, location?: TextRange): JSDocTupleType {
            let node = createNode<JSDocTupleType>(SyntaxKind.JSDocTupleType, location);
            node.types = types && createNodeArray(types)
            return node;
        }
        export function updateJSDocTupleType(node: JSDocTupleType, types: Array<JSDocType>): JSDocTupleType {
            if (types !== node.types) {
                let newNode = createJSDocTupleType(types);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocNullableType(type?: JSDocType, location?: TextRange): JSDocNullableType {
            let node = createNode<JSDocNullableType>(SyntaxKind.JSDocNullableType, location);
            node.type = type;
            return node;
        }
        export function updateJSDocNullableType(node: JSDocNullableType, type: JSDocType): JSDocNullableType {
            if (type !== node.type) {
                let newNode = createJSDocNullableType(type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocNonNullableType(type?: JSDocType, location?: TextRange): JSDocNonNullableType {
            let node = createNode<JSDocNonNullableType>(SyntaxKind.JSDocNonNullableType, location);
            node.type = type;
            return node;
        }
        export function updateJSDocNonNullableType(node: JSDocNonNullableType, type: JSDocType): JSDocNonNullableType {
            if (type !== node.type) {
                let newNode = createJSDocNonNullableType(type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocRecordType(members?: Array<JSDocRecordMember>, location?: TextRange): JSDocRecordType {
            let node = createNode<JSDocRecordType>(SyntaxKind.JSDocRecordType, location);
            node.members = members && createNodeArray(members)
            return node;
        }
        export function updateJSDocRecordType(node: JSDocRecordType, members: Array<JSDocRecordMember>): JSDocRecordType {
            if (members !== node.members) {
                let newNode = createJSDocRecordType(members);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocRecordMember(name?: Identifier | LiteralExpression, type?: JSDocType, location?: TextRange): JSDocRecordMember {
            let node = createNode<JSDocRecordMember>(SyntaxKind.JSDocRecordMember, location);
            if (arguments.length) {
                node.name = name;
                node.type = type;
            }
            return node;
        }
        export function updateJSDocRecordMember(node: JSDocRecordMember, name: Identifier | LiteralExpression, type: JSDocType): JSDocRecordMember {
            if (name !== node.name || type !== node.type) {
                let newNode = createJSDocRecordMember(name, type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocTypeReference(name?: EntityName, typeArguments?: Array<JSDocType>, location?: TextRange): JSDocTypeReference {
            let node = createNode<JSDocTypeReference>(SyntaxKind.JSDocTypeReference, location);
            if (arguments.length) {
                node.name = name;
                node.typeArguments = typeArguments && createNodeArray(typeArguments)
            }
            return node;
        }
        export function updateJSDocTypeReference(node: JSDocTypeReference, name: EntityName, typeArguments: Array<JSDocType>): JSDocTypeReference {
            if (name !== node.name || typeArguments !== node.typeArguments) {
                let newNode = createJSDocTypeReference(name, typeArguments);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocOptionalType(type?: JSDocType, location?: TextRange): JSDocOptionalType {
            let node = createNode<JSDocOptionalType>(SyntaxKind.JSDocOptionalType, location);
            node.type = type;
            return node;
        }
        export function updateJSDocOptionalType(node: JSDocOptionalType, type: JSDocType): JSDocOptionalType {
            if (type !== node.type) {
                let newNode = createJSDocOptionalType(type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocFunctionType(parameters?: Array<ParameterDeclaration>, type?: JSDocType, 
            location?: TextRange): JSDocFunctionType {
            let node = createNode<JSDocFunctionType>(SyntaxKind.JSDocFunctionType, location);
            if (arguments.length) {
                node.parameters = parameters && createNodeArray(parameters)
                node.type = type;
            }
            return node;
        }
        export function updateJSDocFunctionType(node: JSDocFunctionType, parameters: Array<ParameterDeclaration>, type: JSDocType
            ): JSDocFunctionType {
            if (parameters !== node.parameters || type !== node.type) {
                let newNode = createJSDocFunctionType(parameters, type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocVariadicType(type?: JSDocType, location?: TextRange): JSDocVariadicType {
            let node = createNode<JSDocVariadicType>(SyntaxKind.JSDocVariadicType, location);
            node.type = type;
            return node;
        }
        export function updateJSDocVariadicType(node: JSDocVariadicType, type: JSDocType): JSDocVariadicType {
            if (type !== node.type) {
                let newNode = createJSDocVariadicType(type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocConstructorType(type?: JSDocType, location?: TextRange): JSDocConstructorType {
            let node = createNode<JSDocConstructorType>(SyntaxKind.JSDocConstructorType, location);
            node.type = type;
            return node;
        }
        export function updateJSDocConstructorType(node: JSDocConstructorType, type: JSDocType): JSDocConstructorType {
            if (type !== node.type) {
                let newNode = createJSDocConstructorType(type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocThisType(type?: JSDocType, location?: TextRange): JSDocThisType {
            let node = createNode<JSDocThisType>(SyntaxKind.JSDocThisType, location);
            node.type = type;
            return node;
        }
        export function updateJSDocThisType(node: JSDocThisType, type: JSDocType): JSDocThisType {
            if (type !== node.type) {
                let newNode = createJSDocThisType(type);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocComment(tags?: Array<JSDocTag>, location?: TextRange): JSDocComment {
            let node = createNode<JSDocComment>(SyntaxKind.JSDocComment, location);
            node.tags = tags && createNodeArray(tags)
            return node;
        }
        export function updateJSDocComment(node: JSDocComment, tags: Array<JSDocTag>): JSDocComment {
            if (tags !== node.tags) {
                let newNode = createJSDocComment(tags);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocTag(atToken?: Node, tagName?: Identifier, location?: TextRange): JSDocTag {
            let node = createNode<JSDocTag>(SyntaxKind.JSDocTag, location);
            if (arguments.length) {
                node.atToken = atToken;
                node.tagName = tagName;
            }
            return node;
        }
        export function updateJSDocTag(node: JSDocTag, tagName: Identifier): JSDocTag {
            if (tagName !== node.tagName) {
                let newNode = createJSDocTag(node.atToken, tagName);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocParameterTag(preParameterName?: Identifier, typeExpression?: JSDocTypeExpression, postParameterName?: Identifier, 
            atToken?: Node, tagName?: Identifier, location?: TextRange): JSDocParameterTag {
            let node = createNode<JSDocParameterTag>(SyntaxKind.JSDocParameterTag, location);
            if (arguments.length) {
                node.preParameterName = preParameterName;
                node.typeExpression = typeExpression;
                node.postParameterName = postParameterName;
                node.atToken = atToken;
                node.tagName = tagName;
            }
            return node;
        }
        export function updateJSDocParameterTag(node: JSDocParameterTag, preParameterName: Identifier, typeExpression: JSDocTypeExpression
            , postParameterName: Identifier, tagName: Identifier): JSDocParameterTag {
            if (preParameterName !== node.preParameterName || typeExpression !== node.typeExpression || postParameterName !== node.postParameterName
                || tagName !== node.tagName) {
                let newNode = createJSDocParameterTag(preParameterName, typeExpression, postParameterName, node.atToken, tagName);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocReturnTag(typeExpression?: JSDocTypeExpression, atToken?: Node, tagName?: Identifier, 
            location?: TextRange): JSDocReturnTag {
            let node = createNode<JSDocReturnTag>(SyntaxKind.JSDocReturnTag, location);
            if (arguments.length) {
                node.typeExpression = typeExpression;
                node.atToken = atToken;
                node.tagName = tagName;
            }
            return node;
        }
        export function updateJSDocReturnTag(node: JSDocReturnTag, typeExpression: JSDocTypeExpression, tagName: Identifier): JSDocReturnTag {
            if (typeExpression !== node.typeExpression || tagName !== node.tagName) {
                let newNode = createJSDocReturnTag(typeExpression, node.atToken, tagName);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocTypeTag(typeExpression?: JSDocTypeExpression, atToken?: Node, tagName?: Identifier, 
            location?: TextRange): JSDocTypeTag {
            let node = createNode<JSDocTypeTag>(SyntaxKind.JSDocTypeTag, location);
            if (arguments.length) {
                node.typeExpression = typeExpression;
                node.atToken = atToken;
                node.tagName = tagName;
            }
            return node;
        }
        export function updateJSDocTypeTag(node: JSDocTypeTag, typeExpression: JSDocTypeExpression, tagName: Identifier): JSDocTypeTag {
            if (typeExpression !== node.typeExpression || tagName !== node.tagName) {
                let newNode = createJSDocTypeTag(typeExpression, node.atToken, tagName);
                return updateFrom(node, newNode);
            }
            return node;
        }
        export function createJSDocTemplateTag(typeParameters?: Array<TypeParameterDeclaration>, atToken?: Node, tagName?: Identifier, 
            location?: TextRange): JSDocTemplateTag {
            let node = createNode<JSDocTemplateTag>(SyntaxKind.JSDocTemplateTag, location);
            if (arguments.length) {
                node.typeParameters = typeParameters && createNodeArray(typeParameters)
                node.atToken = atToken;
                node.tagName = tagName;
            }
            return node;
        }
        export function updateJSDocTemplateTag(node: JSDocTemplateTag, typeParameters: Array<TypeParameterDeclaration>, tagName: Identifier
            ): JSDocTemplateTag {
            if (typeParameters !== node.typeParameters || tagName !== node.tagName) {
                let newNode = createJSDocTemplateTag(typeParameters, node.atToken, tagName);
                return updateFrom(node, newNode);
            }
            return node;
        }
    }
    export function isNumericLiteral(node: Node): node is LiteralExpression {
        return node && node.kind === SyntaxKind.NumericLiteral;
    }
    export function isStringLiteral(node: Node): node is StringLiteral {
        return node && node.kind === SyntaxKind.StringLiteral;
    }
    export function isRegularExpressionLiteral(node: Node): node is LiteralExpression {
        return node && node.kind === SyntaxKind.RegularExpressionLiteral;
    }
    export function isNoSubstitutionTemplateLiteral(node: Node): node is LiteralExpression {
        return node && node.kind === SyntaxKind.NoSubstitutionTemplateLiteral;
    }
    export function isTemplateHead(node: Node): node is LiteralExpression {
        return node && node.kind === SyntaxKind.TemplateHead;
    }
    export function isTemplateMiddle(node: Node): node is LiteralExpression {
        return node && node.kind === SyntaxKind.TemplateMiddle;
    }
    export function isTemplateTail(node: Node): node is LiteralExpression {
        return node && node.kind === SyntaxKind.TemplateTail;
    }
    export function isIdentifier(node: Node): node is Identifier {
        return node && node.kind === SyntaxKind.Identifier;
    }
    export function isQualifiedName(node: Node): node is QualifiedName {
        return node && node.kind === SyntaxKind.QualifiedName;
    }
    export function isComputedPropertyName(node: Node): node is ComputedPropertyName {
        return node && node.kind === SyntaxKind.ComputedPropertyName;
    }
    export function isTypeParameter(node: Node): node is TypeParameterDeclaration {
        return node && node.kind === SyntaxKind.TypeParameter;
    }
    export function isParameter(node: Node): node is ParameterDeclaration {
        return node && node.kind === SyntaxKind.Parameter;
    }
    export function isDecorator(node: Node): node is Decorator {
        return node && node.kind === SyntaxKind.Decorator;
    }
    export function isPropertySignature(node: Node): node is PropertySignature {
        return node && node.kind === SyntaxKind.PropertySignature;
    }
    export function isPropertyDeclaration(node: Node): node is PropertyDeclaration {
        return node && node.kind === SyntaxKind.PropertyDeclaration;
    }
    export function isMethodSignature(node: Node): node is MethodSignature {
        return node && node.kind === SyntaxKind.MethodSignature;
    }
    export function isMethodDeclaration(node: Node): node is MethodDeclaration {
        return node && node.kind === SyntaxKind.MethodDeclaration;
    }
    export function isConstructor(node: Node): node is ConstructorDeclaration {
        return node && node.kind === SyntaxKind.Constructor;
    }
    export function isGetAccessor(node: Node): node is GetAccessorDeclaration {
        return node && node.kind === SyntaxKind.GetAccessor;
    }
    export function isSetAccessor(node: Node): node is SetAccessorDeclaration {
        return node && node.kind === SyntaxKind.SetAccessor;
    }
    export function isCallSignature(node: Node): node is CallSignatureDeclaration {
        return node && node.kind === SyntaxKind.CallSignature;
    }
    export function isConstructSignature(node: Node): node is ConstructSignatureDeclaration {
        return node && node.kind === SyntaxKind.ConstructSignature;
    }
    export function isIndexSignature(node: Node): node is IndexSignatureDeclaration {
        return node && node.kind === SyntaxKind.IndexSignature;
    }
    export function isTypePredicate(node: Node): node is TypePredicateNode {
        return node && node.kind === SyntaxKind.TypePredicate;
    }
    export function isTypeReference(node: Node): node is TypeReferenceNode {
        return node && node.kind === SyntaxKind.TypeReference;
    }
    export function isFunctionType(node: Node): node is FunctionTypeNode {
        return node && node.kind === SyntaxKind.FunctionType;
    }
    export function isConstructorType(node: Node): node is ConstructorTypeNode {
        return node && node.kind === SyntaxKind.ConstructorType;
    }
    export function isTypeQuery(node: Node): node is TypeQueryNode {
        return node && node.kind === SyntaxKind.TypeQuery;
    }
    export function isTypeLiteral(node: Node): node is TypeLiteralNode {
        return node && node.kind === SyntaxKind.TypeLiteral;
    }
    export function isArrayType(node: Node): node is ArrayTypeNode {
        return node && node.kind === SyntaxKind.ArrayType;
    }
    export function isTupleType(node: Node): node is TupleTypeNode {
        return node && node.kind === SyntaxKind.TupleType;
    }
    export function isUnionType(node: Node): node is UnionTypeNode {
        return node && node.kind === SyntaxKind.UnionType;
    }
    export function isIntersectionType(node: Node): node is IntersectionTypeNode {
        return node && node.kind === SyntaxKind.IntersectionType;
    }
    export function isParenthesizedType(node: Node): node is ParenthesizedTypeNode {
        return node && node.kind === SyntaxKind.ParenthesizedType;
    }
    export function isObjectBindingPattern(node: Node): node is ObjectBindingPattern {
        return node && node.kind === SyntaxKind.ObjectBindingPattern;
    }
    export function isArrayBindingPattern(node: Node): node is ArrayBindingPattern {
        return node && node.kind === SyntaxKind.ArrayBindingPattern;
    }
    export function isBindingElement(node: Node): node is BindingElement {
        return node && node.kind === SyntaxKind.BindingElement;
    }
    export function isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression {
        return node && node.kind === SyntaxKind.ArrayLiteralExpression;
    }
    export function isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression {
        return node && node.kind === SyntaxKind.ObjectLiteralExpression;
    }
    export function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression {
        return node && node.kind === SyntaxKind.PropertyAccessExpression;
    }
    export function isElementAccessExpression(node: Node): node is ElementAccessExpression {
        return node && node.kind === SyntaxKind.ElementAccessExpression;
    }
    export function isCallExpression(node: Node): node is CallExpression {
        return node && node.kind === SyntaxKind.CallExpression;
    }
    export function isNewExpression(node: Node): node is NewExpression {
        return node && node.kind === SyntaxKind.NewExpression;
    }
    export function isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression {
        return node && node.kind === SyntaxKind.TaggedTemplateExpression;
    }
    export function isTypeAssertionExpression(node: Node): node is TypeAssertion {
        return node && node.kind === SyntaxKind.TypeAssertionExpression;
    }
    export function isParenthesizedExpression(node: Node): node is ParenthesizedExpression {
        return node && node.kind === SyntaxKind.ParenthesizedExpression;
    }
    export function isFunctionExpression(node: Node): node is FunctionExpression {
        return node && node.kind === SyntaxKind.FunctionExpression;
    }
    export function isArrowFunction(node: Node): node is ArrowFunction {
        return node && node.kind === SyntaxKind.ArrowFunction;
    }
    export function isDeleteExpression(node: Node): node is DeleteExpression {
        return node && node.kind === SyntaxKind.DeleteExpression;
    }
    export function isTypeOfExpression(node: Node): node is TypeOfExpression {
        return node && node.kind === SyntaxKind.TypeOfExpression;
    }
    export function isVoidExpression(node: Node): node is VoidExpression {
        return node && node.kind === SyntaxKind.VoidExpression;
    }
    export function isAwaitExpression(node: Node): node is AwaitExpression {
        return node && node.kind === SyntaxKind.AwaitExpression;
    }
    export function isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression {
        return node && node.kind === SyntaxKind.PrefixUnaryExpression;
    }
    export function isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression {
        return node && node.kind === SyntaxKind.PostfixUnaryExpression;
    }
    export function isBinaryExpression(node: Node): node is BinaryExpression {
        return node && node.kind === SyntaxKind.BinaryExpression;
    }
    export function isConditionalExpression(node: Node): node is ConditionalExpression {
        return node && node.kind === SyntaxKind.ConditionalExpression;
    }
    export function isTemplateExpression(node: Node): node is TemplateExpression {
        return node && node.kind === SyntaxKind.TemplateExpression;
    }
    export function isYieldExpression(node: Node): node is YieldExpression {
        return node && node.kind === SyntaxKind.YieldExpression;
    }
    export function isSpreadElementExpression(node: Node): node is SpreadElementExpression {
        return node && node.kind === SyntaxKind.SpreadElementExpression;
    }
    export function isClassExpression(node: Node): node is ClassExpression {
        return node && node.kind === SyntaxKind.ClassExpression;
    }
    export function isOmittedExpression(node: Node): node is Expression {
        return node && node.kind === SyntaxKind.OmittedExpression;
    }
    export function isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments {
        return node && node.kind === SyntaxKind.ExpressionWithTypeArguments;
    }
    export function isAsExpression(node: Node): node is AsExpression {
        return node && node.kind === SyntaxKind.AsExpression;
    }
    export function isTemplateSpan(node: Node): node is TemplateSpan {
        return node && node.kind === SyntaxKind.TemplateSpan;
    }
    export function isSemicolonClassElement(node: Node): node is SemicolonClassElement {
        return node && node.kind === SyntaxKind.SemicolonClassElement;
    }
    export function isBlock(node: Node): node is Block {
        return node && node.kind === SyntaxKind.Block;
    }
    export function isVariableStatement(node: Node): node is VariableStatement {
        return node && node.kind === SyntaxKind.VariableStatement;
    }
    export function isEmptyStatement(node: Node): node is Statement {
        return node && node.kind === SyntaxKind.EmptyStatement;
    }
    export function isExpressionStatement(node: Node): node is ExpressionStatement {
        return node && node.kind === SyntaxKind.ExpressionStatement;
    }
    export function isIfStatement(node: Node): node is IfStatement {
        return node && node.kind === SyntaxKind.IfStatement;
    }
    export function isDoStatement(node: Node): node is DoStatement {
        return node && node.kind === SyntaxKind.DoStatement;
    }
    export function isWhileStatement(node: Node): node is WhileStatement {
        return node && node.kind === SyntaxKind.WhileStatement;
    }
    export function isForStatement(node: Node): node is ForStatement {
        return node && node.kind === SyntaxKind.ForStatement;
    }
    export function isForInStatement(node: Node): node is ForInStatement {
        return node && node.kind === SyntaxKind.ForInStatement;
    }
    export function isForOfStatement(node: Node): node is ForOfStatement {
        return node && node.kind === SyntaxKind.ForOfStatement;
    }
    export function isContinueStatement(node: Node): node is ContinueStatement {
        return node && node.kind === SyntaxKind.ContinueStatement;
    }
    export function isBreakStatement(node: Node): node is BreakStatement {
        return node && node.kind === SyntaxKind.BreakStatement;
    }
    export function isReturnStatement(node: Node): node is ReturnStatement {
        return node && node.kind === SyntaxKind.ReturnStatement;
    }
    export function isWithStatement(node: Node): node is WithStatement {
        return node && node.kind === SyntaxKind.WithStatement;
    }
    export function isSwitchStatement(node: Node): node is SwitchStatement {
        return node && node.kind === SyntaxKind.SwitchStatement;
    }
    export function isLabeledStatement(node: Node): node is LabeledStatement {
        return node && node.kind === SyntaxKind.LabeledStatement;
    }
    export function isThrowStatement(node: Node): node is ThrowStatement {
        return node && node.kind === SyntaxKind.ThrowStatement;
    }
    export function isTryStatement(node: Node): node is TryStatement {
        return node && node.kind === SyntaxKind.TryStatement;
    }
    export function isDebuggerStatement(node: Node): node is Statement {
        return node && node.kind === SyntaxKind.DebuggerStatement;
    }
    export function isVariableDeclaration(node: Node): node is VariableDeclaration {
        return node && node.kind === SyntaxKind.VariableDeclaration;
    }
    export function isVariableDeclarationList(node: Node): node is VariableDeclarationList {
        return node && node.kind === SyntaxKind.VariableDeclarationList;
    }
    export function isFunctionDeclaration(node: Node): node is FunctionDeclaration {
        return node && node.kind === SyntaxKind.FunctionDeclaration;
    }
    export function isClassDeclaration(node: Node): node is ClassDeclaration {
        return node && node.kind === SyntaxKind.ClassDeclaration;
    }
    export function isInterfaceDeclaration(node: Node): node is InterfaceDeclaration {
        return node && node.kind === SyntaxKind.InterfaceDeclaration;
    }
    export function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration {
        return node && node.kind === SyntaxKind.TypeAliasDeclaration;
    }
    export function isEnumDeclaration(node: Node): node is EnumDeclaration {
        return node && node.kind === SyntaxKind.EnumDeclaration;
    }
    export function isModuleDeclaration(node: Node): node is ModuleDeclaration {
        return node && node.kind === SyntaxKind.ModuleDeclaration;
    }
    export function isModuleBlock(node: Node): node is ModuleBlock {
        return node && node.kind === SyntaxKind.ModuleBlock;
    }
    export function isCaseBlock(node: Node): node is CaseBlock {
        return node && node.kind === SyntaxKind.CaseBlock;
    }
    export function isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration {
        return node && node.kind === SyntaxKind.ImportEqualsDeclaration;
    }
    export function isImportDeclaration(node: Node): node is ImportDeclaration {
        return node && node.kind === SyntaxKind.ImportDeclaration;
    }
    export function isImportClause(node: Node): node is ImportClause {
        return node && node.kind === SyntaxKind.ImportClause;
    }
    export function isNamespaceImport(node: Node): node is NamespaceImport {
        return node && node.kind === SyntaxKind.NamespaceImport;
    }
    export function isNamedImports(node: Node): node is NamedImports {
        return node && node.kind === SyntaxKind.NamedImports;
    }
    export function isImportSpecifier(node: Node): node is ImportSpecifier {
        return node && node.kind === SyntaxKind.ImportSpecifier;
    }
    export function isExportAssignment(node: Node): node is ExportAssignment {
        return node && node.kind === SyntaxKind.ExportAssignment;
    }
    export function isExportDeclaration(node: Node): node is ExportDeclaration {
        return node && node.kind === SyntaxKind.ExportDeclaration;
    }
    export function isNamedExports(node: Node): node is NamedExports {
        return node && node.kind === SyntaxKind.NamedExports;
    }
    export function isExportSpecifier(node: Node): node is ExportSpecifier {
        return node && node.kind === SyntaxKind.ExportSpecifier;
    }
    export function isMissingDeclaration(node: Node): node is MissingDeclaration {
        return node && node.kind === SyntaxKind.MissingDeclaration;
    }
    export function isExternalModuleReference(node: Node): node is ExternalModuleReference {
        return node && node.kind === SyntaxKind.ExternalModuleReference;
    }
    export function isJsxElement(node: Node): node is JsxElement {
        return node && node.kind === SyntaxKind.JsxElement;
    }
    export function isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement {
        return node && node.kind === SyntaxKind.JsxSelfClosingElement;
    }
    export function isJsxOpeningElement(node: Node): node is JsxOpeningElement {
        return node && node.kind === SyntaxKind.JsxOpeningElement;
    }
    export function isJsxText(node: Node): node is JsxText {
        return node && node.kind === SyntaxKind.JsxText;
    }
    export function isJsxClosingElement(node: Node): node is JsxClosingElement {
        return node && node.kind === SyntaxKind.JsxClosingElement;
    }
    export function isJsxAttribute(node: Node): node is JsxAttribute {
        return node && node.kind === SyntaxKind.JsxAttribute;
    }
    export function isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute {
        return node && node.kind === SyntaxKind.JsxSpreadAttribute;
    }
    export function isJsxExpression(node: Node): node is JsxExpression {
        return node && node.kind === SyntaxKind.JsxExpression;
    }
    export function isCaseClause(node: Node): node is CaseClause {
        return node && node.kind === SyntaxKind.CaseClause;
    }
    export function isDefaultClause(node: Node): node is DefaultClause {
        return node && node.kind === SyntaxKind.DefaultClause;
    }
    export function isHeritageClause(node: Node): node is HeritageClause {
        return node && node.kind === SyntaxKind.HeritageClause;
    }
    export function isCatchClause(node: Node): node is CatchClause {
        return node && node.kind === SyntaxKind.CatchClause;
    }
    export function isPropertyAssignment(node: Node): node is PropertyAssignment {
        return node && node.kind === SyntaxKind.PropertyAssignment;
    }
    export function isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment {
        return node && node.kind === SyntaxKind.ShorthandPropertyAssignment;
    }
    export function isEnumMember(node: Node): node is EnumMember {
        return node && node.kind === SyntaxKind.EnumMember;
    }
    export function isJSDocTypeExpression(node: Node): node is JSDocTypeExpression {
        return node && node.kind === SyntaxKind.JSDocTypeExpression;
    }
    export function isJSDocAllType(node: Node): node is JSDocAllType {
        return node && node.kind === SyntaxKind.JSDocAllType;
    }
    export function isJSDocUnknownType(node: Node): node is JSDocUnknownType {
        return node && node.kind === SyntaxKind.JSDocUnknownType;
    }
    export function isJSDocArrayType(node: Node): node is JSDocArrayType {
        return node && node.kind === SyntaxKind.JSDocArrayType;
    }
    export function isJSDocUnionType(node: Node): node is JSDocUnionType {
        return node && node.kind === SyntaxKind.JSDocUnionType;
    }
    export function isJSDocTupleType(node: Node): node is JSDocTupleType {
        return node && node.kind === SyntaxKind.JSDocTupleType;
    }
    export function isJSDocNullableType(node: Node): node is JSDocNullableType {
        return node && node.kind === SyntaxKind.JSDocNullableType;
    }
    export function isJSDocNonNullableType(node: Node): node is JSDocNonNullableType {
        return node && node.kind === SyntaxKind.JSDocNonNullableType;
    }
    export function isJSDocRecordType(node: Node): node is JSDocRecordType {
        return node && node.kind === SyntaxKind.JSDocRecordType;
    }
    export function isJSDocRecordMember(node: Node): node is JSDocRecordMember {
        return node && node.kind === SyntaxKind.JSDocRecordMember;
    }
    export function isJSDocTypeReference(node: Node): node is JSDocTypeReference {
        return node && node.kind === SyntaxKind.JSDocTypeReference;
    }
    export function isJSDocOptionalType(node: Node): node is JSDocOptionalType {
        return node && node.kind === SyntaxKind.JSDocOptionalType;
    }
    export function isJSDocFunctionType(node: Node): node is JSDocFunctionType {
        return node && node.kind === SyntaxKind.JSDocFunctionType;
    }
    export function isJSDocVariadicType(node: Node): node is JSDocVariadicType {
        return node && node.kind === SyntaxKind.JSDocVariadicType;
    }
    export function isJSDocConstructorType(node: Node): node is JSDocConstructorType {
        return node && node.kind === SyntaxKind.JSDocConstructorType;
    }
    export function isJSDocThisType(node: Node): node is JSDocThisType {
        return node && node.kind === SyntaxKind.JSDocThisType;
    }
    export function isJSDocComment(node: Node): node is JSDocComment {
        return node && node.kind === SyntaxKind.JSDocComment;
    }
    export function isJSDocTag(node: Node): node is JSDocTag {
        return node && node.kind === SyntaxKind.JSDocTag;
    }
    export function isJSDocParameterTag(node: Node): node is JSDocParameterTag {
        return node && node.kind === SyntaxKind.JSDocParameterTag;
    }
    export function isJSDocReturnTag(node: Node): node is JSDocReturnTag {
        return node && node.kind === SyntaxKind.JSDocReturnTag;
    }
    export function isJSDocTypeTag(node: Node): node is JSDocTypeTag {
        return node && node.kind === SyntaxKind.JSDocTypeTag;
    }
    export function isJSDocTemplateTag(node: Node): node is JSDocTemplateTag {
        return node && node.kind === SyntaxKind.JSDocTemplateTag;
    }
}
