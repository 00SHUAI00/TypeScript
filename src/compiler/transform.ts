/// <reference path="factory.ts" />
/// <reference path="transform.generated.ts" />
/* @internal */
namespace ts.transform {
    // Flags enum to track count of temp variables and a few dedicated names
    const enum TempFlags {
        Auto      = 0x00000000,  // No preferred name
        CountMask = 0x0FFFFFFF,  // Temp variable counter
        _i        = 0x10000000,  // Use/preference flag for '_i'
    }
    
    export class VisitorContext {
        private generatedNameSet: Map<string> = {};
        private getGeneratedNameForNode: (node: Node) => string;
        
        private tempFlagStack: number[] = [];
        private hoistedVariableDeclarationsStack: VariableDeclaration[][] = [];
        private hoistedFunctionDeclarationsStack: FunctionDeclaration[][] = [];
        private statementsStack: Statement[][] = [];
        private isPinnedOrTripleSlashComment = (comment: CommentRange) => this.isPinnedOrTripleSlashCommentWorker(comment);
        
        public currentSourceFile: SourceFile;
        public resolver: EmitResolver;
        
        constructor(currentSourceFile: SourceFile, resolver: EmitResolver, generatedNameSet: Map<string>, getGeneratedNameForNode: (node: Node) => string) {
            this.currentSourceFile = currentSourceFile;
            this.resolver = resolver;
            this.generatedNameSet = generatedNameSet;
            this.getGeneratedNameForNode = getGeneratedNameForNode;
        }
        
        public pushLexicalEnvironment(): void {
            this.tempFlagStack.push(0);
            this.hoistedVariableDeclarationsStack.push(undefined);
            this.hoistedFunctionDeclarationsStack.push(undefined);
        }
        
        public getHoistedVariableDeclarations(): VariableDeclaration[] {
            return this.hoistedVariableDeclarationsStack[this.hoistedVariableDeclarationsStack.length - 1];
        }
        
        public getHoistedFunctionDeclarations(): FunctionDeclaration[] {
            return this.hoistedFunctionDeclarationsStack[this.hoistedFunctionDeclarationsStack.length - 1];
        }
        
        // Return the next available name in the pattern _a ... _z, _0, _1, ...
        // TempFlags._i or TempFlags._n may be used to express a preference for that dedicated name.
        // Note that names generated by makeTempVariableName and makeUniqueName will never conflict.
        public makeTempVariableName(flags: TempFlags): string {
            let tempFlags = this.tempFlagStack[this.tempFlagStack.length - 1];
            if (flags && !(tempFlags & flags)) {
                let name = flags === TempFlags._i ? "_i" : "_n";
                if (this.isUniqueName(name)) {
                    this.tempFlagStack[this.tempFlagStack.length - 1] = tempFlags |= flags;
                    return name;
                }
            }
            while (true) {
                let count = tempFlags & TempFlags.CountMask;
                tempFlags++;
                // Skip over 'i' and 'n'
                if (count !== 8 && count !== 13) {
                    let name = count < 26 
                        ? "_" + String.fromCharCode(CharacterCodes.a + count)
                        : "_" + (count - 26);
                    if (this.isUniqueName(name)) {
                        this.tempFlagStack[this.tempFlagStack.length - 1] = tempFlags;
                        return name;
                    }
                }
            }
        }
        
        // Generate a name that is unique within the current file and doesn't conflict with any names
        // in global scope. The name is formed by adding an '_n' suffix to the specified base name,
        // where n is a positive integer. Note that names generated by makeTempVariableName and
        // makeUniqueName are guaranteed to never conflict.
        public makeUniqueName(baseName: string): string {
            // Find the first unique 'name_n', where n is a positive number
            if (baseName.charCodeAt(baseName.length - 1) !== CharacterCodes._) {
                baseName += "_";
            }
            let i = 1;
            while (true) {
                let generatedName = baseName + i;
                if (this.isUniqueName(generatedName)) {
                    return this.generatedNameSet[generatedName] = generatedName;
                }
                i++;
            }
        }

        public getDeclarationName(node: Declaration) {
            let name = node.name;
            if (name && !nodeIsSynthesized(name)) {
                return factory.cloneNode(name);
            }
            else {
                return factory.createIdentifier(
                    this.getGeneratedNameForNode(node)
                );
            }
        }
        
        public createUniqueIdentifier(baseName: string): Identifier {
            let name = this.makeUniqueName(baseName);
            return factory.createIdentifier(name);
        }
        
        public createTempVariable(flags: TempFlags): Identifier {
            let name = this.makeTempVariableName(flags);
            return factory.createIdentifier(name);
        }
        
        public declareLocal(baseName?: string): Identifier {
            let local = baseName 
                ? this.createUniqueIdentifier(baseName)
                : this.createTempVariable(TempFlags.Auto);
            this.hoistVariableDeclaration(local);
            return local;
        }
        
        public hoistVariableDeclaration(name: Identifier): void {
            let hoistedVariableDeclarations = this.getHoistedVariableDeclarations();
            if (!hoistedVariableDeclarations) {
                this.hoistedVariableDeclarationsStack[this.hoistedVariableDeclarationsStack.length - 1] = hoistedVariableDeclarations = [];
            }
            
            hoistedVariableDeclarations.push(factory.createVariableDeclaration2(name));
        }

        public hoistFunctionDeclaration(func: FunctionDeclaration): void {
            let hoistedFunctionDeclarations = this.getHoistedFunctionDeclarations();
            if (!hoistedFunctionDeclarations) {
                this.hoistedFunctionDeclarationsStack[this.hoistedFunctionDeclarationsStack.length - 1] = hoistedFunctionDeclarations = [];
            }
            
            hoistedFunctionDeclarations.push(func);
        }
        
        public popLexicalEnvironment(): void {
            this.tempFlagStack.pop();
            this.hoistedVariableDeclarationsStack.pop();
            this.hoistedFunctionDeclarationsStack.pop();
        }
        
        public pushStatements(): void {
            this.statementsStack.push(undefined);
        }
        
        public getStatements(): Statement[] {
            return this.statementsStack[this.statementsStack.length - 1];
        }
        
        public emitStatement(statement: Statement) {
            if (!statement) {
                return;
            }
            
            let statements = this.statementsStack[this.statementsStack.length - 1];
            if (!statements) {
                this.statementsStack[this.statementsStack.length - 1] = statements = [];
            }
            
            statements.push(statement);
        }
        
        public emitStatements(statements: Statement[]) {
            for (let statement of statements) {
                this.emitStatement(statement);
            }
        }
        
        public emitExpressionStatement(expression: Expression, location?: TextRange) {
            this.emitStatement(factory.createExpressionStatement(expression));
        }

        public emitExpressionStatements(expressions: Expression[]) {
            for (let expression of expressions) {
                this.emitExpressionStatement(expression);
            }
        }
        
        public emitReturnStatement(expression?: Expression, location?: TextRange) {
            this.emitStatement(factory.createReturnStatement(expression, location));
        }
        
        public emitAssignmentStatement(left: Expression, right: Expression, location?: TextRange) {
            this.emitStatement(factory.createAssignmentExpressionStatement(left, right, location));
        }

        public popStatements(): void {
            this.statementsStack.pop();
        }

        public getLeadingCommentRanges(node: Node, onlyPinnedOrTripleSlashComments?: boolean) {
            let leadingCommentRanges: CommentRange[];
            
            while (node && !leadingCommentRanges) {
                leadingCommentRanges = (<SynthesizedNode>node).leadingCommentRanges;
                if (!leadingCommentRanges && !nodeIsSynthesized(node)) {
                    leadingCommentRanges = getLeadingCommentRangesOfNode(node, this.currentSourceFile);
                }
                
                node = node.original;
            }
            
            return this.filterComments(leadingCommentRanges, onlyPinnedOrTripleSlashComments);
        }
        
        public getTrailingCommentRanges(node: Node) {
            let trailingCommentRanges: CommentRange[];
            
            while (node && !trailingCommentRanges) {
                trailingCommentRanges = (<SynthesizedNode>node).trailingCommentRanges;
                if (!trailingCommentRanges && !nodeIsSynthesized(node)) {
                    trailingCommentRanges = getTrailingCommentRanges(this.currentSourceFile.text, node.pos);
                }
                
                node = node.original;
            }
            
            return trailingCommentRanges;
        }

        private filterComments(ranges: CommentRange[], onlyPinnedOrTripleSlashComments: boolean): CommentRange[] {
            // If we're removing comments, then we want to strip out all but the pinned or
            // triple slash comments.
            if (ranges && onlyPinnedOrTripleSlashComments) {
                ranges = filter(ranges, this.isPinnedOrTripleSlashComment);
                if (ranges.length === 0) {
                    return undefined;
                }
            }

            return ranges;
        }
        
        private isPinnedOrTripleSlashCommentWorker(comment: CommentRange) {
            if (this.currentSourceFile.text.charCodeAt(comment.pos + 1) === CharacterCodes.asterisk) {
                return this.currentSourceFile.text.charCodeAt(comment.pos + 2) === CharacterCodes.exclamation;
            }
            // Verify this is /// comment, but do the regexp match only when we first can find /// in the comment text
            // so that we don't end up computing comment string and doing match for all // comments
            else if (this.currentSourceFile.text.charCodeAt(comment.pos + 1) === CharacterCodes.slash &&
                comment.pos + 2 < comment.end &&
                this.currentSourceFile.text.charCodeAt(comment.pos + 2) === CharacterCodes.slash &&
                this.currentSourceFile.text.substring(comment.pos, comment.end).match(fullTripleSlashReferencePathRegEx)) {
                return true;
            }
        }

        private isUniqueName(name: string): boolean {
            return !this.resolver.hasGlobalName(name)
                && !hasProperty(this.currentSourceFile.identifiers, name)
                && !hasProperty(this.generatedNameSet, name);
        }
    }
    
    export type Visitor = (context: VisitorContext, node: Node) => Node;
    
    export function visit(context: VisitorContext, node: Node, visitor: Visitor): Node {
        if (!node || !visitor) {
            return node;
        }
        
        let visited = visitor(context, node);
        if (visited && visited !== node) {
            aggregateTransformFlags(visited);
        }
        
        return visited;
    }
    
    export function visitStatement(context: VisitorContext, node: Statement, visitor: Visitor): Statement {
        let visited = visit(context, node, visitor);
        Debug.assert(!visited || isStatement(visited) || isDeclarationStatement(visited), "Wrong node kind after visit.");
        return <Statement>visited;
    }

    /**
      * Visits a Block in a new lexical scope.
      */
    export function visitBlockInNewLexicalScope(context: VisitorContext, node: Block, visitor: Visitor): Block {
        return visitNodeInNewLexicalEnvironment(context, node, visitor, afterVisitBlockInNewLexicalEnvironment);
    }
    
    /**
      * Visits a Block or an Expression that starts a new lexical scope.
      */
    export function visitBlockOrExpressionInNewLexicalScope(context: VisitorContext, node: Block | Expression, visitor: Visitor): Block | Expression {
        return visitNodeInNewLexicalEnvironment(context, node, visitor, afterVisitBlockOrExpressionInNewLexicalEnvironment);
    }
    
    /**
      * Visits a ModuleBlock or a ModuleDeclaration in a new lexical scope.
      */
    export function visitModuleBlockOrModuleDeclarationInNewLexicalScope(context: VisitorContext, node: ModuleBlock | ModuleDeclaration, visitor: Visitor): ModuleBlock | ModuleDeclaration {
        return visitNodeInNewLexicalEnvironment(context, node, visitor, afterVisitModuleBlockOrModuleDeclarationInNewLexicalEnvironment);
    }
    
    /**
      * Visits a node that starts a new lexical environment.
      */
    function visitNodeInNewLexicalEnvironment<TNode extends Node>(context: VisitorContext, node: TNode, visitor: Visitor, afterVisit: (visited: TNode, statements: Statement[]) => TNode): TNode {
        // When we visit a node that starts a new lexical environment, there is a possibility
        // that a new subtree will be returned that may have declared new temporary variables
        // or needed to hoist function declarations (such as in a downlevel generator).
        //
        // To support this, we keep track of temp flags in the `VisitorContext`
        // along with arrays for any hoisted variable declarations or function
        // declarations. We save the context from the caller and restore it
        // at the end of the function call as we descend into a tree.
        //
        // The `afterVisit` callback is used to verify that the result of visiting the node
        // is consistent with the expected return value, as `Visitor` is generally
        // untyped and could return any `Node` subtype. The `afterVisit` callback is also
        // used to specialize how hoisted declarations should be merged into the visited
        // node.
        
        // Save and reset temp flags and hoisted declarations for the lexical environment
        context.pushLexicalEnvironment();
        
        // Visit the block or expression
        let visited = <TNode>visit(context, node, visitor);

        // If the visited node differs from the original node, or we declared new hoisted
        // declarations in this lexical environment, we should call the `afterVisit` callback.
        let hoistedVariableDeclarations = context.getHoistedVariableDeclarations();
        let hoistedFunctionDeclarations = context.getHoistedFunctionDeclarations();
        if (!visited || visited !== node || hoistedVariableDeclarations || hoistedFunctionDeclarations) {
            // If there were any new hoisted declarations added in this lexical environment, we should 
            // include them in the statments we pass to the `afterVisit` callback.
            let statements: Statement[];
            if (hoistedVariableDeclarations || hoistedFunctionDeclarations) {
                statements = [];
                if (hoistedVariableDeclarations) {
                    statements.push(factory.createVariableStatement(factory.createVariableDeclarationList(hoistedVariableDeclarations)));
                }
                if (hoistedFunctionDeclarations) {
                    statements.push(...hoistedFunctionDeclarations);
                }
            }
            
            // Perform any assertions and merge generated statements with the visited node.
            visited = afterVisit(visited, statements);
        }
        
        // Restore temp flags and hoisted declarations from the caller
        context.popLexicalEnvironment();
        return visited;
    }

    function afterVisitBlockInNewLexicalEnvironment(visited: Block, statements: Statement[]): Block {
        Debug.assert(!visited || isBlock(visited), "Wrong node kind after visit.");
        
        let merged: Block;
        if (statements) {
            if (visited) {
                merged = factory.updateBlock(visited, [
                    ...statements,
                    ...visited.statements
                ]);
            }
            else {
                merged = factory.createBlock(statements);
            }
        }
        
        return merged || visited;
    }

    function afterVisitBlockOrExpressionInNewLexicalEnvironment(visited: Block | Expression, statements: Statement[]): Block | Expression {
        Debug.assert(!visited || isBlock(visited) || isExpression(visited), "Wrong node kind after visit.");
        
        let merged: Block | Expression;
        if (statements) {
            if (visited) {
                if (isBlock(visited)) {
                    merged = factory.updateBlock(visited, [
                        ...statements,
                        ...visited.statements
                    ]);
                }
                else {
                    merged = factory.createBlock([
                        ...statements,
                        factory.createReturnStatement(<Expression>visited)
                    ]);
                }
            }
            else {
                merged = factory.createBlock(statements);
            }
        }
        
        return merged || visited;
    }
    
    function afterVisitModuleBlockOrModuleDeclarationInNewLexicalEnvironment(visited: ModuleBlock | ModuleDeclaration, statements: Statement[]): ModuleBlock | ModuleDeclaration {
        Debug.assert(!visited || isModuleBlock(visited) || isModuleDeclaration(visited), "Wrong node kind after visit.");
        
        let merged: ModuleBlock | ModuleDeclaration;
        if (statements) {
            if (visited) {
                if (isModuleBlock(visited)) {
                    merged = factory.updateModuleBlock(visited, [
                        ...statements,
                        ...visited.statements
                    ]);
                }
                else {
                    merged = factory.createModuleBlock([
                        ...statements,
                        factory.cloneNode(visited, /*location*/ visited, /*flags*/ visited.flags | NodeFlags.Export)
                    ]);
                }
            }
            else {
                merged = factory.createModuleBlock(statements);
            }
        }
        
        return merged || visited;
    }
    
    export function visitNodes<T extends Node>(context: VisitorContext, nodes: T[], visitor: Visitor, visitNode: (context: VisitorContext, node: Node, visitor: Visitor) => T): T[] {
        if (!nodes || !visitor) {
            return nodes;
        }

        let updatedNodes: T[];
        //let cacheOffset = 0;
        for (var i = 0; i < nodes.length; i++) {
            let node = nodes[i];
            // if (cache && cache.shouldCachePreviousNodes(node)) {
            //     if (!updatedNodes) {
            //         updatedNodes = nodes.slice(0, i);
            //     }

            //     while (cacheOffset < updatedIndex) {
            //         updatedNodes[cacheOffset] = cache.cacheNode(updatedNodes[cacheOffset]);
            //         cacheOffset++;
            //     }

            //     cacheOffset = updatedIndex;
            // }
            
            let updatedNode = visitNode(context, node, visitor);
            if (updatedNodes || !updatedNode || updatedNode !== node) {
                if (!updatedNodes) {
                    updatedNodes = nodes.slice(0, i);
                }
                if (updatedNode) {
                    updatedNodes.push(updatedNode);
                }
            }
        }

        if (updatedNodes) {
            return factory.createNodeArray(updatedNodes, /*location*/ <NodeArray<T>>nodes);
        }

        return nodes;
    }
    

    export function visitNodeArrayOfStatement(context: VisitorContext, statements: NodeArray<Statement>, visitor: Visitor): NodeArray<Statement> {
        return visitNodeArrayWithStack(context, statements, visitor, visitStatement, pushStatementContext, popStatementContext, getContextStatements);
    }

    function visitNodeArrayWithStack<T extends Node>(context: VisitorContext, nodes: NodeArray<T>, visitor: Visitor, 
        visitNode: (context: VisitorContext, node: T, visitor: Visitor) => T, pushContext: (context: VisitorContext) => void, 
        popContext: (context: VisitorContext) => void, getGeneratedNodes: (context: VisitorContext) => T[]): NodeArray<T> {
        if (!nodes || !visitor) {
            return nodes;
        }
        
        pushContext(context);
        
        let updatedNodes: T[];
        let contextNodes: T[];
        let contextNodesOffset = 0;
        for (let i = 0; i < nodes.length; i++) {
            let node = nodes[i];
            let updatedNode = visitNode(context, node, visitor);
            if (updatedNodes || !updatedNode || updatedNode !== node) {
                if (!updatedNodes) {
                    updatedNodes = nodes.slice(0, i);
                }
                if (contextNodes || (contextNodes = getGeneratedNodes(context))) {
                    while (contextNodesOffset < contextNodes.length) {
                        let contextNode = contextNodes[contextNodesOffset++];
                        if (contextNode) {
                            transform.aggregateTransformFlags(contextNode);
                            updatedNodes.push(contextNode);
                        }
                    }
                }
                if (updatedNode) {
                    updatedNodes.push(updatedNode);
                }
            }
        }

        popContext(context);
        
        return updatedNodes
            ? factory.createNodeArray(updatedNodes, /*location*/ nodes)
            : nodes;
    }
    
    function pushStatementContext(context: VisitorContext) {
        context.pushStatements();
    }
    
    function popStatementContext(context: VisitorContext) {
        context.popStatements();
    }
    
    function getContextStatements(context: VisitorContext) {
        return context.getStatements();
    }
    
    export function needsTransform(node: Node, mask: TransformFlags): boolean {
        return !!(node.transformFlags & mask);
    }
    
    let transformFlags: TransformFlags;
    
    function aggregateChildTransformFlags(child: Node) {
        let saveTransformFlags = transformFlags;
        aggregateTransformFlags(child);
        transformFlags = saveTransformFlags | (transformFlags & ~TransformFlags.ThisNodeFlags);
    }
    
    export function aggregateTransformFlags(node: Node) {
        transformFlags = node.transformFlags;
        if (transformFlags === undefined) {
            forEachChild(node, aggregateChildTransformFlags);
            
            if (node.flags & NodeFlags.Ambient) {
                transformFlags |= TransformFlags.ThisNodeIsTypeScriptAmbientDeclaration;
            }
            
            // Mark transformations needed for each node
            switch (node.kind) {
                case SyntaxKind.PublicKeyword:
                case SyntaxKind.PrivateKeyword:
                case SyntaxKind.ProtectedKeyword:
                case SyntaxKind.AbstractKeyword:
                case SyntaxKind.DeclareKeyword:
                case SyntaxKind.AsyncKeyword:
                case SyntaxKind.ConstKeyword:
                    transformFlags |= TransformFlags.ThisNodeIsTypeScriptAccessibilityModifier
                    break;
                    
                case SyntaxKind.ModuleDeclaration:
                    transformFlags |= TransformFlags.ThisNodeIsTypeScriptModuleDeclaration;
                    break;
                
                case SyntaxKind.ComputedPropertyName:
                    transformFlags |= TransformFlags.ThisNodeIsES6ComputedPropertyName;
                    break;
                    
                case SyntaxKind.TemplateExpression:
                    transformFlags |= TransformFlags.ThisNodeIsES6TemplateExpression;
                    break;
                    
                case SyntaxKind.NoSubstitutionTemplateLiteral:
                    transformFlags |= TransformFlags.ThisNodeIsES6NoSubstitutionTemplateLiteral;
                    break;
                    
                // case SyntaxKind.NumericLiteral:
                //     let sourceFile = getSourceFileOfNode(node);
                //     let firstChar = sourceFile.text.charCodeAt(node.pos);
                //     if (firstChar === CharacterCodes.b 
                //         || firstChar === CharacterCodes.B 
                //         || firstChar === CharacterCodes.o
                //         || firstChar === CharacterCodes.O) {
                //         markTransform(TransformFlags.ThisNodeIsES6BinaryOrOctalLiteralExpression);
                //     }
                //     break;
                    
                case SyntaxKind.Parameter:
                    if ((<ParameterDeclaration>node).questionToken) {
                        transformFlags |= TransformFlags.ThisNodeIsTypeScriptOptionalParameter;
                    }
                    if ((<ParameterDeclaration>node).flags & NodeFlags.AccessibilityModifier) {
                        transformFlags |= TransformFlags.ThisNodeIsTypeScriptParameterPropertyAssignment;
                    }
                    if ((<ParameterDeclaration>node).initializer) {
                        transformFlags |= TransformFlags.ThisNodeIsES6ParameterInitializer;
                    }
                    if ((<ParameterDeclaration>node).dotDotDotToken) {
                        transformFlags |= TransformFlags.ThisNodeIsES6RestParameter;
                    }
                    break;
                
                case SyntaxKind.YieldExpression:
                    transformFlags |= TransformFlags.ThisNodeIsES6Yield;
                    break;
                    
                case SyntaxKind.BinaryExpression:
                    if (isDestructuringAssignment(node)) {
                        transformFlags |= TransformFlags.ThisNodeIsES6DestructuringAssignment;
                    }
                    break;
                    
                case SyntaxKind.TaggedTemplateExpression:
                    transformFlags |= TransformFlags.ThisNodeIsES6TaggedTemplateExpression;
                    break;
                
                case SyntaxKind.ThisKeyword:
                    transformFlags |= TransformFlags.ThisNodeIsThisKeyword;
                    break;
                    
                case SyntaxKind.SpreadElementExpression:
                    transformFlags |= TransformFlags.ThisNodeIsES6SpreadElement;
                    break;
                    
                case SyntaxKind.ShorthandPropertyAssignment:
                    transformFlags |= TransformFlags.ThisNodeIsES6ShorthandPropertyAssignment;
                    break;
                    
                case SyntaxKind.ArrowFunction:
                    transformFlags |= TransformFlags.ThisNodeIsES6ArrowFunction;
                    break;
                    
                case SyntaxKind.FunctionExpression:
                    if ((<FunctionLikeDeclaration>node).asteriskToken) {
                        transformFlags |= TransformFlags.ThisNodeIsES6Generator;
                    }
                    break;
                    
                case SyntaxKind.FunctionDeclaration:
                    if (!(<MethodDeclaration>node).body) {
                        transformFlags |= TransformFlags.ThisNodeIsTypeScriptOverload;
                    }

                    if ((<FunctionLikeDeclaration>node).asteriskToken) {
                        transformFlags |= TransformFlags.ThisNodeIsES6Generator;
                    }
                    if (node.parserContextFlags & ParserContextFlags.Yield) {
                        transformFlags |= TransformFlags.ThisNodeIsHoistedDeclarationInGenerator;
                    }
                    if (node.flags & NodeFlags.Export) {
                        transformFlags |= TransformFlags.ThisNodeIsES6Export;
                    }
                    break;
                    
                case SyntaxKind.ForOfStatement:
                    transformFlags |= TransformFlags.ThisNodeIsES6ForOfStatement;
                    break;
                    
                case SyntaxKind.BreakStatement:
                case SyntaxKind.ContinueStatement:
                case SyntaxKind.ReturnStatement:
                    if (node.parserContextFlags & ParserContextFlags.Yield) {
                        transformFlags |= TransformFlags.ThisNodeIsCompletionStatementInGenerator;
                    }
                    break;
                    
                case SyntaxKind.ObjectBindingPattern:
                case SyntaxKind.ArrayBindingPattern:
                    transformFlags |= TransformFlags.ThisNodeIsES6BindingPattern;
                    break;
                
                case SyntaxKind.VariableDeclarationList:
                    if (node.parserContextFlags & ParserContextFlags.Yield) {
                        transformFlags |= TransformFlags.ThisNodeIsHoistedDeclarationInGenerator;
                    }
                    if (node.flags & (NodeFlags.Let | NodeFlags.Const)) {
                        transformFlags |= TransformFlags.ThisNodeIsES6LetOrConst;
                    }
                    break;
                
                case SyntaxKind.VariableStatement:
                    if (node.flags & NodeFlags.Export) {
                        transformFlags |= TransformFlags.ThisNodeIsES6Export;
                    }
                    break;
                
                case SyntaxKind.Decorator:
                    transformFlags |= TransformFlags.ThisNodeIsTypeScriptDecorator;
                    break;
                    
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.ClassExpression:
                    transformFlags |= TransformFlags.ThisNodeIsES6Class;
                    if (transformFlags & TransformFlags.ContainsTypeScriptClassSyntaxExtension) {
                        transformFlags |= TransformFlags.ThisNodeIsTypeScriptClassWithSyntaxExtensions;
                    }
                    break;

                case SyntaxKind.PropertyDeclaration:
                    transformFlags |= TransformFlags.ThisNodeIsTypeScriptPropertyDeclaration;
                    if (node.flags & NodeFlags.Static && (<PropertyDeclaration>node).initializer) {
                        transformFlags |= TransformFlags.ContainsTypeScriptGeneratedStatements;
                    }
                    
                    break;
                    
                case SyntaxKind.Constructor:
                    if (!(<ConstructorDeclaration>node).body) {
                        transformFlags |= TransformFlags.ThisNodeIsTypeScriptOverload;
                    }
                    break;

                case SyntaxKind.MethodDeclaration:
                    if (!(<MethodDeclaration>node).body) {
                        transformFlags |= TransformFlags.ThisNodeIsTypeScriptOverload;
                    }
                    
                    transformFlags |= TransformFlags.ThisNodeIsES6MethodDeclaration;
                    if ((<FunctionLikeDeclaration>node).asteriskToken) {
                        transformFlags |= TransformFlags.ThisNodeIsES6Generator;
                    }
                    
                    break;
                    
                case SyntaxKind.EnumDeclaration:
                    transformFlags |= TransformFlags.ThisNodeIsTypeScriptEnumDeclaration;
                    break;
                    
                case SyntaxKind.ImportEqualsDeclaration:
                    transformFlags |= TransformFlags.ThisNodeIsTypeScriptImportEqualsDeclaration;
                    break;
                    
                case SyntaxKind.ImportDeclaration:
                    transformFlags |= TransformFlags.ThisNodeIsES6ImportDeclaration;
                    break;
                    
                case SyntaxKind.ExportAssignment:
                    transformFlags |= TransformFlags.ThisNodeIsTypeScriptExportAssignmentDeclaration;
                    break;
                    
                case SyntaxKind.ExportDeclaration:
                    transformFlags |= TransformFlags.ThisNodeIsES6ExportDeclaration;
                    break;
            }
            
            node.transformFlags = transformFlags;
            
            // Exclude flags that should not escape the lexical environment.
            if (isArrowFunction(node)) {
                transformFlags &= ~TransformFlags.ArrowFunctionScopeExcludes;
            }
            else if (isFunctionLike(node)) {
                transformFlags &= ~TransformFlags.FunctionScopeExcludes;
            }
            else if (isClassLike(node)) {
                transformFlags &= ~TransformFlags.ClassScopeExcludes;
            }
            else if (nodeStartsNewLexicalEnvironment(node)) {
                transformFlags &= ~TransformFlags.ModuleScopeExcludes;
            }
        }
    }
}