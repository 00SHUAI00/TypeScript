=== tests/cases/conformance/types/rest/differenceType.ts ===
type A = { a };
>A : Symbol(A, Decl(differenceType.ts, 0, 0))
>a : Symbol(a, Decl(differenceType.ts, 0, 10))

type Ab = { a; b };
>Ab : Symbol(Ab, Decl(differenceType.ts, 0, 15))
>a : Symbol(a, Decl(differenceType.ts, 1, 11))
>b : Symbol(b, Decl(differenceType.ts, 1, 14))

let nothing: A - 'a';
>nothing : Symbol(nothing, Decl(differenceType.ts, 2, 3))
>A : Symbol(A, Decl(differenceType.ts, 0, 0))

let none: Ab - 'a' | 'b';
>none : Symbol(none, Decl(differenceType.ts, 3, 3))
>Ab : Symbol(Ab, Decl(differenceType.ts, 0, 15))

let over: A - 'a' | 'b';
>over : Symbol(over, Decl(differenceType.ts, 4, 3))
>A : Symbol(A, Decl(differenceType.ts, 0, 0))

let under: Ab - 'a';
>under : Symbol(under, Decl(differenceType.ts, 5, 3))
>Ab : Symbol(Ab, Decl(differenceType.ts, 0, 15))

let partial: Ab - 'b' | 'd';
>partial : Symbol(partial, Decl(differenceType.ts, 6, 3))
>Ab : Symbol(Ab, Decl(differenceType.ts, 0, 15))

let empty: Ab - 'a' | 'b';
>empty : Symbol(empty, Decl(differenceType.ts, 7, 3))
>Ab : Symbol(Ab, Decl(differenceType.ts, 0, 15))

let nope: {} - string;
>nope : Symbol(nope, Decl(differenceType.ts, 8, 3))

let nope2: Ab - string;
>nope2 : Symbol(nope2, Decl(differenceType.ts, 9, 3))
>Ab : Symbol(Ab, Decl(differenceType.ts, 0, 15))

let nope3: {} - 'a' | 'b';
>nope3 : Symbol(nope3, Decl(differenceType.ts, 10, 3))

type Abcd = { a; b; c; d }
>Abcd : Symbol(Abcd, Decl(differenceType.ts, 10, 26))
>a : Symbol(a, Decl(differenceType.ts, 12, 13))
>b : Symbol(b, Decl(differenceType.ts, 12, 16))
>c : Symbol(c, Decl(differenceType.ts, 12, 19))
>d : Symbol(d, Decl(differenceType.ts, 12, 22))

function f<T,U extends keyof Abcd, V>(t: T, u: U, v: V): T - U {
>f : Symbol(f, Decl(differenceType.ts, 12, 26))
>T : Symbol(T, Decl(differenceType.ts, 14, 11))
>U : Symbol(U, Decl(differenceType.ts, 14, 13))
>Abcd : Symbol(Abcd, Decl(differenceType.ts, 10, 26))
>V : Symbol(V, Decl(differenceType.ts, 14, 34))
>t : Symbol(t, Decl(differenceType.ts, 14, 38))
>T : Symbol(T, Decl(differenceType.ts, 14, 11))
>u : Symbol(u, Decl(differenceType.ts, 14, 43))
>U : Symbol(U, Decl(differenceType.ts, 14, 13))
>v : Symbol(v, Decl(differenceType.ts, 14, 49))
>V : Symbol(V, Decl(differenceType.ts, 14, 34))
>T : Symbol(T, Decl(differenceType.ts, 14, 11))
>U : Symbol(U, Decl(differenceType.ts, 14, 13))

    let vsubtkey: V - keyof T;
>vsubtkey : Symbol(vsubtkey, Decl(differenceType.ts, 15, 7))
>V : Symbol(V, Decl(differenceType.ts, 14, 34))
>T : Symbol(T, Decl(differenceType.ts, 14, 11))

    vsubtkey = vsubtkey;
>vsubtkey : Symbol(vsubtkey, Decl(differenceType.ts, 15, 7))
>vsubtkey : Symbol(vsubtkey, Decl(differenceType.ts, 15, 7))

    let tsubu: T - U;
>tsubu : Symbol(tsubu, Decl(differenceType.ts, 18, 7))
>T : Symbol(T, Decl(differenceType.ts, 14, 11))
>U : Symbol(U, Decl(differenceType.ts, 14, 13))

    return tsubu;
>tsubu : Symbol(tsubu, Decl(differenceType.ts, 18, 7))
}

const x = f<Ab, 'b' | 'd', A>({ a: 1, b: 2 }, 'b', { a: 3 })
>x : Symbol(x, Decl(differenceType.ts, 22, 5))
>f : Symbol(f, Decl(differenceType.ts, 12, 26))
>Ab : Symbol(Ab, Decl(differenceType.ts, 0, 15))
>A : Symbol(A, Decl(differenceType.ts, 0, 0))
>a : Symbol(a, Decl(differenceType.ts, 22, 31))
>b : Symbol(b, Decl(differenceType.ts, 22, 37))
>a : Symbol(a, Decl(differenceType.ts, 22, 52))

const y = f({ a: 1, b: 2 }, 'b', { a: 3 })
>y : Symbol(y, Decl(differenceType.ts, 23, 5))
>f : Symbol(f, Decl(differenceType.ts, 12, 26))
>a : Symbol(a, Decl(differenceType.ts, 23, 13))
>b : Symbol(b, Decl(differenceType.ts, 23, 19))
>a : Symbol(a, Decl(differenceType.ts, 23, 34))

