=== tests/cases/conformance/types/thisType/thisTypeInObjectLiterals2.ts ===

// In methods of an object literal with no contextual type, 'this' has the type
// of the object literal.

let obj1 = {
>obj1 : { a: number; f(): number; b: string; c: { g(): void; }; readonly d: number; e: string; }
>{    a: 1,    f() {        return this.a;    },    b: "hello",    c: {        g() {            this.g();        }    },    get d() {        return this.a;    },    get e() {        return this.b;    },    set e(value) {        this.b = value;    }} : { a: number; f(): number; b: string; c: { g(): void; }; readonly d: number; e: string; }

    a: 1,
>a : number
>1 : 1

    f() {
>f : () => number

        return this.a;
>this.a : number
>this : { a: number; f(): number; b: string; c: { g(): void; }; readonly d: number; e: string; }
>a : number

    },
    b: "hello",
>b : string
>"hello" : "hello"

    c: {
>c : { g(): void; }
>{        g() {            this.g();        }    } : { g(): void; }

        g() {
>g : () => void

            this.g();
>this.g() : void
>this.g : () => void
>this : { g(): void; }
>g : () => void
        }
    },
    get d() {
>d : number

        return this.a;
>this.a : number
>this : { a: number; f(): number; b: string; c: { g(): void; }; readonly d: number; e: string; }
>a : number

    },
    get e() {
>e : string

        return this.b;
>this.b : string
>this : { a: number; f(): number; b: string; c: { g(): void; }; readonly d: number; e: string; }
>b : string

    },
    set e(value) {
>e : string
>value : string

        this.b = value;
>this.b = value : string
>this.b : string
>this : { a: number; f(): number; b: string; c: { g(): void; }; readonly d: number; e: string; }
>b : string
>value : string
    }
};

// In methods of an object literal with a contextual type, 'this' has the
// contextual type.

type Point = {
>Point : Point

    x: number;
>x : number

    y: number;
>y : number

    moveBy(dx: number, dy: number): void;
>moveBy : (dx: number, dy: number) => void
>dx : number
>dy : number
}

let p1: Point = {
>p1 : Point
>Point : Point
>{    x: 10,    y: 20,    moveBy(dx, dy) {        this.x += dx;        this.y += dy;    }} : { x: number; y: number; moveBy(dx: number, dy: number): void; }

    x: 10,
>x : number
>10 : 10

    y: 20,
>y : number
>20 : 20

    moveBy(dx, dy) {
>moveBy : (dx: number, dy: number) => void
>dx : number
>dy : number

        this.x += dx;
>this.x += dx : number
>this.x : number
>this : Point
>x : number
>dx : number

        this.y += dy;
>this.y += dy : number
>this.y : number
>this : Point
>y : number
>dy : number
    }
};

declare function f1(p: Point): void;
>f1 : (p: Point) => void
>p : Point
>Point : Point

f1({
>f1({    x: 10,    y: 20,    moveBy(dx, dy) {        this.x += dx;        this.y += dy;    }}) : void
>f1 : (p: Point) => void
>{    x: 10,    y: 20,    moveBy(dx, dy) {        this.x += dx;        this.y += dy;    }} : { x: number; y: number; moveBy(dx: number, dy: number): void; }

    x: 10,
>x : number
>10 : 10

    y: 20,
>y : number
>20 : 20

    moveBy(dx, dy) {
>moveBy : (dx: number, dy: number) => void
>dx : number
>dy : number

        this.x += dx;
>this.x += dx : number
>this.x : number
>this : Point
>x : number
>dx : number

        this.y += dy;
>this.y += dy : number
>this.y : number
>this : Point
>y : number
>dy : number
    }
});

// In methods of an object literal with a contextual type that includes some
// ThisType<T>, 'this' is of type T.

type ObjectDescriptor<D, M> = {
>ObjectDescriptor : ObjectDescriptor<D, M>
>D : D
>M : M

    data?: D;
>data : D
>D : D

    methods?: M & ThisType<D & M>;  // Type of 'this' in methods is D & M
>methods : M & ThisType<D & M>
>M : M
>ThisType : ThisType<T>
>D : D
>M : M
}

declare function makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M;
>makeObject : <D, M>(desc: ObjectDescriptor<D, M>) => D & M
>D : D
>M : M
>desc : ObjectDescriptor<D, M>
>ObjectDescriptor : ObjectDescriptor<D, M>
>D : D
>M : M
>D : D
>M : M

let x1 = makeObject({
>x1 : { x: number; y: number; } & { moveBy(dx: number, dy: number): void; }
>makeObject({    data: { x: 0, y: 0 },    methods: {        moveBy(dx: number, dy: number) {            this.x += dx;  // Strongly typed this            this.y += dy;  // Strongly typed this        }    }}) : { x: number; y: number; } & { moveBy(dx: number, dy: number): void; }
>makeObject : <D, M>(desc: ObjectDescriptor<D, M>) => D & M
>{    data: { x: 0, y: 0 },    methods: {        moveBy(dx: number, dy: number) {            this.x += dx;  // Strongly typed this            this.y += dy;  // Strongly typed this        }    }} : { data: { x: number; y: number; }; methods: { moveBy(dx: number, dy: number): void; }; }

    data: { x: 0, y: 0 },
>data : { x: number; y: number; }
>{ x: 0, y: 0 } : { x: number; y: number; }
>x : number
>0 : 0
>y : number
>0 : 0

    methods: {
>methods : { moveBy(dx: number, dy: number): void; }
>{        moveBy(dx: number, dy: number) {            this.x += dx;  // Strongly typed this            this.y += dy;  // Strongly typed this        }    } : { moveBy(dx: number, dy: number): void; }

        moveBy(dx: number, dy: number) {
>moveBy : (dx: number, dy: number) => void
>dx : number
>dy : number

            this.x += dx;  // Strongly typed this
>this.x += dx : number
>this.x : number
>this : { x: number; y: number; } & { moveBy(dx: number, dy: number): void; }
>x : number
>dx : number

            this.y += dy;  // Strongly typed this
>this.y += dy : number
>this.y : number
>this : { x: number; y: number; } & { moveBy(dx: number, dy: number): void; }
>y : number
>dy : number
        }
    }
});

// In methods contained in an object literal with a contextual type that includes
// some ThisType<T>, 'this' is of type T.

type ObjectDescriptor2<D, M> = ThisType<D & M> & {
>ObjectDescriptor2 : ObjectDescriptor2<D, M>
>D : D
>M : M
>ThisType : ThisType<T>
>D : D
>M : M

    data?: D;
>data : D
>D : D

    methods?: M;
>methods : M
>M : M
}

declare function makeObject2<D, M>(desc: ObjectDescriptor<D, M>): D & M;
>makeObject2 : <D, M>(desc: ObjectDescriptor<D, M>) => D & M
>D : D
>M : M
>desc : ObjectDescriptor<D, M>
>ObjectDescriptor : ObjectDescriptor<D, M>
>D : D
>M : M
>D : D
>M : M

let x2 = makeObject2({
>x2 : { x: number; y: number; } & { moveBy(dx: number, dy: number): void; }
>makeObject2({    data: { x: 0, y: 0 },    methods: {        moveBy(dx: number, dy: number) {            this.x += dx;  // Strongly typed this            this.y += dy;  // Strongly typed this        }    }}) : { x: number; y: number; } & { moveBy(dx: number, dy: number): void; }
>makeObject2 : <D, M>(desc: ObjectDescriptor<D, M>) => D & M
>{    data: { x: 0, y: 0 },    methods: {        moveBy(dx: number, dy: number) {            this.x += dx;  // Strongly typed this            this.y += dy;  // Strongly typed this        }    }} : { data: { x: number; y: number; }; methods: { moveBy(dx: number, dy: number): void; }; }

    data: { x: 0, y: 0 },
>data : { x: number; y: number; }
>{ x: 0, y: 0 } : { x: number; y: number; }
>x : number
>0 : 0
>y : number
>0 : 0

    methods: {
>methods : { moveBy(dx: number, dy: number): void; }
>{        moveBy(dx: number, dy: number) {            this.x += dx;  // Strongly typed this            this.y += dy;  // Strongly typed this        }    } : { moveBy(dx: number, dy: number): void; }

        moveBy(dx: number, dy: number) {
>moveBy : (dx: number, dy: number) => void
>dx : number
>dy : number

            this.x += dx;  // Strongly typed this
>this.x += dx : number
>this.x : number
>this : { x: number; y: number; } & { moveBy(dx: number, dy: number): void; }
>x : number
>dx : number

            this.y += dy;  // Strongly typed this
>this.y += dy : number
>this.y : number
>this : { x: number; y: number; } & { moveBy(dx: number, dy: number): void; }
>y : number
>dy : number
        }
    }
});

// Proof of concept for typing of Vue.js

type Accessors<T> = { [K in keyof T]: (() => T[K]) | Computed<T[K]> };
>Accessors : Accessors<T>
>T : T
>K : K
>T : T
>T : T
>K : K
>Computed : Computed<T>
>T : T
>K : K

type Dictionary<T> = { [x: string]: T }
>Dictionary : Dictionary<T>
>T : T
>x : string
>T : T

type Computed<T> = {
>Computed : Computed<T>
>T : T

    get?(): T;
>get : () => T
>T : T

    set?(value: T): void;
>set : (value: T) => void
>value : T
>T : T
}

type VueOptions<D, M, P> = ThisType<D & M & P> & {
>VueOptions : VueOptions<D, M, P>
>D : D
>M : M
>P : P
>ThisType : ThisType<T>
>D : D
>M : M
>P : P

    data?: D | (() => D);
>data : D | (() => D)
>D : D
>D : D

    methods?: M;
>methods : M
>M : M

    computed?: Accessors<P>;
>computed : Accessors<P>
>Accessors : Accessors<T>
>P : P
}

declare const Vue: new <D, M, P>(options: VueOptions<D, M, P>) => D & M & P;
>Vue : new <D, M, P>(options: VueOptions<D, M, P>) => D & M & P
>D : D
>M : M
>P : P
>options : VueOptions<D, M, P>
>VueOptions : VueOptions<D, M, P>
>D : D
>M : M
>P : P
>D : D
>M : M
>P : P

let vue = new Vue({
>vue : { x: number; y: number; } & { f(x: string): number; } & { test: number; hello: string; }
>new Vue({    data: () => ({ x: 1, y: 2 }),    methods: {        f(x: string) {            return this.x;        }    },    computed: {        test(): number {            return this.x;        },        hello: {            get() {                return "hi";            },            set(value: string) {            }        }    }}) : { x: number; y: number; } & { f(x: string): number; } & { test: number; hello: string; }
>Vue : new <D, M, P>(options: VueOptions<D, M, P>) => D & M & P
>{    data: () => ({ x: 1, y: 2 }),    methods: {        f(x: string) {            return this.x;        }    },    computed: {        test(): number {            return this.x;        },        hello: {            get() {                return "hi";            },            set(value: string) {            }        }    }} : { data: () => { x: number; y: number; }; methods: { f(x: string): number; }; computed: { test(): number; hello: { get(): string; set(value: string): void; }; }; }

    data: () => ({ x: 1, y: 2 }),
>data : () => { x: number; y: number; }
>() => ({ x: 1, y: 2 }) : () => { x: number; y: number; }
>({ x: 1, y: 2 }) : { x: number; y: number; }
>{ x: 1, y: 2 } : { x: number; y: number; }
>x : number
>1 : 1
>y : number
>2 : 2

    methods: {
>methods : { f(x: string): number; }
>{        f(x: string) {            return this.x;        }    } : { f(x: string): number; }

        f(x: string) {
>f : (x: string) => number
>x : string

            return this.x;
>this.x : number
>this : { x: number; y: number; } & { f(x: string): number; } & { test: number; hello: string; }
>x : number
        }
    },
    computed: {
>computed : { test(): number; hello: { get(): string; set(value: string): void; }; }
>{        test(): number {            return this.x;        },        hello: {            get() {                return "hi";            },            set(value: string) {            }        }    } : { test(): number; hello: { get(): string; set(value: string): void; }; }

        test(): number {
>test : () => number

            return this.x;
>this.x : number
>this : { x: number; y: number; } & { f(x: string): number; } & { test: number; hello: string; }
>x : number

        },
        hello: {
>hello : { get(): string; set(value: string): void; }
>{            get() {                return "hi";            },            set(value: string) {            }        } : { get(): string; set(value: string): void; }

            get() {
>get : () => string

                return "hi";
>"hi" : "hi"

            },
            set(value: string) {
>set : (value: string) => void
>value : string
            }
        }
    }
});

vue;
>vue : { x: number; y: number; } & { f(x: string): number; } & { test: number; hello: string; }

vue.x;
>vue.x : number
>vue : { x: number; y: number; } & { f(x: string): number; } & { test: number; hello: string; }
>x : number

vue.f("abc");
>vue.f("abc") : number
>vue.f : (x: string) => number
>vue : { x: number; y: number; } & { f(x: string): number; } & { test: number; hello: string; }
>f : (x: string) => number
>"abc" : "abc"

vue.test;
>vue.test : number
>vue : { x: number; y: number; } & { f(x: string): number; } & { test: number; hello: string; }
>test : number

vue.hello;
>vue.hello : string
>vue : { x: number; y: number; } & { f(x: string): number; } & { test: number; hello: string; }
>hello : string

