=== tests/cases/compiler/constIndexedAccess.ts ===

const enum numbers {
>numbers : Symbol(numbers, Decl(constIndexedAccess.ts, 0, 0))

	zero,
>zero : Symbol(numbers.zero, Decl(constIndexedAccess.ts, 1, 20))

	one
>one : Symbol(numbers.one, Decl(constIndexedAccess.ts, 2, 6))
}

interface indexAccess {
>indexAccess : Symbol(indexAccess, Decl(constIndexedAccess.ts, 4, 1))

	0: string;
	1: number;
}

let test: indexAccess;
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>indexAccess : Symbol(indexAccess, Decl(constIndexedAccess.ts, 4, 1))

let s = test[0];
>s : Symbol(s, Decl(constIndexedAccess.ts, 13, 3))
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>0 : Symbol(indexAccess.0, Decl(constIndexedAccess.ts, 6, 23))

let n = test[1];
>n : Symbol(n, Decl(constIndexedAccess.ts, 14, 3))
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>1 : Symbol(indexAccess.1, Decl(constIndexedAccess.ts, 7, 11))

let s1 = test[numbers.zero];
>s1 : Symbol(s1, Decl(constIndexedAccess.ts, 16, 3))
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>numbers.zero : Symbol(numbers.zero, Decl(constIndexedAccess.ts, 1, 20))
>numbers : Symbol(numbers, Decl(constIndexedAccess.ts, 0, 0))
>zero : Symbol(numbers.zero, Decl(constIndexedAccess.ts, 1, 20))

let n1 = test[numbers.one];
>n1 : Symbol(n1, Decl(constIndexedAccess.ts, 17, 3))
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>numbers.one : Symbol(numbers.one, Decl(constIndexedAccess.ts, 2, 6))
>numbers : Symbol(numbers, Decl(constIndexedAccess.ts, 0, 0))
>one : Symbol(numbers.one, Decl(constIndexedAccess.ts, 2, 6))

/*
TODO: revisit with const propagation

const zero = 0;
const one = 1;

let s2 = test[zero];
let n2 = test[one];

const zeroRef = zero;
const oneRef = one;

let s3 = test[zeroRef];
let n3 = test[oneRef];

const zeroRefEnum = numbers.zero;
const oneRefEnum = numbers.one;

let s4 = test[zeroRefEnum];
let n4 = test[oneRefEnum];
*/
