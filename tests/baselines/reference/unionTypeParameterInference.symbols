=== tests/cases/compiler/unionTypeParameterInference.ts ===
interface Foo<T> { prop: T; }
>Foo : Symbol(Foo, Decl(unionTypeParameterInference.ts, 0, 0))
>T : Symbol(T, Decl(unionTypeParameterInference.ts, 0, 14))
>prop : Symbol(prop, Decl(unionTypeParameterInference.ts, 0, 18))
>T : Symbol(T, Decl(unionTypeParameterInference.ts, 0, 14))

declare function lift<U>(value: U | Foo<U>): Foo<U>;
>lift : Symbol(lift, Decl(unionTypeParameterInference.ts, 0, 29))
>U : Symbol(U, Decl(unionTypeParameterInference.ts, 2, 22))
>value : Symbol(value, Decl(unionTypeParameterInference.ts, 2, 25))
>U : Symbol(U, Decl(unionTypeParameterInference.ts, 2, 22))
>Foo : Symbol(Foo, Decl(unionTypeParameterInference.ts, 0, 0))
>U : Symbol(U, Decl(unionTypeParameterInference.ts, 2, 22))
>Foo : Symbol(Foo, Decl(unionTypeParameterInference.ts, 0, 0))
>U : Symbol(U, Decl(unionTypeParameterInference.ts, 2, 22))

function unlift<U>(value: U | Foo<U>): U {
>unlift : Symbol(unlift, Decl(unionTypeParameterInference.ts, 2, 52))
>U : Symbol(U, Decl(unionTypeParameterInference.ts, 4, 16))
>value : Symbol(value, Decl(unionTypeParameterInference.ts, 4, 19))
>U : Symbol(U, Decl(unionTypeParameterInference.ts, 4, 16))
>Foo : Symbol(Foo, Decl(unionTypeParameterInference.ts, 0, 0))
>U : Symbol(U, Decl(unionTypeParameterInference.ts, 4, 16))
>U : Symbol(U, Decl(unionTypeParameterInference.ts, 4, 16))

    return lift(value).prop; // error TS2322: Type '{}' is not assignable to type 'U'.
>lift(value).prop : Symbol(Foo.prop, Decl(unionTypeParameterInference.ts, 0, 18))
>lift : Symbol(lift, Decl(unionTypeParameterInference.ts, 0, 29))
>value : Symbol(value, Decl(unionTypeParameterInference.ts, 4, 19))
>prop : Symbol(Foo.prop, Decl(unionTypeParameterInference.ts, 0, 18))
}

