=== tests/cases/conformance/types/spread/objectSpreadIntersection.ts ===
function iteratedUnionIntersection<T, U, V>(t: T, u: U, v: V): void {
>iteratedUnionIntersection : Symbol(iteratedUnionIntersection, Decl(objectSpreadIntersection.ts, 0, 0))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 0, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 0, 40))
>t : Symbol(t, Decl(objectSpreadIntersection.ts, 0, 44))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 0, 35))
>u : Symbol(u, Decl(objectSpreadIntersection.ts, 0, 49))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>v : Symbol(v, Decl(objectSpreadIntersection.ts, 0, 55))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 0, 40))

    let tu: T | U;
>tu : Symbol(tu, Decl(objectSpreadIntersection.ts, 1, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 0, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))

    let uv: U & V;
>uv : Symbol(uv, Decl(objectSpreadIntersection.ts, 2, 7))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 0, 40))

    let result = { ...tu, ...uv, id: 'foo' };
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 3, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 3, 32))

    let expected: ({ ...T, ...U, id: string } & { ...T, ...V, id: string }) | ({ ...U, id: string } & { ...U, ...V, id: string });
>expected : Symbol(expected, Decl(objectSpreadIntersection.ts, 4, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 0, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 4, 32))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 0, 35))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 0, 40))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 4, 61))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 4, 86))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 0, 40))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 4, 115))

    let assignable: { ...(T | U), ...(U & V), id: string } = result;
>assignable : Symbol(assignable, Decl(objectSpreadIntersection.ts, 5, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 0, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 0, 40))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 5, 45))
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 3, 7))
}
// concrete types work
interface A1 { a: number }
>A1 : Symbol(A1, Decl(objectSpreadIntersection.ts, 6, 1))
>a : Symbol(A1.a, Decl(objectSpreadIntersection.ts, 8, 14))

interface A2 { a: string }
>A2 : Symbol(A2, Decl(objectSpreadIntersection.ts, 8, 26))
>a : Symbol(A2.a, Decl(objectSpreadIntersection.ts, 9, 14))

let a12: A1 & A2;
>a12 : Symbol(a12, Decl(objectSpreadIntersection.ts, 10, 3))
>A1 : Symbol(A1, Decl(objectSpreadIntersection.ts, 6, 1))
>A2 : Symbol(A2, Decl(objectSpreadIntersection.ts, 8, 26))

let result = { ...a12 };
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 11, 3))

let sn: number & string = result.a;
>sn : Symbol(sn, Decl(objectSpreadIntersection.ts, 12, 3))
>result.a : Symbol(a, Decl(objectSpreadIntersection.ts, 8, 14), Decl(objectSpreadIntersection.ts, 9, 14))
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 11, 3))
>a : Symbol(a, Decl(objectSpreadIntersection.ts, 8, 14), Decl(objectSpreadIntersection.ts, 9, 14))

let assignable: { ...(A1 & A2) } = result;
>assignable : Symbol(assignable, Decl(objectSpreadIntersection.ts, 13, 3))
>A1 : Symbol(A1, Decl(objectSpreadIntersection.ts, 6, 1))
>A2 : Symbol(A2, Decl(objectSpreadIntersection.ts, 8, 26))
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 11, 3))

function tripleIntersection<T, U, V>(t: T, u: U, v: V): void {
>tripleIntersection : Symbol(tripleIntersection, Decl(objectSpreadIntersection.ts, 13, 42))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 15, 28))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 15, 30))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 15, 33))
>t : Symbol(t, Decl(objectSpreadIntersection.ts, 15, 37))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 15, 28))
>u : Symbol(u, Decl(objectSpreadIntersection.ts, 15, 42))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 15, 30))
>v : Symbol(v, Decl(objectSpreadIntersection.ts, 15, 48))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 15, 33))

    let tuv: T & U & V;
>tuv : Symbol(tuv, Decl(objectSpreadIntersection.ts, 16, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 15, 28))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 15, 30))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 15, 33))

    let result = { ...tuv, id: 'bar' };
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 17, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 17, 26))

    let expected: { ...T, id: string } & { ...U, id: string } & { ...V, id: string } = result;
>expected : Symbol(expected, Decl(objectSpreadIntersection.ts, 18, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 15, 28))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 18, 25))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 15, 30))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 18, 48))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 15, 33))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 18, 71))
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 17, 7))

    let assignable: { ...(T & U & V), id: string } = result;
>assignable : Symbol(assignable, Decl(objectSpreadIntersection.ts, 19, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 15, 28))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 15, 30))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 15, 33))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 19, 37))
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 17, 7))
}
function iteratedDoubleIntersection<T, U, V>(t: T, u: U, v: V): void {
>iteratedDoubleIntersection : Symbol(iteratedDoubleIntersection, Decl(objectSpreadIntersection.ts, 20, 1))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 21, 36))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 21, 41))
>t : Symbol(t, Decl(objectSpreadIntersection.ts, 21, 45))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 21, 36))
>u : Symbol(u, Decl(objectSpreadIntersection.ts, 21, 50))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>v : Symbol(v, Decl(objectSpreadIntersection.ts, 21, 56))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 21, 41))

    let tu: T & U;
>tu : Symbol(tu, Decl(objectSpreadIntersection.ts, 22, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 21, 36))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))

    let uv: U & V;
>uv : Symbol(uv, Decl(objectSpreadIntersection.ts, 23, 7))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 21, 41))

    let result = { ...tu, ...uv, id: 'baz' };
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 24, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 24, 32))

    let expected: { ...T, ...U, id: string } & { ...T, ...V, id: string } & { ...U, id: string } & { ...U, ...V, id: string };
>expected : Symbol(expected, Decl(objectSpreadIntersection.ts, 25, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 21, 36))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 25, 31))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 21, 36))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 21, 41))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 25, 60))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 25, 83))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 21, 41))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 25, 112))

    let assignable: { ...(T & U), ...(U & V), id: string } = result;
>assignable : Symbol(assignable, Decl(objectSpreadIntersection.ts, 26, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 21, 36))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 21, 41))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 26, 45))
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 24, 7))
}
function iteratedIntersectionUnion<T, U, V>(t: T, u: U, v: V): void {
>iteratedIntersectionUnion : Symbol(iteratedIntersectionUnion, Decl(objectSpreadIntersection.ts, 27, 1))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 28, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 28, 40))
>t : Symbol(t, Decl(objectSpreadIntersection.ts, 28, 44))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 28, 35))
>u : Symbol(u, Decl(objectSpreadIntersection.ts, 28, 49))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>v : Symbol(v, Decl(objectSpreadIntersection.ts, 28, 55))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 28, 40))

    let tu: T & U;
>tu : Symbol(tu, Decl(objectSpreadIntersection.ts, 29, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 28, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))

    let uv: U | V;
>uv : Symbol(uv, Decl(objectSpreadIntersection.ts, 30, 7))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 28, 40))

    let result = { ...tu, ...uv, id: 'qux' };
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 31, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 31, 32))

    let expected: ({ ...T, ...U, id: string } & { ...U, id: string }) | ({ ...T, ...V, id: string } & { ...U, ...V, id: string });
>expected : Symbol(expected, Decl(objectSpreadIntersection.ts, 32, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 28, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 32, 32))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 32, 55))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 28, 35))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 28, 40))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 32, 86))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 28, 40))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 32, 115))

    let assignable: { ...(T & U), ...(U | V), id: string } = result;
>assignable : Symbol(assignable, Decl(objectSpreadIntersection.ts, 33, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 28, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 28, 40))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 33, 45))
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 31, 7))
}


