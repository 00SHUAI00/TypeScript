=== tests/cases/compiler/emitDecoratorMetadata_restArgs.ts ===

declare const MyClassDecorator: ClassDecorator;
>MyClassDecorator : <TFunction extends Function>(target: TFunction) => void | TFunction
>ClassDecorator : <TFunction extends Function>(target: TFunction) => void | TFunction

declare const MyMethodDecorator: MethodDecorator;
>MyMethodDecorator : <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => void | TypedPropertyDescriptor<T>
>MethodDecorator : <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => void | TypedPropertyDescriptor<T>

@MyClassDecorator
>MyClassDecorator : <TFunction extends Function>(target: TFunction) => void | TFunction

class A {
>A : A

    constructor(...args) {}
>args : any[]

    @MyMethodDecorator
>MyMethodDecorator : <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => void | TypedPropertyDescriptor<T>

    method(...args) {}
>method : (...args: any[]) => void
>args : any[]
}

@MyClassDecorator
>MyClassDecorator : <TFunction extends Function>(target: TFunction) => void | TFunction

class B {
>B : B

    constructor(...args: number[]) {}
>args : number[]

    @MyMethodDecorator
>MyMethodDecorator : <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => void | TypedPropertyDescriptor<T>

    method(...args: string[]) {}
>method : (...args: string[]) => void
>args : string[]
}

