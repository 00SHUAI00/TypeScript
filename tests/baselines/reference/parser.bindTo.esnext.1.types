=== tests/cases/conformance/parser/esnext/parser.bindTo.esnext.1.ts ===
// single argument
declare function f1(this: number): string;
>f1 : (this: number) => string
>this : number

1 :: f1;
>f1 : any

1 :: f1();
>1 :: f1() : string
>f1 : any

// multiple steps
declare function f2(this: string): boolean;
>f2 : (this: string) => boolean
>this : string

1 :: f1() :: f2();
>1 :: f1() :: f2() : boolean
>1 :: f1() : string
>f1 : any
>f2 : any

// use cases
declare function map<T, U>(this: Iterable<T>, cb: (value: T) => U): Iterable<U>;
>map : <T, U>(this: Iterable<T>, cb: (value: T) => U) => Iterable<U>
>T : T
>U : U
>this : Iterable<T>
>Iterable : Iterable<T>
>T : T
>cb : (value: T) => U
>value : T
>T : T
>U : U
>Iterable : Iterable<T>
>U : U

declare function filter<T>(this: Iterable<T>, cb: (value: T) => boolean): Iterable<T>;
>filter : <T>(this: Iterable<T>, cb: (value: T) => boolean) => Iterable<T>
>T : T
>this : Iterable<T>
>Iterable : Iterable<T>
>T : T
>cb : (value: T) => boolean
>value : T
>T : T
>Iterable : Iterable<T>
>T : T

declare function reduce<T>(this: Iterable<T>, cb: (memo: T, value: T) => T, initial: T): T;
>reduce : <T>(this: Iterable<T>, cb: (memo: T, value: T) => T, initial: T) => T
>T : T
>this : Iterable<T>
>Iterable : Iterable<T>
>T : T
>cb : (memo: T, value: T) => T
>memo : T
>T : T
>value : T
>T : T
>T : T
>initial : T
>T : T
>T : T

[1, 2, 3]
>[1, 2, 3]    :: map(x => x * 2)    :: filter(x => x > 2)    :: reduce((x, y) => x + y, 0) : number
>[1, 2, 3]    :: map(x => x * 2)    :: filter(x => x > 2) : Iterable<number>
>[1, 2, 3]    :: map(x => x * 2) : Iterable<number>
>[1, 2, 3] : number[]
>1 : 1
>2 : 2
>3 : 3

    :: map(x => x * 2)
>map : any
>x => x * 2 : (x: number) => number
>x : number
>x * 2 : number
>x : number
>2 : 2

    :: filter(x => x > 2)
>filter : any
>x => x > 2 : (x: number) => boolean
>x : number
>x > 2 : boolean
>x : number
>2 : 2

    :: reduce((x, y) => x + y, 0);
>reduce : any
>(x, y) => x + y : (x: number, y: number) => number
>x : number
>y : number
>x + y : number
>x : number
>y : number
>0 : 0

